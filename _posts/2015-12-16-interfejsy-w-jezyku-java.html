---
layout: default
title: Interfejsy w języku Java
excerpt: "W artykule przeczytasz o interfejsach. Poznasz interfejs ze standardowej
  biblioteki Java. Dowiesz się czym różni się interfejs od jego implementacji.
  Przeczytasz też o tym dlaczego używanie interfejsów uważane jest w większości
  przypadków za dobrą praktykę. Jak zwykle na koniec będziesz miał także proste
  zadanie do wykonania. Do kodu! :)\r\n\r\n"
date: '2015-12-16 19:54:10 +0100'
categories:
- Kurs programowania Java
---
<p>W artykule przeczytasz o interfejsach. Poznasz interfejs ze standardowej biblioteki Java. Dowiesz się czym różni się interfejs od jego implementacji. Przeczytasz też o tym dlaczego używanie interfejsów uważane jest w większości przypadków za dobrą praktykę. Jak zwykle na koniec będziesz miał także proste zadanie do wykonania. Do kodu! :)</p>
<p><a id="more"></a><a id="more-186"></a></p>
<p>[idea]To jest jeden z artykułów w ramach <a href="http://www.samouczekprogramisty.pl/kurs-programowania-java/">darmowego kursu programowania w Javie</a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[/idea]</p>
<h1>Interfejs</h1><br />
Wyobraź sobie kuchenkę mikrofalową. Kuchenka ma zestaw przycisków, parę pokręteł możliwe, że dodatkowy wyświetlacz. Ten zestaw to nic innego jak właśnie interfejs (ang. interface). Interfejs to&nbsp; zestaw &bdquo;mechanizmów&rdquo; służących do interakcji, w tym przypadku z kuchenką mikrofalową.</p>
<p>Pojęcie interfejsu można także przenieść do świata programowania. Mówimy wówczas o tak zwanym API (ang. <em>Application Programming Interface</em>).</p>
<p>Interfejs w kontekście programowania w języku Java to zestaw metod bez ich implementacji (bez kodu definiującego zachowanie metody)[1. Wyjątkiem tutaj są tak zwane metody domyślne o których przeczytasz niżej.] . Właściwa implementacja metod danego interfejsu znajduje się w klasie implementującej dany interfejs.</p>
<p>W języku Java do definiowani interfejsów używamy słowa kluczowego <code>interface</code>. Interfejsy, podobnie jak klasy, definiujemy w osobnych plikach. Nazwa pliku musi odpowiadać nazwie interfejsu.</p>
<pre class="lang:default decode:true">public interface Clock {<br />
    long secondsElapsedSince(Date date);<br />
}</pre><br />
Powyżej mamy przykład interfejsu o nazwie <code>Clock</code>, który ma jedną metodę <code>secondsElapsedSince</code>, która przyjmuje argument typu <code>Date</code>[2. <code>java.util.Date</code> jest jednym z typów z bilblioteki standardowej służącym do przedstawiania czasu.] i zwraca wynik typu <code>long</code> mówiący o liczbie sekund, która minęła od czasu przekazanego w argumencie.</p>
<p>Wszystkie metody zawarte w interfejsie zawsze są publiczne więc w tym przypadku można ominąć słowo kluczowe <code>public</code>, nie jest potrzebne.</p>
<p>Poza zwykłymi metodami w interfejsie mogą się znajdować</p>
<ul>
<li>metody domyślne,</li>
<li>metody statyczne,</li>
<li>stałe.</li><br />
</ul><br />
Więcej o metodach statycznych możesz przeczytać w <a href="http://www.samouczekprogramisty.pl/pierwszy-program-w-java/">artykule opisującym pierwszy program w języku Java</a>. Nie jest to dla Ciebie nic nowego. Metody domyślne i stałe wymagają dodatkowego wyjaśnienia.</p>
<h2>Metody domyślne</h2><br />
Istnieje możliwość zdefiniowania tak zwanych metod domyślnych. Metody te mogą mieć właściwą implementacje w ciele interfejsu. Metody takie poprzedzone są słowem kluczowym <code>default</code> jak w przykładzie poniżej</p>
<pre class="lang:default decode:true ">public interface MicrowaveOven {<br />
    void start();</p>
<p>    void setDuration(int durationInSeconds);</p>
<p>    boolean isFinished();</p>
<p>    void setPower(int power);</p>
<p>    default String getName() {<br />
        return "MicrovaweOwen";<br />
    }<br />
}</pre><br />
Klasy, które implementują interfejs mogą nadpisać metodę domyślną.</p>
<h2>Wartości niezmienne i stałe</h2></p>
<pre class="lang:default decode:true ">int counter = 123;</pre><br />
<code>counter</code> to zmienna. Do zmiennej <code>counter</code> możemy przypisać nową wartość:</p>
<pre class="lang:default decode:true ">counter = counter + 1;</pre><br />
Wartości niezmienne w odróżnieniu od zmiennych poprzedzamy słowem kluczowym <code>final</code>. Poniżej możesz zobaczyć przykład klasy z atrybutem, którego wartości nie możemy przypisać na nowo. Atrybuty tego typu możemy inicjalizować jak w przykładzie poniżej: bezpośrednio bądź w ciele konstruktora.</p>
<pre class="lang:default decode:true">public class Calculator implements {<br />
    public final double PI = 3.14;<br />
    public final double SQRT_2;</p>
<p>    public Calculator() {<br />
        SQRT_2 = Math.sqrt(2);<br />
    }<br />
}</pre><br />
Wartości niezmienne, podobnie jak metody, mogą być przypisane do instancji bądź klasy. Jeśli taka wartość przypisana jest do klasy mówimy wówczas o stałej. Jeśli chcemy aby stała była przypisana do klasy poprzedzamy ją słowem kluczowym <code>static</code>.</p>
<p>Do stałych wartość możemy przypisać wyłącznie raz - podczas inicjalizacji klasy. Zgodnie z konwencją nazewniczą stałe piszemy wielkimi literami.</p>
<pre class="lang:default decode:true ">public interface Cat {<br />
    int NUMBER_OF_PAWS = 4;<br />
}</pre><br />
W interfejsie powyżej mamy stałą, która pokazuje ile łap ma kot. Domyślnie wszystkie atrybuty interfejsu są stałymi publicznymi przypisanymi do interfejsu więc słowa kluczowe <code>public static final</code> mogą zostać pominięte.</p>
<h1>Implementacja interfejsu</h1><br />
Sam interfejs nie jest zbyt wiele warty bez jego implementacji. Poniżej możesz zobaczyć przykładową, prostą implementację.</p>
<pre class="lang:default decode:true ">public interface Clock {<br />
    long secondsElapsedSince(Date date);<br />
}</p>
<p>public class BrokenClock implements Clock {<br />
    public long secondsElapsedSince(Date date) {<br />
        return 300;<br />
    }<br />
}</pre><br />
Klasa <code>BrokenClock</code> implementuje interfejs <code>Clock</code>. Zwróć uwagę na słowo kluczowe <code>implements</code>. Używamy go żeby pokazać że klasa <code>BrockenClock</code> implementuje interfejs <code>Clock</code>.</p>
<p>W języku Java jedna klasa może implementować wiele interfejsów. W takim przypadku klasa implementująca musi definiować metody wszystkich interfejsów, które implementuje [3. Oczywiście jest od tego wyjątek, o klasach abstrakcyjnych przeczytasz w innym artykule.].</p>
<h1>Dziedziczenie interfejsów</h1><br />
Dziedziczenie to temat na osobny, obszerny artykuł. Jednak już teraz wspomnę, że interfejsy mogą dziedziczyć po innych interfejsach. Dziedziczenie oznaczane jest słowem kluczowym <code>extends</code>. Interfejs, który dziedziczy po innych interfejsach zawiera wszystkie metody z tych interfejsów.</p>
<pre class="lang:default decode:true ">public interface Cat {<br />
    int NUMBER_OF_PAWS = 4;</p>
<p>    String getName();<br />
}</p>
<p>public interface LasagnaEater {<br />
    String getLasagnaRecipe();<br />
}</p>
<p>public interface FatCat extends Cat, LasagnaEater {<br />
    double getWeight();<br />
}</pre><br />
W przykładzie powyżej klasa implementująca interfejs <code>FatCat</code>, musi zaimplementować 3 metody:</p>
<ul>
<li><code>String getName()</code>,</li>
<li><code>String getLasagnaRecipe()</code>,</li>
<li><code>duble getWeight()</code>.</li><br />
</ul></p>
<h1>Interfejs znacznikowy</h1><br />
A czy możliwa jest sytuacja kiedy interfejs nie ma żadnej metody? Oczywiście, że tak. Mówimy wówczas o interfejsie znacznikowym. Jak sama nazwa wskazuje służy on do oznaczenia, danej klasy. Dzięki temu możesz przekazać zestaw dodatkowych informacji. Przykładem takiego interfejsu jest <code>java.io.Serializable</code>, którego używamy aby dać znać kompilatorowi, że dana klasa jest serializowalna (o serializacji przeczytasz w innym artykule).</p>
<h1>Interfejs a typ obiektu</h1><br />
Każdy obiekt w języku Java może być przypisany do zmiennej określonego typu. W najprostszym przypadku jest to jego klasa.</p>
<p>Interfejsy pozwalają na przypisane obiektu do zmiennej typu interfejsu. Wydaje się to trochę skomplikowane jednak mam nadzieję, że przykład poniżej pomoże w zrozumieniu tego tematu.</p>
<pre class="lang:default decode:true ">public class Garfield implements FatCat {<br />
    // implementacja metod<br />
}</pre><br />
&nbsp;</p>
<p><a href="http://www.samouczekprogramisty.pl/wp-content/uploads/2015/12/dziedziczenie.png"><img class="aligncenter size-thumbnail wp-image-187" src="http://www.samouczekprogramisty.pl/wp-content/uploads/2015/12/dziedziczenie-150x150.png" alt="dziedziczenie" width="150" height="150" /></a></p>
<pre class="lang:default decode:true">Garfield garfield = new Garfield();<br />
FatCat fatCat = new Garfield();<br />
Cat cat = new Garfield();<br />
LasagnaEater lasagnaEater = new Garfield();</pre><br />
Instancję klasy <code>Garfield</code> możemy przypisać zarówno do zmiennej klasy <code>Garfield</code> jak i każdego z interfejsów, który ta klasa implementuje (bezpośrednio lub pośrednio). Chociaż w trakcie wykonania programu każdy z obiektów jest tego samego typu (instancja klasy <code>Garfield</code>), to w trakcie kompilacji sprawa wygląda trochę inaczej:</p>
<ul>
<li>na obiekcie <code>garfield</code> możemy wykonać wszystkie metody udostępnione w klasie <code>Garfield</code> i interfejsach, które ta klasa implementuje:
<ul>
<li><code>getWeight()</code>,</li>
<li><code>getName()</code>,</li>
<li><code>getLasagnaReceipe()</code>.</li><br />
</ul><br />
</li></p>
<li>na obiekcie <code>fatCat</code> możemy wykonać wszystkie metody udostępnione w interfejsie <code>FatCat</code> i interfejsach po których dziedziczy:
<ul>
<li><code>getWeight()</code>,</li>
<li><code>getName()</code>,</li>
<li><code>getLasagnaReceipe()</code>.</li><br />
</ul><br />
</li></p>
<li>na obiekcie <code>cat</code> możemy wykonać wyłącznie metody z interfejsu <code>Cat</code>:
<ul>
<li><code>getName()</code>.</li><br />
</ul><br />
</li></p>
<li>na obiekcie <code>lasagnaEater</code> możemy wykonać wyłącznie metody z interfejsu <code>LasagnaEater</code>:
<ul>
<li><code>getLasagnaReceipe()</code>.</li><br />
</ul><br />
</li><br />
</ul></p>
<h1>Zastosowania interfejsów</h1><br />
Do czego właściwie potrzebne są nam interfejsy? Czy nie jest to po prostu zestaw dodatkowych linijek kodu, które trzeba napisać i nic one nie wnoszą? Otóż nie.</p>
<p>Interfejsy w bardzo prosty sposób ułatwiają różnego rodzaju integrację różnych fragmentów kodu. Wyobraź sobie sytuację, w której Piotrek pisze program obliczający średnią temperaturę w każdym z województw. Współpracuje on z Kasią, która pisze program udostępniający aktualną temperaturę w danej miejscowości.</p>
<p>Aby Piotrek mógł napisać swój program musi skorzystać z programu Kasi. Musi się z nim zintegrować. Taką integrację ułatwiają właśnie interfejsy.</p>
<p>Piotrek z Kasią uzgadniają, że będą używali następującego interfejsu</p>
<pre class="lang:default decode:true ">public interface Thermometer {<br />
    double getCurrentTemperatureFor(String city);<br />
}</pre><br />
Dzięki niemu Piotrek może pisać swój program równolegle z Kasią.</p>
<p>Co więcej może się okazać, że implementacja Kasi nie jest zbyt dokładna. Ania implementuje ten sam interfejs ale temperatury przez nią zwracane są dokładniejsze. Wówczas Piotrek w ogóle nie musi zmieniać swojego programu. Wystarczy, ze użyje innej implementacji interfejsu <code>Thermometer</code> dostarczonej przez Anię.</p>
<p>To właśnie jest kolejna zaleta interfejsów. Dzięki nim możemy pisać programy, które możemy w łatwiejszy sposób modyfikować. Interfejsy jasno oddzielają komponenty programu. Dzięki takiemu podejściu komponenty można z łatwością wymieniać.</p>
<h1>Zadanie</h1><br />
Napisz dwie klasy implementujące interfejs <code>Computation</code>. Niech jedna z implementacji przeprowadza operację dodawania, druga mnożenia.</p>
<pre class="lang:default decode:true ">public interface Computation {<br />
    double compute(double argument1, double argument2);<br />
}</pre><br />
Użyj obu implementacji do uzupełnienia programu poniżej</p>
<pre class="lang:default decode:true ">public class Main {<br />
    public static void main(String[] args) {<br />
        Main main = new Main();<br />
        Computation computation;</p>
<p>        if (main.shouldMultiply()) {<br />
            computation = new Multiplication(); // zaimplementuj brakującą klasę<br />
        }<br />
        else {<br />
            computation = new Addition(); // zaimplementuj brakującą klasę<br />
        }</p>
<p>        double argument1 = main.getArgument();<br />
        double argument2 = main.getArgument();</p>
<p>        double result = computation.compute(argument1, argument2);<br />
        System.out.println("Wynik: " + result);<br />
    }</p>
<p>    private boolean shouldMultiply() {<br />
        return false; // tutaj zapytaj użytkownika co chce zrobić (mnożenie czy dodawanie)<br />
    }</p>
<p>    private double getArgument() {<br />
        return 0; // tutaj pobierz liczbę od użytkownika<br />
    }<br />
}</pre><br />
Program po uruchomieniu powinien zapytać użytkownika jaką operację chce wykonać, następnie pobrać dwa argumenty niezbędne do wykonania tej operacji. Ostatnią linijką powinien być wynik dodawania/mnożenia wyświetlony użytkownikowi. Przygotowałem też dla Ciebie <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/07_interfejsy/src/main/java/pl/samouczekprogramisty/kursjava/interfaces/exercise" target="_blank" rel="noopener">przykładowe rozwiązanie zadania</a>, pamiętaj jednak, że rozwiązując je samodzielnie nauczysz się najwięcej.</p>
<h1>Materiały dodatkowe</h1><br />
Oczywiście nie wyczerpaliśmy tematu mimo sporej objętości artykułu. Zachęcam do samodzielnego pogłębiania wiedzy korzystając z materiałów dodatkowych. Specyfikacja Języka Java jest w języku angielskim.</p>
<ul>
<li><a href="https://pl.wikipedia.org/wiki/Interfejs_%28programowanie_obiektowe%29" target="_blank" rel="noopener">Opis interfejsu na Wikipedii</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html" target="_blank" rel="noopener">Rozdział w Java Language Specification dotyczący interfejsów</a></li>
<li><a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/07_interfejsy/src/main/java/pl/samouczekprogramisty/kursjava/interfaces" target="_blank" rel="noopener">Kod źródłowy przykładów użytych w artykule</a></li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Dzisiaj poruszyliśmy bardzo wiele zagadnień. Dowiedziałeś się o interfejsach, przeczytałeś o ich przeznaczeniu. Poznałeś też kilka nowych słów kluczowych w języku Java. Wystarczająca dawka wiedzy jak na jeden dzień :)</p>
<p>Mam nadzieję, że artykuł był dla Ciebie ciekawy, jeśli cokolwiek nie było zrozumiałe bądź wymaga dokładniejszego wyjaśnienia daj znać, na pewno pomogę.</p>
<p>Jak zwykle na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze swoimi znajomymi, zależy mi na dotarciu do jak największej liczby osób, które chcą nauczyć się programowania :) Zapraszam także na <a href="https://facebook.com/SamouczekProgramisty" target="_blank" rel="noopener">SamouczekProgramisty</a> na facebooku. Możesz też zapisać się do mojego newslettera.</p>
<p>Do następnego razu!</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości <em>FreeImages.com/Piotr Lewandowski</em>.</p>
