---
layout: post
status: publish
published: true
title: Dziedziczenie w języku Java
excerpt: "W innych artykułach omawiałem pewne aspekty programowania obiektowego. Wiesz
  już o interfejsach i dlaczego warto ich używać. Dzisiaj przeczytasz o dziedziczeniu.
  Bez dziedziczenia nie można mówić o programowaniu obiektowym w Javie. Dowiesz
  się czym jest <code>Object</code>, dlaczego dziedziczenie jest ważne i kiedy
  powinniśmy go używać. Przeczytasz o przeciążaniu i nadpisywaniu metod. Poznasz też
  słowa kluczowe <code>abstract</code> i <code>final</code>. Do kodu!\r\n\r\n"
wordpress_id: 200
wordpress_url: http://www.samouczekprogramisty.pl/?p=200
date: '2016-01-24 13:47:46 +0100'
date_gmt: '2016-01-24 12:47:46 +0100'
categories:
- Kurs programowania Java
tags: []
---
<p>W innych artykułach omawiałem pewne aspekty programowania obiektowego. Wiesz już o interfejsach i dlaczego warto ich używać. Dzisiaj przeczytasz o dziedziczeniu. Bez dziedziczenia nie można mówić o programowaniu obiektowym w Javie. Dowiesz się czym jest <code>Object</code>, dlaczego dziedziczenie jest ważne i kiedy powinniśmy go używać. Przeczytasz o przeciążaniu i nadpisywaniu metod. Poznasz też słowa kluczowe <code>abstract</code> i <code>final</code>. Do kodu!</p>
<p><a id="more"></a><a id="more-200"></a></p>
<p>[idea]To jest jeden z artykułów w ramach <a href="http://www.samouczekprogramisty.pl/kurs-programowania-java/">darmowego kursu programowania w Javie</a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[/idea]</p>
<h1>Dziedziczenie</h1><br />
Na początku postaram się wyjaśnić czym właściwie jest dziedziczenie. Nie jest to nic skomplikowanego.</p>
<p>Niektóre obiekty mogą mieć między sobą dużo wspólnego. Na przykład zarówno samochód osobowy jak i samochód ciężarowy mają silnik, kierownicę, drzwi, światła itd. Co prawda każdy z tych elementów może być różny, jednak bez wątpienia oba te pojazdy mają wiele wspólnego. Oba są pojazdami. Możemy powiedzieć, że samochód ciężarowy rozszerza (ang. <em>extends</em>) funkcjonalność pojazdu.</p>
<p>W naszym przykładzie pojazd możemy uznać, za tak zwaną klasę bazową (lub &bdquo;nadklasę&rdquo;). Natomiast samochód osobowy i samochód ciężarowy rozszerzają funkcjonalność pojazdu. Możemy też powiedzieć, że każda z nich jest klasą pochodną (lub &bdquo;podklasą&rdquo;). Proszę spójrz na przykład:</p>
<pre class="lang:default decode:true ">public class Vehicle {<br />
}</p>
<p>public class Car extends Vehicle {<br />
}</p>
<p>public class Truck extends Vehicle {<br />
}</pre><br />
Dziedziczenie jest jedną z podstaw programowania obiektowego (nie tylko w języku Java). Dzięki dziedziczeniu możemy ograniczyć ilość zduplikowanego kodu poprzez definiowanie atrybutów, konstruktorów, metod w klasach bazowych.</p>
<p>Dziedziczenie może być wielopoziomowe, jednak w języku Java zawsze bezpośrednio możemy dziedziczyć od jednej klasy.</p>
<pre class="lang:default decode:true ">public class Vehicle {<br />
}</p>
<p>public class Car extends Vehicle {<br />
}</p>
<p>public class SUV extends Car {<br />
}</pre><br />
W przykładzie powyżej <code>SUV</code> dziedziczy po klasie <code>Car</code>. Klasa <code>Car</code> jest podklasą klasy <code>Vehicle</code>. Zatem pośrednio <code>SUV</code> także dziedziczy po klasie <code>Vehicle</code>.</p>
<h1>Modyfikatory dostępu</h1><br />
Dzięki dziedziczeniu możemy mieć dostęp do metod, atrybutów, konstruktorów klas po których dziedziczymy. Do określenia czy dany element może być dostępny w ramach podklasy służą modyfikatory dostępu.</p>
<p>Do tej pory poznałeś modyfikatory dostępu takie jak:</p>
<ul>
<li><code>public</code> - element oznaczony tym modyfikatorem dostępny jest "z zewnątrz" obiektu, stanowi jego interfejs,</li>
<li><code>private</code> - element oznaczony tym modyfikatorem jest dostępna wyłącznie wewnątrz obiektu, także klasy pochodne nie mają do niego dostępu.</li><br />
</ul><br />
W przypadku dziedziczenia znaczenie ma także modyfikator <code>protected</code>. Element poprzedzony tym atrybutem może być dostępny wewnątrz klasy bądź przez każdą inną klasę która po niej dziedziczy[1. Istnieje też "brak modyfikatora dostępu" jednak na początek możemy tą sytuację pominąć. Opiszę to w osobnym artykule.]</p>
<h1>Przesłonięcie metody</h1><br />
Łatwo sobie wyobrazić sytuację, w której metoda o tej samej sygnaturze występuje zarówno w klasie bazowej jak i klasie pochodnej. W tej sytuacji mówimy o tym, że klasa pochodna przesłania metodę z klasy bazowej (ang. <em>override</em>). Proszę spójrz na przykład poniżej.</p>
<pre class="lang:default decode:true ">public class Vehicle {<br />
    public void startEngine() {<br />
        System.out.println("Engine starts. Brum brum brum.");<br />
    }<br />
}</p>
<p>public class Car extends Vehicle {<br />
    public void startEngine() {<br />
        System.out.println("Force driver to fasten seat belts.");<br />
    }<br />
}</pre><br />
W naszym przykładzie wywołanie metody <code>startEngine</code> na obiekcie typu <code>Car</code> zmusi kierowcę do zapięcia pasów (wyświetli się komunikat <code>Force driver to fasten seat belts</code>). Jeśli tą samą metodę wywołamy na instancji obiektu klasy Vehicle wówczas pojawi się komunikat <code>Engine starts. Brum brum brum.</code>.</p>
<p>Co jeśli chcielibyśmy nieznacznie zmodyfikować oryginalną metodę? Jest na to sposób. Słowo kluczowe <code>super</code> pozwala na wywołanie nadpisanej metody z klasy bazowej. Rozszerzając przykład powyżej moglibyśmy napisać taki fragment kodu:</p>
<pre class="lang:default decode:true ">public class Car extends Vehicle {<br />
    public void startEngine() {<br />
        super.startEngine();<br />
        System.out.println("Force driver to fasten seat belts.");<br />
    }<br />
}</pre><br />
W takim przypadku wywołanie metody <code>startEngine</code> na instancji obiektu <code>Car</code> na początku wywoła tą metodę z klasy bazowej (wyświetli się komunikat <code>Engine starts...</code>) następnie pokazany zostanie komunikat <code>Force driver...</code> (zachęcam do eksperymentowania z IDE).</p>
<h1>Konstruktory a dziedziczenie</h1><br />
Konstruktory w przypadku dziedziczenia zachowują się tak samo jak metody. Także możemy wywołać konstruktor z klasy bazowej wewnątrz klasy dziedziczącej używając słowa kluczowego <code>super</code> (jeśli pozwala na to modyfikator dostępu).</p>
<p>Klasa pochodna musi mieć możliwość wywołania konstruktora klasy bazowej. Jeśli tego nie robi domyślnie wywoływany jest konstruktor bezparametrowy</p>
<pre class="lang:default decode:true">public class Animal {<br />
    public Animal() {<br />
    }<br />
}</p>
<p>public class Dog extends Animal {<br />
    public Dog() {<br />
        super();<br />
    }<br />
}</pre><br />
W powyższym przykładzie wewnątrz konstruktora klasy <code>Dog</code> wywołujemy konstruktor klasy <code>Animal</code> wywołując <code>super()</code>. Jak napisałem wyżej możemy pominąć to wywołanie, wówczas kompilator zrobi to za nas. Ma to pewne konsekwencje. Jeśli w klasie bazowej zdefiniujemy konstruktor z parametrami wówczas konstruktor bezparametrowy nie zostanie utworzony automatycznie.</p>
<p>W takich przypadkach w konstruktorach klas pochodnych musimy wywołać konstruktor klasy bazowej. Pokazałem to w przykładzie poniżej:</p>
<pre class="lang:default decode:true">public class Vehicle {<br />
    private int numberOfWheels;<br />
    private Engine engine;</p>
<p>    public Vehicle(Engine engine, int numberOfWheels) {<br />
        this.engine = engine;<br />
        this.numberOfWheels = numberOfWheels;<br />
    }<br />
}</p>
<p>public class Car extends Vehicle {<br />
    private static final int NUMBER_OF_WHEELS = 4;</p>
<p>    public Car(Engine engine) {<br />
        super(engine, NUMBER_OF_WHEELS);<br />
    }<br />
}</pre><br />
Jak widzisz w przykładzie powyżej klasa <code>Car</code> nie musi definiować konstruktora z taką samą liczbą parametrów jak klasa bazowa, ale musi wywołać konstruktor klasy <code>Vehicle</code> i przekazać dwa parametry. Dzieje się tak, ponieważ w klasie <code>Vehicle</code> jest tylko konstruktor z dwoma parametrami.</p>
<h1>Klasy abstrakcyjne</h1><br />
Czasami może wystąpić sytuacja, w której klasa bazowa jest swego rodzaju uogólnieniem, abstrakcją, która nie ma sensu bez konkretnych implementacji. Wówczas możemy mówić o klasie abstrakcyjnej.</p>
<p>Nie ma możliwości stworzenie instancji klasy abstrakcyjnej. W naszym przykładzie klasa Vehicle mogłaby być klasą abstrakcyjną. Klasy abstrakcyjne poprzedzamy słowem kluczowym abstract. Proszę spójrz na przykład poniżej.</p>
<pre class="lang:default decode:true ">public abstract class Vehicle {<br />
    private int numberOfWheels;<br />
    private Engine engine;</p>
<p>    public Vehicle(Engine engine, int numberOfWheels) {<br />
        this.engine = engine;<br />
        this.numberOfWheels = numberOfWheels;<br />
    }<br />
}</p>
<p>public class Car extends Vehicle {<br />
    private static final int NUMBER_OF_WHEELS = 4;</p>
<p>    public Car(Engine engine) {<br />
        super(engine, NUMBER_OF_WHEELS);<br />
    }<br />
}</pre><br />
Jak widzisz klasa abstrakcyjna może mieć konstruktor, jednak służy on tylko do tego, żeby uniknąć duplikacji kodu w klasach pochodnych. Klasa <code>Car</code> używa konstruktora zdefiniowanego w abstrakcyjnej klasie <code>Vehicle</code>.</p>
<h1>Klasy i metody finalne</h1><br />
Możliwość dziedziczenia i nadpisywania metod daje bardzo duże możliwości. Wyobraź sobie następujący kod:</p>
<pre class="lang:default decode:true ">public interface BankAccount {<br />
    void deposit(BigDecimal amount);<br />
    void withdraw(BigDecimal amount);<br />
}</p>
<p>public class Transfer {<br />
    public void transferMoney(BankAccount source, BankAccount destination, BigDecimal amount) {<br />
        source.withdraw(amount);<br />
        destination.deposit(amount);<br />
    }<br />
}</pre><br />
Co stanie się jeśli programista utworzy nową klasę jak w przykładzie poniżej?</p>
<pre class="lang:default decode:true ">public class FraudTransfer extends Transfer{<br />
    public void transferMoney(BankAccount source, BankAccount destination, BigDecimal amount) {<br />
        destination.deposit(amount);<br />
    }<br />
}</pre><br />
Przy takiej implementacji konto docelowe zostałoby zasilone dodatkową kwotą jednak ta kwota nie byłaby pobrana z konta źródłowego. Niedobrze.</p>
<p>W takich przypadkach możemy użyć słowa kluczowego <code>final</code>. Słowo to umieszczone przed klasą oznacza, że nie możemy po danej klasie dziedziczyć. W przypadku metody oznacza, że metoda nie może zostać nadpisana.</p>
<p>Dla przykładu klasy w pakiecie <code>java.lang</code> są finalne. Nie można nadpisać ich implementacji.</p>
<h1>Klasa <code>java.lang.Object</code></h1><br />
Teraz już wiesz czym jest dziedziczenie. A wiesz, że używałeś go od pierwszej lekcji nauki języka Java? :)</p>
<p>Z jednego z poprzednich artykułów wiesz o tym, że kompilator dodaje automatycznie konstruktor bezparametrowy jeśli nie zdefiniujesz żadnego w swojej klasie. Podobnie jest z dziedziczeniem, każda klasa domyślnie dziedziczy po klasie <code>java.lang.Object</code> (chyba, że zdefiniujesz inną klasę po której dziedziczysz).</p>
<p>Dzięki tej klasie masz dostęp do zestawu metod, które zdefiniowane są w ciele klasy Object. Na przykład metoda <code>String toString()</code> ma swoją podstawową implementację w klasie <code>Object</code> [2. Domyślna implementacja pokazuje nazwę klasy wraz z pakietem oraz jej adres w pamięci np. <code>pl.samouczekprogramisty.kursjava.cars.X@14ae5a5</code>].</p>
<h1>Dobre praktyki</h1><br />
Dziedziczenie to bardzo pomocny mechanizm. Jak napisałem wcześniej pozwala nam na uniknięcie duplikowania kodu. Jednak ma też swoje wady. Hierarchie dziedziczenia, które mają dużo poziomów mogą stać się mało czytelne. Tak zagmatwany kod może stać się trudny w utrzymaniu. Powinniśmy unikać takiej sytuacji.</p>
<p>Nie ma tu jasnej reguły, jednak w przypadku gdy w programie występuje wielopoziomowe dziedziczenie starałbym się uprościć taki kod. Bardzo często mówi się o preferowaniu kompozycji nad dziedziczeniem. Kompozycja to nic innego jak zawarcie innego obiektu jako atrybut naszej klasy. Kompozycja w wielu przypadkach potrafi uprościć skomplikowane hierarchie dziedziczenia.</p>
<h1>Zadanie</h1><br />
Na koniec mam dla Ciebie zadanie do wykonania, przećwiczysz w nim zagadnienia omówione w tym artykule.</p>
<p>Napisz program, w którym zasymulujesz hierarchię dziedziczenia zwierząt. Stwórz abstrakcyjną klasę <code>Animal</code>, po której będą dziedziczyły klasy <code>Fish</code> i <code>Mammal</code>. Wszystkie te klasy powinny być abstrakcyjne. Następnie stwórz konkretne klasy które dziedziczą po <code>Fish</code> i <code>Mammal</code>. Będą to odpowiednio <code>Goldfish</code> i <code>Human</code>.</p>
<p>Nadpisz metodę <code>toString</code> w każdej z tych klas. Stwórz instancje obu tych klas i wyświetl je na konsoli.</p>
<p>Jeśli miałbyś problemy z zadaniem możesz spojrzeć na <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/08_dziedziczenie/src/main/java/pl/samouczekprogramisty/kursjava/inheritance/exercise" target="_blank" rel="noopener noreferrer">przykładowe rozwiązanie</a>.</p>
<h1>Dodatkowe materiały</h1><br />
Poniżej przygotowałem dla Ciebie zestaw linków z dodatkowymi materiałami, część z nich jest w języku angielskim.</p>
<ul>
<li><a href="https://pl.wikipedia.org/wiki/Dziedziczenie_%28programowanie%29" target="_blank" rel="noopener noreferrer">https://pl.wikipedia.org/wiki/Dziedziczenie_%28programowanie%29</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html</a></li>
<li><a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/08_dziedziczenie/src/main/java/pl/samouczekprogramisty/kursjava/inheritance" target="_blank" rel="noopener noreferrer">kod źródłowy przykładów z tego artykułu</a></li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Bardzo się cieszę, że przeczytałeś artykuł do końca. Dzisiaj dowiedziałeś się czegoś więcej o dziedziczeniu. Poznałeś słowa kluczowe <code>abstract</code> i <code>final</code>. Wiesz już czym jest nadpisywanie metod czy klasa bazowa. Innymi słowy poznałeś kolejny zestaw narzędzi niezbędnych dla każdego programisty. Tak trzymaj! :)</p>
<p>Na koniec bardzo proszę Cię o podzielenie się artykułem ze swoimi znajomymi, którzy są zainteresowani taką tematyką. Jak zwykle zależy mi na tym, żeby z blogiem i jego zawartością dotrzeć do jak największej liczby czytelników takich jak Ty :) Jeśli jeszcze tego nie zrobiłeś prosiłbym o polubienie strony na facebooku.</p>
<p>Do następnego razu!</p>
<p>[FM_form id="3"]</p>
