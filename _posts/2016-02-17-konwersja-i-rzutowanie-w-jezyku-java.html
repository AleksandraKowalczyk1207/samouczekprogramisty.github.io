---
layout: post
status: publish
published: true
title: Konwersja i rzutowanie w języku Java
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "Cześć! W dzisiejszym artykule przeczytasz o konwersji i rzutowaniu w języku
  Java. Przeczytasz o konwersji obiektów oraz typów prostych. Dowiesz
  się czym jest czym jest konwersja bezstratna. Przeczytasz o konwersji typów
  do typu <code>String</code>. Poznasz mechanizm boxing'u oraz unboxing'u. Innymi
  słowy, dziś kolejna porcja informacji na temat języka Java :)\r\n\r\n"
wordpress_id: 242
wordpress_url: http://www.samouczekprogramisty.pl/?p=242
date: '2016-02-17 17:48:51 +0100'
date_gmt: '2016-02-17 16:48:51 +0100'
categories:
- Kurs programowania Java
tags: []
comments: []
---
<p>Cześć! W dzisiejszym artykule przeczytasz o konwersji i rzutowaniu w języku Java. Przeczytasz o konwersji obiektów oraz typów prostych. Dowiesz się czym jest czym jest konwersja bezstratna. Przeczytasz o konwersji typów do typu <code>String</code>. Poznasz mechanizm boxing'u oraz unboxing'u. Innymi słowy, dziś kolejna porcja informacji na temat języka Java :)</p>
<p><a id="more"></a><a id="more-242"></a></p>
<p>[idea]To jest jeden z artykułów w ramach <a href="http://www.samouczekprogramisty.pl/kurs-programowania-java/">darmowego kursu programowania w Javie</a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[/idea]</p>
<h1>Rzutowanie</h1><br />
Zaczniemy od rzutowania (ang. <em>cast</em>). Jak już wiesz kompilator Javy ma pewną wiedzę na temat tego jaki rodzaj obiektu kryje się pod daną referencją w trakcie kompilacji. Wie to z typu zmiennej do której przypisany jest dany obiekt. Jednak możliwa jest sytuacja kiedy pod referencją typu X przypisany jest obiekt typu Y jak w przykładzie poniżej:</p>
<pre class="lang:default decode:true ">public void differentTypes() {<br />
    Object objectInstance = new Object();<br />
    Object stringInstance = "string";<br />
}</pre><br />
Obie referencje są typu <code>Object</code> jednak druga z nich przechowuje zmienną typu <code>String</code>. Jest to w 100% poprawny kod. Jednak jeśli na zmiennej <code>stringInstance</code> chciałbyś wywołać metodę, którą implementuje klasa <code>String</code> a nie ma jej w klasie <code>Object</code> skończy się to błędem kompilacji:</p>
<pre class="lang:default decode:true">Error:(15, 23) java: cannot find symbol<br />
  symbol: method length()<br />
  location: variable stringInstance of type java.lang.Object</pre><br />
Jak zatem wywołać taką metodę? Przecież jesteśmy pewni, że pod zmienną <code>stringInstance</code> kryje się obiekt typu <code>String</code>. Tutaj z pomocą przychodzi rzutowanie. Java pozwala rzutować typ A na typ B używając wyrażenia rzutowania, możesz je zobaczyć w przykładzie poniżej:</p>
<pre class="lang:default decode:true ">public void differentTypes() {<br />
    Object objectInstance = new Object();<br />
    Object stringInstance = "string";</p>
<p>    String realString = (String) stringInstance;<br />
    realString.length();<br />
}</pre><br />
Oczywiście nie każde rzutowanie jest poprawne. W przykładzie poniżej możesz zobaczyć błędne rzutowanie z typu Object na typ <code>String</code>. Tego typu operacje kończą się wyjątkiem w trakcie wykonania programu:</p>
<pre class="lang:default decode:true">public class RuntimeType {<br />
    public static void main(String[] args) {<br />
        Object[] someMysteriousObjects = new Object[] {"1234", new Object()};</p>
<p>        String castedString = (String) someMysteriousObjects[0];<br />
        String classCastException = (String) someMysteriousObjects[1];<br />
    }<br />
}</pre></p>
<pre class="lang:default decode:true ">Exception in thread "main" java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String<br />
  at pl.samouczekprogramisty.kursjava.RuntimeType.main(RuntimeType.java:8)</pre><br />
Wyjątek mówi tyle, że obiektu typu <code>java.lang.Object</code> nie możemy rzutować do typu <code>java.lang.String</code>. Jakie rzutowanie jest w takim razie dozwolone? Możemy rzutować wyłącznie na typ, który znajduje się hierarchii dziedziczenia danego obiektu. Z tego właśnie powodu rzutowanie <code>String</code> na <code>Object</code> jest dopuszczalne ale odwrotna operacja kończy się błędem.</p>
<p>W jednym z kolejnych artykułów przeczytasz o typach generycznych, które pomagają rozwiązać część sytuacji, kiedy rzutowanie jest potrzebne. W codziennym programowaniu radziłbym unikać tego typu operacji. Z pewnością istnieje inny sposób napisania programu, który pozwoli na uniknięcie rzutowania.</p>
<h1>Konwersja</h1><br />
Rzutowanie to specyficzny przypadek konwersji, jest to konwersja jawna, wymuszona przez programistę. W trakcie niektórych operacji może dochodzić do automatycznej konwersji, konwersji niejawnej. Konwersja niejawna może wystąpić np. podczas wywołania metod czy operacji arytmetycznych. Poniżej przykład konwersji automatycznej, która zachodzi w trakcie wywołania metody:</p>
<pre class="lang:default decode:true">public class WideningConversion {<br />
    public static void main(String[] args) {<br />
        WideningConversion conversion = new WideningConversion();<br />
        int intVariable = Integer.MAX_VALUE;<br />
        long longVariable = Long.MAX_VALUE;</p>
<p>        conversion.methodLongArgument(longVariable);<br />
        conversion.methodLongArgument(intVariable); // extending conversion<br />
    }</p>
<p>    public void methodLongArgument(long argument) {<br />
        System.out.println(argument);<br />
    }<br />
}</pre><br />
Dochodzi do konwersji ponieważ metoda <code>methodLongArgument</code> przyjmuje parametr typu <code>long</code> a jedno z wywołań przyjmuje zmienną typu <code>int</code>. Jest to tak zwana konwersja rozszerzająca. Może być wykonana niejawnie ponieważ podczas takiej konwersji nie zachodzi ryzyko utracenia informacji (o tym dalej). Kompilator robi to automatycznie za programistę. W przykładzie powyżej zmienna <code>intVariable</code> zostałą automatycznie rozszerzone do typu <code>long</code>. Nie utraciliśmy żadnych informacji ponieważ typ <code>long</code> zawsze może pomieścić liczby które przechowuje <code>int</code>. W przykładzie używam zmiennych statycznych <code>MAX_VALUE</code>, które są typu <code>int</code> lub <code>long</code> i trzymają największą liczbę możliwą do przechowywania przez dany typ.</p>
<p>Konwersja w odwrotną stronę wymaga już jawnego rzutowania. Taka konwersja może prowadzić do utraty informacji. Proszę spójrz na przykład:</p>
<pre class="lang:default decode:true">public class NarrowingConversion {<br />
    public static void main(String[] args) {<br />
        NarrowingConversion conversion = new NarrowingConversion();<br />
        int intVariable = Integer.MAX_VALUE;<br />
        long longVariable = Long.MAX_VALUE;<br />
        long longVariableWithoutLoosingInformation = Integer.MAX_VALUE; // automatic conversion from int to long</p>
<p>        conversion.methodIntArgument(intVariable);<br />
        conversion.methodIntArgument((int) longVariable);<br />
        conversion.methodIntArgument((int) longVariableWithoutLoosingInformation);<br />
    }</p>
<p>    public void methodIntArgument(int argument) {<br />
        System.out.println(argument);<br />
    }<br />
}</pre><br />
Jak myślisz co zostanie wypisane na konsoli po uruchomieniu tego programu?</p>
<pre class="lang:default decode:true ">2147483647<br />
-1<br />
2147483647</pre><br />
Dziwne prawda? :) Środkowa linijka to nic innego jak właśnie "utrata informacji", która może zajść w trakcie jawnej konwersji [1. Wartość -1 wynika ze sposobu zapisywania liczb w Javie. Wiesz już o <a href="http://www.samouczekprogramisty.pl/system-dwojkowy/">binarnym zapisie</a>, tutaj wykorzystywana jest jego specyficzna odmiana &ndash; uzupełnienia do dwóch, jeżeli jesteś zainteresowany szczegółami daj znać w komentarzu, skrobnę o tym artykuł :)]. Ostatnia linijka pokazuje, że nie każda konwersja z <code>long</code> do <code>int</code> prowadzi do utraty informacji.</p>
<h2>Konwersja typów zmiennoprzecinkowych do całkowitoliczbowych</h2><br />
Innym przykładem konwersji w której dochodzi do utraty informacji jest konwersja z typów zmiennoprzecinkowych do typów całkowitoliczbowych:</p>
<pre class="lang:default decode:true ">int intValue = (int) 123.123F;<br />
long longValue = (long) 456.456;</pre><br />
W obu przypadkach tracimy informację o ułamku, zostaje wyłącznie część całkowitoliczbowa.</p>
<h2>Automatyczna konwersja podczas przypisania</h2><br />
Podobnie rzecz się ma w przypadku przypisania wartości zmiennej, tutaj także dochodzi do automatycznej konwersji. Poniższy przykład pokazuje kilka możliwych przypadków:</p>
<pre class="lang:default decode:true ">public class AssignmentConversion {<br />
    public static void main(String[] args) {<br />
        long longValue = 123;<br />
        int intValue = (short) 123;<br />
        float floatValue = 12.12F;<br />
        double doubleValue = floatValue;</p>
<p>        System.out.println(longValue);<br />
        System.out.println(intValue);<br />
        System.out.println(floatValue);<br />
        System.out.println(doubleValue);<br />
    }<br />
}</pre><br />
Pierwsza linijka metody <code>main</code> to niejawna konwersja z typu <code>int</code> na <code>long</code> (literały całkowitoliczbowe domyślnie są typu <code>int</code>), kolejna zawiera jawne rzutowanie 123 na typ <code>short</code>, które następnie konwertowane jest niejawnie z powrotem na typ <code>int</code>. Ostatni przykład to konwersja z typu <code>float</code> do <code>double</code>.</p>
<h1>Automatyczna konwersja podczas operacji arytmetycznych</h1><br />
Podczas operacji arytmetycznych także może dochodzić do niejawnej konwersji. Zgodnie ze specyfikacją języka Java (https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2) możliwa jest konwersja (zachodzi pierwszy pasujący warunek):</p>
<ol>
<li>rozszerzająca do typu <code>double</code> jeśli którykolwiek z elementów operacji arytmetycznej jest typu <code>double</code>,</li>
<li>rozszerzająca do typu <code>float</code> jeśli którykolwiek z elementów operacji jest typu <code>float</code>,</li>
<li>rozszerzająca to typu <code>long</code> jeśli którykolwiek z elementów operacji jest typu <code>long</code>,</li>
<li>rozszerzająca do typu <code>int</code>.</li><br />
</ol><br />
Wszystkie cztery przypadki pokazane są w przykładzie poniżej:</p>
<pre class="lang:default decode:true ">public class ArithmeticConversion {<br />
    public static void main(String[] args) {<br />
        short shortValue = 1;<br />
        int intValue = 1;<br />
        long longValue = 2;<br />
        float floatValue = 3.1F;<br />
        double doubleValue = 4.1;</p>
<p>        System.out.println(intValue + doubleValue);<br />
        System.out.println(intValue + floatValue);<br />
        System.out.println(intValue + longValue);<br />
        System.out.println(shortValue + shortValue);<br />
    }<br />
}</pre><br />
Tutaj drobna dygresja, operator dzielenia (/) wykonuje w języku Java dzielenie całkowitoliczbowe jeśli dzielna i dzielnik są całkowitoliczbowe. Jeśli chcemy otrzymać typ zmiennoprzecinkowy co najmniej jeden z elementów musi być typu zmiennoprzecinkowego:</p>
<pre class="lang:default decode:true">5 / 2 = 2<br />
5.0 / 2 = 2.5<br />
5 / 2.0 = 2.5<br />
6 / 2 = 3<br />
6.0 / 2 = 3.0</pre></p>
<h1>Boxing i unboxing</h1><br />
Jak wiesz w języku Java występują zarówno typy proste jak i obiekty reprezentujące liczby np. <code>int</code> i <code>Integer</code>. Kompilator Java jest w stanie dokonać konwersji pomiędzy odpowiadającymi sobie typami prostymi i obiektami automatycznie. Proszę spójrz na przykład poniżej</p>
<pre class="lang:default decode:true ">int primitiveInt = new Integer(123);<br />
long primitiveLong = new Long(123L);<br />
float primitiveFloat = new Float(123.123F);<br />
double primitiveDouble = new Double(123.123);<br />
boolean primitiveBoolean = new Boolean(true);</pre><br />
Mamy tu do czynienia z tak zwanym "<em>unboxing</em>'iem", czyli automatycznym odpakowywaniem obiektu do odpowiadającego mu typu prostego.</p>
<pre class="lang:default decode:true ">Integer objectInteger = 123;<br />
Long objectLong = 123L;<br />
Float objectFloat = 123.123F;<br />
Double objectDouble = 123.123;<br />
Boolean objectBoolean = true;</pre><br />
Przykłady powyżej pokazują z kolei "<em>boxing</em>", czyli automatyczne tworzenie instancji obiektów na podstawie typów prostych.</p>
<p>Podczas <em>boxingu</em>/<em>unboxingu</em> może dość do rzucenia różnych wyjątków, na przykład gdy obiekt przypisywany do typu prostego jest nullem lub gdy do typu prostego próbujemy przypisać inny obiekt (np. <code>Long</code> do <code>int</code>).</p>
<h1>Konwersja do typu <code>String</code></h1><br />
Konwersja do typu <code>String</code> jest specyficznym rodzajem konwersji automatycznej. Jest ona specyficzna ponieważ bazuje na metodzie <code>toString</code>, która może być przedefiniowana przez programistę. Konwersja do typu <code>String</code> zachodzi przy operatorze dodawania + jeśli któryś z dodawanych elementów jest typu <code>String</code>.</p>
<p>Typy proste także są automatycznie konwertowane do typu <code>String</code>, odbywa się to dwuetapowo, na początku zachodzi boxing następne obiekt konwertowany jest do typu <code>String</code> (wywoływana jest metoda <code>toString</code>).</p>
<pre class="lang:default decode:true ">String x = "123" + new Object();<br />
String y = new Object() + "123";<br />
String z = 1 + "123";</pre></p>
<h1>Zadania</h1></p>
<ol>
<li>Napisz program przyjmujący od użytkownika liczbę całkowitą i wyświetl wynik mnożenia tej liczby oraz stałej pi (<code>Math.PI</code>). Wyświetl wynik w postaci liczby całkowitej i liczby zmiennoprzecinkowej.</li>
<li>Napisz program pobierający od użytkownika dwie liczby całkowite. Wyświetl wynik ich dzielenia wraz z częścią ułamkową.</li>
<li>Napisz program, który skończy się wyjątkiem spowodowanym błędem podczas boxingu/unboxingu.</li>
<li>Jak myślisz co otrzymasz przypisując zmienną typu <code>char</code> do zmiennej typu <code>int</code>? Znajdziesz ten numer w <a href="https://pl.wikipedia.org/wiki/ASCII#Tabela" target="_blank" rel="noopener">tabeli ASCII</a>?</li><br />
</ol><br />
Przygotowałem też dla Ciebie zestaw <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/11_konwersja_rzutowanie/src/main/java/pl/samouczekprogramisty/kursjava/zadanie" target="_blank" rel="noopener">przykładowych rozwiązań zadań</a>, analizując je także możesz się czegoś nauczyć.</p>
<h1>Dodatkowe materiały do nauki</h1></p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16</a> &ndash; "cast expression",</li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html</a> &ndash; rzutowanie i konwersje,</li>
<li><a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/11_konwersja_rzutowanie" target="_blank" rel="noopener">https://github.com/SamouczekProgramisty/KursJava/tree/master/11_konwersja_rzutowanie</a> &ndash; kod źródłowy przykładów użytych w artykule.</li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Właśnie dowiedziałeś się o kilku kolejnych zakamarkach języka Java. Mam nadzieję, że Ci się podobało. Jak zwykle na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, zleży mi na dotarciu do jak największego grona czytelników. Jeśli nie chcesz pominąć żadnego postu polub Samouczka na facebooku. Do następnego razu! :)</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/parrhesiastes</p>
