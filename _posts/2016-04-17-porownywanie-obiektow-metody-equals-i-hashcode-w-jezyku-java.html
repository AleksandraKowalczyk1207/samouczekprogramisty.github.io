---
layout: post
status: publish
published: true
title: Porównywanie obiektów, metody equals i hashCode w języku Java
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "Cześć! W dzisiejszym artykule będziesz mógł przeczytać o właściwym
  sposobie porównywania obiektów i typów prostych w języku Java.
  Dowiesz się do czego służą metody <code>equals</code> oraz <code>hashCode</code>
  oraz przeczytasz o tak zwanym kontrakcie między tymi metodami. Na koniec będzie
  na Ciebie czekało małe ćwiczenie do wykonania samodzielnie. Zapraszam do artykułu.\r\n<blockquote>"
wordpress_id: 286
wordpress_url: http://www.samouczekprogramisty.pl/?p=286
date: '2016-04-17 12:23:22 +0200'
date_gmt: '2016-04-17 10:23:22 +0200'
categories:
- Kurs programowania Java
tags: []
---
<p>Cześć! W dzisiejszym artykule będziesz mógł przeczytać o właściwym sposobie porównywania obiektów i typów prostych w języku Java. Dowiesz się do czego służą metody <code>equals</code> oraz <code>hashCode</code> oraz przeczytasz o tak zwanym kontrakcie między tymi metodami. Na koniec będzie na Ciebie czekało małe ćwiczenie do wykonania samodzielnie. Zapraszam do artykułu.</p>
<blockquote><p><a id="more"></a><a id="more-286"></a></blockquote><br />
[idea]To jest jeden z artykułów w ramach <a href="http://www.samouczekprogramisty.pl/kurs-programowania-java/">darmowego kursu programowania w Javie</a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[/idea]</p>
<h1>Porównywanie typów prostych</h1><br />
Do sprawdzenia "równości" typów prostych służą operatory <code>==</code> oraz <code>!=</code>. Dzięki nim możemy porównać ze sobą każdą zmienną typu prostego. Wynikiem takiego porównania jest wartość typu <code>boolean</code> &ndash; <code>true</code> jeśli porównywane obiekty są równe i <code>false</code> w przeciwnym wypadku. Proszę spójrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">System.out.println("10 == 10: " + (10 == 10));<br />
System.out.println("10 != 10: " + (10 != 10));<br />
System.out.println("true == true: " + (true == true));<br />
System.out.println("true != true: " + (true != true));<br />
System.out.println("'a' == 'a': " + ('a' == 'a'));<br />
System.out.println("'a' != 'a': " + ('a' != 'a'));<br />
System.out.println("500L == 500L: " + (500L == 500L));<br />
System.out.println("500L != 500L: " + (500L != 500L));</pre><br />
Kolejne linijki porównują odpowiednio:</p>
<ul>
<li>liczby typu <code>int</code>,</li>
<li>zmienne typu <code>boolean</code>,</li>
<li>znaki typu <code>char</code>,</li>
<li>liczby typu <code>long</code>.</li><br />
</ul></p>
<h2>Priorytety operatorów</h2><br />
Drobna dygresja dotycząca priorytetów operatorów. W języku Java wszystkie operatory mają tak zwany priorytet. Oznacza to tyle, że priorytet operatorów określa kolejność wykonywania działań. Proszę spójrz na przykład niżej</p>
<pre class="lang:default decode:true ">10 == 4 + 6<br />
4 + 6 == 10<br />
3 * 5 + 2</pre><br />
Operator <code>+</code> ma wyższy priorytet niż operator <code>==</code>. W związku z tym operacja dodawania wykonana zostanie jako pierwsza i porównanie zwróci true. Podobnie <code>*</code> ma wyższy priorytet niż <code>+</code>. Zatem na początku wykonana zostanie operacja mnożenia a na końcu dodawanie.</p>
<p>Czasami jednak domyślny priorytet operatorów nie jest odpowiedni, chcielibyśmy wykonać operacje w innej kolejności. Z pomocą przychodzą nawiasy, które pozwalają na modyfikację zachowania programu. Przykład poniżej pomaga zrozumieć jak to działa:</p>
<pre class="lang:default decode:true ">3 * (5 + 2)</pre><br />
Mimo tego, że operator <code>*</code> ma wyższy priorytet niż <code>+</code> operacja mnożenia zostanie wykonana jako druga. Pierwsze zostanie wykonane dodawanie ponieważ zostało otoczone parą nawiasów.</p>
<p>Po tym wstępie mogę wyjaśnić dlaczego w przykładzie poniżej potrzebujemy nawiasów:</p>
<pre class="lang:default decode:true">"10 == 10: " + 10 == 10 // compilation error!<br />
"10 == 10: " + (10 == 10)</pre><br />
Bez dodatkowej pary nawiasów pierwszeństwo miałby operator <code>+</code>. <code>"10 == 10: " + 10 == 10</code> inaczej możemy zapisać jako <code>"10 == 10: 10"&nbsp; == 10</code> a taki zapis nie jest poprawny, ponieważ operatorem <code>==</code> nie możemy porównać instancji typu <code>String</code> i wartości typu <code>int</code>.</p>
<h1>Porównywanie zmiennoprzecinkowych typów prostych</h1><br />
O ile sprawdzanie równości wartości liczb całkowitych nie jest trudne to ta sama operacja dla typów zmiennoprzecinkowych jest trochę bardziej skomplikowana. W związku ze sposobem reprezentacji liczb zmiennoprzecinkowych typu <code>float</code> i <code>double</code> w pamięci komputera nie jest możliwe ich dokładne porównywanie. Operacja taka jest dopuszczalna ale może prowadzić do dziwnych rezultatów (na przykład, liczby, które teoretycznie powinny być równe według komputera nie są).</p>
<p>W związku z tym liczby zmiennoprzecinkowe powinno się porównywać z pewną dokładnością.</p>
<pre class="lang:default decode:true ">System.out.println("0.3 == 0.1 + 0.2: " + (0.3 == 0.1 + 0.2)); // !!!<br />
System.out.println("0.3 == 0.1 + 0.2: " + (Math.abs(0.3 - (0.1 + 0.2)) < 0.000001));</pre><br />
W przykładzie powyżej została użyta metoda <code>Math.abs()</code>. Metoda ta zwraca <a href="https://pl.wikipedia.org/wiki/Warto%C5%9B%C4%87_bezwzgl%C4%99dna" target="_blank" rel="noopener">wartość bezwzględną</a> danej liczby. Następnie wartość tą porównujemy z bardzo małą liczbą. Liczba ta reprezentuje dokładność porównania. Jeśli różnica liczb jest mniejsza niż nasza założona dokładność uznajemy, że porównywane liczby są równe.</p>
<h1>Porównanie obiektów</h1><br />
Używając operatora <code>==</code> do porównywania obiektów uzyskamy błędne rezultaty. Do porównania tego typu powinniśmy używać metody equals.</p>
<pre class="lang:default decode:true ">System.out.println("test == test: " + (new String("test") == new String("test")));<br />
System.out.println("test equals test: " + new String("test").equals(new String("test")));</pre><br />
Dlaczego tak się dzieje? Otóż w przypadku obiektów operator <code>==</code> porównuje referencje obiektów (adresy na stercie). Mając dwie różne instancje obiektów mają one dwa różne adresy w pamięci w związku z tym zawsze ich adresy są różne. Innymi słowy w przypadku obiektów przy pomocy operatora <code>==</code> możemy sprawdzić czy dwie referencje wskazują na ten sam obiekt.</p>
<pre class="lang:default decode:true ">String reference1 = new String("something");<br />
String reference2 = reference1;<br />
System.out.println("reference1 == reference2: " + (reference1 == reference2));</pre></p>
<h1>Metoda <code>equals</code></h1><br />
Metoda <code>equals</code> jest jedną z metod dostępnych w klasie <code>Object</code>. W związku z tym, że każdy obiekt w języku Java ma tą klasę w swojej hierarchii dziedziczenia możemy tą metodą wywołać na każdym obiekcie.</p>
<p>W większości przypadków domyślna implementacja metody <code>equals</code> nie jest odpowiednia[2. Domyślna implementacja zachowuje się jak operator <code>==</code>, porównuje adresy obiektów.] w związku z tym programista tworzący nowy obiekt musi tą metodę zaimplementować jeśli chce sprawdzać czy instancje tej klasy są równe.</p>
<p>Istnieje zestaw wytycznych, które metoda <code>equals</code> powinna spełniać aby była poprawnie zaimplementowana. Opiszę je po kolei:</p>
<h3>Metoda <code>equals</code> powinna być <a href="https://pl.wikipedia.org/wiki/Relacja_zwrotna" target="_blank" rel="noopener">zwrotna</a></h3><br />
Oznacza to tyle, że dla każdego obiektu operacja <code>object.equals(object)</code> powinna zwrócić <code>true</code>.</p>
<h3>Metoda <code>equals</code> powinna być <a href="https://pl.wikipedia.org/wiki/Relacja_symetryczna" target="_blank" rel="noopener">symetryczna</a></h3><br />
Oznacza to tyle, że dla każdej pary obiektów <code>X</code> i <code>Y</code> powinna zachodzić właściwość jeśli <code>X.equals(Y) == true</code> wówczas także <code>Y.equals(X) == true</code>.</p>
<h3>Metoda equals powinna być <a href="https://pl.wikipedia.org/wiki/Relacja_przechodnia" target="_blank" rel="noopener">przechodnia</a></h3><br />
Jeśli mamy trzy obiekty <code>X</code>, <code>Y</code> i <code>Z</code> oraz jeśli <code>X.equals(Y) == true</code> i <code>Y.equals(Z) == true</code> to także <code>X.equals(Z)</code> jest prawdą.</p>
<h3>Metoda <code>equals</code> powinna być spójna</h3><br />
Innymi słowy kilkukrotne wywołanie metody <code>equals</code> na tych samych obiektach zawsze powinno zwrócić ten sam wynik (zakładając, że obiekty nie były modyfikowane pomiędzy wywołaniami).</p>
<h3>Metoda <code>equals</code> powinna zwrócić <code>false</code> przy porówaniu z <code>null</code></h3><br />
Dla każdego obiektu <code>X</code>, który nie jest <code>null</code> porównanie typu <code>X.equals(null)</code> powinno zwrócić <code>false</code>.<br />
Przykład implementacji metody equals</p>
<p>Załóżmy, że mamy klasę <code>Chair</code>. Możemy powiedzieć, że krzesła są "równe" jeśli zostały wyprodukowane w tym samym roku, przez tego samego producenta oraz są tego samego modelu. Założenia te zostały zaimplementowane poniżej.</p>
<pre class="lang:default decode:true">public class Chair {<br />
    private String model;<br />
    private String manufacturer;<br />
    private int productionYear;</p>
<p>    public Chair(String model, String manufacturer, int productionYear) {<br />
        this.model = model;<br />
        this.manufacturer = manufacturer;<br />
        this.productionYear = productionYear;<br />
    }   </p>
<p>    public String getModel() {<br />
        return model;<br />
    }   </p>
<p>    public String getManufacturer() {<br />
        return manufacturer;<br />
    }   </p>
<p>    public int getProductionYear() {<br />
        return productionYear;<br />
    }</p>
<p>    @Override<br />
    public boolean equals(Object obj) {<br />
        if (obj == null) {<br />
            return false;<br />
        }<br />
        if (obj instanceof Chair) {<br />
            Chair otherChair = (Chair) obj;<br />
            return model.equals(otherChair.model) &amp;&amp;<br />
                    manufacturer.equals(otherChair.manufacturer) &amp;&amp;<br />
                    productionYear == otherChair.productionYear;<br />
        }<br />
        return false;<br />
    }</p>
<p>    @Override<br />
    public int hashCode() {<br />
        return 17 * model.hashCode() + 31 * manufacturer.hashCode() + 7 * productionYear;<br />
    }<br />
}</p>
<p>Chair chair1 = new Chair("Adde", "IKEA", 2016);<br />
Chair chair2 = new Chair("Janinge", "IKEA", 2016);<br />
Chair chair3 = new Chair("Adde", "IKEA", 2015);<br />
Chair chair4 = new Chair("Adde", "IKEA", 2016);</p>
<p>System.out.println("chair1.equals(chair2): " + chair1.equals(chair2));<br />
System.out.println("chair1.equals(chair3): " + chair1.equals(chair3));<br />
System.out.println("chair1.equals(chair4): " + chair1.equals(chair4));<br />
System.out.println("chair1.equals(null): " + chair1.equals(null));</pre><br />
Zauważ, że w naszej implementacji metody <code>equals</code> używamy także metody <code>equals</code> z typu <code>String</code> aby sprawdzić czy model i producent są równi.</p>
<p>Nowy może być także operator <code>instanceof</code>, służy on do sprawdzenia czy dana instancja jest typu <code>Chair</code>. Po tym sprawdzeniu możemy bezpiecznie rzutować obiekt <code>obj</code> i mamy pewność, że nie zostanie rzucony wyjątek <code>ClassCastException</code>.</p>
<h1>Metoda <code>hashCode</code></h1><br />
Podobnie jak w przypadku <code>equals</code> <code>hashCode</code> jest zaimplementowane w klasie <code>Object</code>. Zawsze kiedy programista implementuję metodę<code>hashCode</code>&nbsp;powinien też zaimplementować metodę<code>equals</code>.</p>
<p>Metoda ta zwraca liczbę typu int, która służy do przyporządkowania danego obiektu do grupy. Dzięki metodzie <code>hashCode</code> jesteśmy w stanie podzielić wszystkie możliwe instancje danej klasy na rozdzielne grupy. Każda z tych grup reprezentowana jest przez liczbę zwracaną przez metodę <code>hashCode</code>.</p>
<p>[caption id="attachment_288" align="aligncenter" width="758"]<img class="wp-image-288 size-full" title="hashCode zasada działania" src="http://www.samouczekprogramisty.pl/wp-content/uploads/2016/04/hashCode.jpg" alt="hashCode zasada działania" width="758" height="251" /> hashCode zasada działania[/caption]</p>
<p>Obrazowe przyporządkowanie obiektów do grup zostało przedstawione na diagramie powyżej. Koła i trójkąt zostały przyporządkowane do tej samej grupy, rąb i pięciokąt do grupy Hash#2 natomiast trapez został przyporządkowany do grupy Hash#3.</p>
<p>Metoda <code>hashCode</code> wykorzystywana jest przez niektóre kolekcje (tablice na sterydach), o których przeczytasz <a href="http://www.samouczekprogramisty.pl/kolekcje-w-jezyku-java/">w jednym z kolejnych artykułów</a>. Implementacja metody <code>hashCode</code> sprowadza się do zwrócenia odpowiedniej liczby, tak zwanego hasha. Przyporządkuje on dany obiekt do grupy używanej w niektórych kolekcjach. Najczęściej metodę <code>hashCode</code> implementuje się w oparciu o hashe atrybutów danej instancji. Hashe atrybutów zazwyczaj mnoży się przez liczby pierwsze i sumuje ze sobą. Użycie liczb pierwszych pomaga w uzyskaniu "dobrych hashy". Dobra implementacja <code>hashCode</code> pozwala na uzyskanie jak największej liczby grup (hashy), do których przyporządkowujemy obiekty.</p>
<p>Posłużę sie tu klasą <code>Chair</code> wspomianą wyżej. Zakładając, że nasza klasa ma trzy atrybuty i żaden z nich nie może mieć wartości <code>null</code> przykładowa implemetacja może wyglądać następująco:</p>
<div id="crayon-59adb4fc5fe18854268088-38" class="crayon-line crayon-striped-line">
<pre class="lang:default decode:true">@Override<br />
public int hashCode() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;return 17 * model.hashCode() + 31 * manufacturer.hashCode() + 7 * productionYear;<br />
}</pre><br />
</div><br />
W większości przypadków użycie metody&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html#hash-java.lang.Object...-" target="_blank" rel="noopener"><code>Objects.hash</code></a> przy implementacji metody <code>hashCode</code> jest dobrym pomysłem.</p>
<h1>Kontrakt między metodami <code>equals</code> i <code>hashCode</code></h1><br />
Metody <code>hashCode</code> i <code>equals</code> są ze sobą powiązane i ich implementacja powinna być spójna. Tą zależność określa się kontraktem między metodami <code>hashCode</code> i <code>equals</code>.</p>
<p>* Jeśli <code>X.equals(Y) == true</code> wówczas wymagane jest aby <code>X.hashCode() == Y.hashCode()</code>,<br />
* Kilkukrotne wywołanie metody <code>hashCode</code> na tym samym obiekcie, który nie był modyfikowany pomiędzy wywołaniami musi zwrócić tą samą wartość,<br />
* Jeśli <code>X.hashCode() == Y.hashCode()</code> to nie jest wymagane aby <code>X.equals(Y) == true</code>.</p>
<p>Trzeci przypadek jest ilustrowany na obrazku powyżej gdzie koła i trójkąt mają ten sam <code>hashCode</code> jednak koło i trójkąt nie są równe.</p>
<h1>Generatory metod <code>hashCode</code> i <code>equals</code></h1><br />
Implementacja tych metod w większości przypadków jest dość prosta. W większości z nich także nie jest to kod zbyt skomplikowany. Jednak za każdym razem pisanie tych metod jest uciążliwe. Z pomocą przychodzi IDE. Polecam generowanie tych metod przy jego pomocy. W przypadku InteliJ IDEA pomocny może okazać się skrót klawiaturowy <code>Alt+Insert</code>. Po jego naciśnięciu pokaże się menu kontekstowe pozwalające na wygenerowanie tych metod.</p>
<p>Dodatkowo warto przyjrzeć się klasie <code>Objects</code> i bibliotekom <a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a> czy <a href="https://commons.apache.org/proper/commons-lang/" target="_blank" rel="noopener">Apache commons-lang</a>. Zawierają one metody pomocnicze użyteczne podczas implementacji metod <code>hashCode</code> i <code>equals</code>.</p>
<h1>Zadanie</h1><br />
Na koniec krótkie zadanie dla Ciebie. Napisz klasę reprezentującą człowieka, zaimplementuj metody <code>hashCode</code> i <code>equals</code>. Zastanów się czy to, że ktoś ma to samo imię i nazwisko sprawia, że jest to ta sama osoba? Jaki atrybut może posłużyć do sprawdzenia czy dwie instancje klasy <code>Human</code> reprezentują tę samą osobę?</p>
<p>Jeśli będziesz miał problem z rozwiązaniem zadania <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/14_porownywanie_obiektow/src/main/java/pl/samouczekprogramisty/kursjava/equality" target="_blank" rel="noopener">przykładowe rozwiązanie</a> umieściłem na githubie. Jak zwykle zachęcam do samodzielnych prób, wtedy nauczysz się najwięcej.</p>
<h1>Materiały dodatkowe</h1><br />
Kod źródłowy wszystkich przykładów użytych w artykule znajduje się na <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/14_porownywanie_obiektow/src/main/java/pl/samouczekprogramisty/kursjava/equality" target="_blank" rel="noopener">githubie</a>. Jeśli chcesz poczytać więcej na temat metod <code>equals</code> i <code>hashCode</code> zapraszam do materiałów dodatkowych:</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.21" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.21</a></li>
<li><a href="http://kobietydokodu.pl/niezbednik-juniora-kontrakt-hashcode-i-equals/" target="_blank" rel="noopener">http://kobietydokodu.pl/niezbednik-juniora-kontrakt-hashcode-i-equals</a></li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Bardzo się cieszę, że dotarłeś do końca artykułu. Mam nadzieję, że był on dla Ciebie ciekawy i przydatny. Na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, zależy mi na dotarciu do jak największej liczby czytelników. Jeśli nie chcesz przegapić nowych artykułów polub nas na facebooku :) W przypadku jakichkolwiek pytań proszę zdaj je w komentarzach, postaram się odpowiedzieć.</p>
<p>Do następnego razu!</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/badgreeb_records/6453502559</p>
