---
layout: post
status: publish
published: true
title: Kolekcje w języku Java
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "W tym artykule przeczytasz o kolekcjach w języku Java. Dowiesz się czym
  są kolekcje, kiedy można ich używać. Poznasz podstawowe kolekcje takie jak mapa,
  zbi&oacute;r czy lista. Jak zwykle na koniec czekały będą na Ciebie zadania, przy
  kt&oacute;rych przećwiczysz materiał opisany w tym artykule. Zwr&oacute;cę też uwagę
  na parę skr&oacute;t&oacute;w klawiaturowych, kt&oacute;re mogą Ci się przydać podczas
  pracy z kodem. Zapraszam do lektury!\r\n<h1>"
wordpress_id: 115
wordpress_url: http://www.samouczekprogramisty.pl/?p=115
date: '2016-08-09 19:55:30 +0200'
date_gmt: '2016-08-09 17:55:30 +0200'
categories:
- Kurs programowania Java
- Programowanie
tags: []
---
<p>W tym artykule przeczytasz o kolekcjach w języku Java. Dowiesz się czym są kolekcje, kiedy można ich używać. Poznasz podstawowe kolekcje takie jak mapa, zbi&oacute;r czy lista. Jak zwykle na koniec czekały będą na Ciebie zadania, przy kt&oacute;rych przećwiczysz materiał opisany w tym artykule. Zwr&oacute;cę też uwagę na parę skr&oacute;t&oacute;w klawiaturowych, kt&oacute;re mogą Ci się przydać podczas pracy z kodem. Zapraszam do lektury!</p>
<h1><a id="more"></a><a id="more-115"></a><&#47;h1><br />
[idea]To jest jeden z artykuł&oacute;w w ramach <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;kurs-programowania-java&#47;">darmowego kursu programowania w Javie<&#47;a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[&#47;idea]</p>
<h1>Czym są kolekcje<&#47;h1><br />
Java, podobnie jak wiele innych język&oacute;w, w tak zwanej bibliotece standardowej[1. Biblioteka standardowa to zestaw klas, kt&oacute;re może używać programista, dostarczonych wraz z językiem programowania.] zawiera zestaw kolekcji. Kolekcja to nic innego jak spos&oacute;b grupowania obiekt&oacute;w. Kolekcją możemy także nazwać tablicę obiekt&oacute;w, kt&oacute;rą już znasz. Jednak tego typu kolekcja na pewne ograniczenia, gł&oacute;wnym z nich jest to, że rozmiar, kt&oacute;ry ustalimy na początku nie może być zmieniony.</p>
<p>Kolekcje możemy opisać jako &bdquo;tablice na sterydach&rdquo;. Pozwalają one na dużo więcej niż przechowywanie obiekt&oacute;w w kolejności określonej przez tablicę.</p>
<p>Kolekcje to implementacje tak zwanych struktur danych. O przykładowych implementacjach struktur danych na pewno przeczytasz w jednym z kolejnych artykuł&oacute;w. Na dzisiaj musisz zapamiętać, ze rodzaj kolekcji&#47;struktury danych pozwala napisać program, kt&oacute;ry jest bardziej bądź mniej wydajny (działa szybciej lub wolniej). To, jaką kolekcję w danym momencie użyjemy ma znaczenie. W kolejnych akapitach postaram się przytoczyć podstawowe kolekcje wraz z przykładami ich użycia.</p>
<h1>Hierarchia dziedziczenia<&#47;h1><br />
Kolekcje w standardowej bibliotece Javy implementują r&oacute;żne interfejsy, poniższy diagram pokazuje hierarchię dziedziczenia dla podstawowych typ&oacute;w kolekcji dostępnych w Javie. Każdy z tych interfejs&oacute;w ma kilka implementacji, kt&oacute;rych używa się w r&oacute;żnych sytuacjach.</p>
<p><img class="aligncenter wp-image-307 size-full" src="http:&#47;&#47;www.samouczekprogramisty.pl&#47;wp-content&#47;uploads&#47;2016&#47;08&#47;kolekcje_dziedziczenie.jpg" alt="dziedziczenie kolekcji w języku Java" width="925" height="440" &#47;></p>
<h1>Lista<&#47;h1><br />
Lista (ang. <em>list<&#47;em>) podobnie jak tablica, grupuje elementy. Jej gł&oacute;wną przewagą nad tablicą jest to, że programista nie musi się przejmować rozmiarem listy[2. Oczywiście w granicach rozsądku, w skrajnych przypadkach utworzenie listy ze zbyt dużą liczbą element&oacute;w może prowadzić do wystąpienia błędu <code>OutOfMemoryError<&#47;code>.], jest ona automatycznie powiększana wraz z dodawaniem nowych element&oacute;w. Listy w języku Java reprezentowane są przez interfejs <code>java.util.List<&#47;code>. Listy z definicji są kolekcjami dla kt&oacute;rych kolejność element&oacute;w jest istotna, mogą przechowywać ten sam obiekt po kilka razy. Podstawowymi przykładami implementacji interfejsu <code>java.util.List<&#47;code> są klasy <code>java.util.LinkedList<&#47;code> oraz <code>java.util.ArrayList<&#47;code>.</p>
<p>Bez wdawania się w zbędne szczeg&oacute;ły, proszę zapamiętaj, że <code>LinkedList<&#47;code> lepiej jest używać jeśli często usuwasz elementy z listy a <code>ArrayList<&#47;code> lepiej jest używać jeśli często chcesz mieć dostęp do losowych element&oacute;w w liście. Obiecuje, że dokładne wytłumaczenie&nbsp; dlaczego tak się dzieje znajdziesz w jednym z kolejnych artykuł&oacute;w.</p>
<h2>Przydatne metody w java.util.List<&#47;h2><br />
Chciałbym pokazać Ci parę metod, kt&oacute;re mogą Ci się przydać przy pracy z listami. Jeśli jesteś zainteresowany pełną listą zachęcam do przeczytania <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;List.html" target="_blank" rel="noopener">dokumentacji dla interfejsu <code>List<&#47;code><&#47;a>, tam znajdziesz wszystkie niezbędne szczeg&oacute;ły.</p>
<p>Zał&oacute;żmy, że nasza zmienna jest typu <code>List<String><&#47;code>. W&oacute;wczas będziesz m&oacute;gł używać m.in. następujących metod:</p>
<ul>
<li><code>add<&#47;code> &ndash; dodaje element do listy,<&#47;li>
<li><code>addAll<&#47;code> &ndash; jako parametr przyjmuje inną kolekcję i dodaje wszystkie elementy z tej kolekcji do listy,<&#47;li>
<li><code>contains<&#47;code> &ndash; jako parametr przyjmuje element listy i zwraca flagę informującą czy dany element już istnieje (tutaj przyda Ci się artykuł o por&oacute;wnywaniu obiekt&oacute;w w języku Java),<&#47;li>
<li><code>isEmpty<&#47;code> &ndash; bezargumentowa metoda zwracająca flagę informującą czy lista jest pusta,<&#47;li>
<li><code>size<&#47;code> &ndash; bezargumentowa metoda zwracająca liczbę element&oacute;w w liście,<&#47;li>
<li><code>indexOf<&#47;code> &ndash; metoda jako parametr przyjmuje element listy i zwraca indeks pierwszego wystąpienia,<&#47;li>
<li><code>lastIndexOf<&#47;code> &ndash; metoda jako parametr przyjmuje element listy i zwraca indeks ostatniego wystąpienia.<&#47;li><br />
<&#47;ul><br />
Opisane wyżej metody użyte zostały w kodzie poniżej.</p>
<pre class="lang:default decode:true ">List<String> listWithNames = new LinkedList<>();<br />
listWithNames.add("Piotrek");<br />
listWithNames.add("Krzysiek");</p>
<p>List<String> otherListWithNames = new LinkedList<>();<br />
otherListWithNames.add("Marek");<br />
otherListWithNames.addAll(listWithNames);<br />
otherListWithNames.add("Marek");</p>
<p>System.out.println(otherListWithNames.contains("Marek"));<br />
System.out.println(otherListWithNames.get(0));<br />
System.out.println(otherListWithNames.isEmpty());<br />
System.out.println(otherListWithNames.indexOf("Marek"));<br />
System.out.println(otherListWithNames.lastIndexOf("Marek"));<&#47;pre></p>
<blockquote><p>Tutaj drobna dygresja, w kodzie wyżej widzisz zapis <code>List<String> listWithNames = new LinkedList<>()<&#47;code>. Dlaczego nie napisać <code>LinkedList<String> listWithNames = new LinkedList<>()<&#47;code>? Pierwsza wersja pokazuje dobrą praktykę, kt&oacute;ra polega na definiowaniu zmiennych typu interfejsu a nie klasy implementującej ten interfejs. Dzięki temu w przyszłości z łatwością moglibyśmy przypisać do <code>listWithNames<&#47;code> zmienną typu <code>ArrayList<String><&#47;code> bez konieczności zmiany pozostałej części programu.<&#47;blockquote></p>
<h1>Zbi&oacute;r<&#47;h1><br />
Zbi&oacute;r (ang. <em>set<&#47;em>) to kolekcja, kt&oacute;ra służy do przechowywania unikalnych element&oacute;w. Zbiory w języku Java implementują interfejs <code>java.util.Set<&#47;code>. W przypadku zbioru nie jest istotna kolejność dodawanych element&oacute;w. Innymi słowy jeśli do zbioru dodamy na początku element X a p&oacute;źniej Y to przechodząc po kolei po elementach zbioru możemy dostać je w odwrotnej kolejności. Istnieją także implementacje zbioru, w kt&oacute;rych kolejność element&oacute;w jest zachowana, jednak jest to raczej &bdquo;szczeg&oacute;ł implementacyjny&rdquo; niż szczeg&oacute;lna właściwość zbior&oacute;w.</p>
<p>Kolejną cechą zbioru jest to, że przechowuje on unikalne elementy. W odr&oacute;żnieniu od listy, w zbiorze można przechowywać wyłącznie jedną instancję obiektu.</p>
<p>Skąd możemy wiedzieć, że dana instancja jest już w zbiorze? Ot&oacute;ż służą do tego opisane już metody <code>hashCode<&#47;code> oraz <code>equals<&#47;code>.</p>
<p>Jeszcze raz przypomnę o kontrakcie między tymi metodami. Poprawne działanie kolekcji wymaga poprawnie zaimplementowanych metod <code>hashCode<&#47;code>&#47;<code>equals<&#47;code>. Jeśli ten warunek nie jest spełniony niekt&oacute;re kolekcje mogą działać w dziwny, niespodziewany spos&oacute;b.</p>
<p>Najważniejszą implementacją interfejsu <code>Set<&#47;code> jest klasa <code>java.util.HashSet<&#47;code>.</p>
<h2>Przydatne metody w java.util.Set<&#47;h2><br />
Podobnie jak w przypadku list zachęcam do zapoznania się z <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Set.html" target="_blank" rel="noopener">pełną listą metod dostępnych w interfejsie <code>Set<&#47;code><&#47;a>. Poniżej lista kilku przydatnych metod:</p>
<ul>
<li><code>add<&#47;code> &ndash; dodaje element do zbioru,<&#47;li>
<li><code>addAll<&#47;code> &ndash; jako parametr przyjmuje inną kolekcję i dodaje wszystkie elementy z tej kolekcji do zbioru (pomijając duplikaty),<&#47;li>
<li><code>contains<&#47;code> &ndash; jako parametr przyjmuje element zbioru i zwraca flagę informującą czy dany element już istnieje,<&#47;li>
<li><code>isEmpty<&#47;code> &ndash; bezargumentowa metoda zwracająca flagę informującą czy zbi&oacute;r jest pusty,<&#47;li>
<li><code>size<&#47;code> &ndash; metoda zwraca ilość element&oacute;w w zbiorze.<&#47;li><br />
<&#47;ul><br />
Przykład użycia metod znajduje się we fragmencie kodu poniżej.</p>
<pre class="lang:default decode:true">Set<String> setWithNames = new HashSet<>();<br />
setWithNames.add("Marcin");<br />
setWithNames.add("Marek");<br />
setWithNames.add("Marcin");</p>
<p>Set<String> otherSet = new HashSet<>();<br />
otherSet.add("Zenon");<br />
otherSet.add("Marek");</p>
<p>setWithNames.addAll(otherSet);</p>
<p>System.out.println(setWithNames.isEmpty());<br />
System.out.println(setWithNames.size());<br />
System.out.println(setWithNames.contains("Marcin"));<br />
System.out.println(setWithNames.remove("Janusz"));<&#47;pre></p>
<h1>Mapa<&#47;h1><br />
Mapa (ang. <em>map<&#47;em>) jest kolekcją, kt&oacute;ra pozwala przechować odwzorowanie zbioru kluczy na listę wartości. Innymi słowy w mapie możemy trzymać klucze, kt&oacute;rym odpowiadają wartości. Klucze muszą być unikalne (dlatego pisałem o zbiorze kluczy), wartości natomiast mogą się powtarzać. Czyli pod kluczem A i pod kluczem B może być ta sama wartość X. Ale sytuacja odwrotna gdzie klucz X występuje dwa razy i jeden z nich wskazuje na element A a inny na element B nie jest możliwa[3. Tu zn&oacute;w dygresja, oczywiście istnieją implementacje, kt&oacute;re pozwalają na takie zachowanie, jednak nie jest to &bdquo;domyślne&rdquo; zachowanie.].</p>
<p>Czytając inne źr&oacute;dła możesz natknąć się na inne nazwy. Słownik, tablica asocjacyjna, mapa &ndash; to pojęcia opisujące dokładnie tę samą strukturę danych.</p>
<p>Kluczami w mapie powinny być obiekty, kt&oacute;rych nie można zmodyfikować (ang. <em>immutable<&#47;em>). Np dobrymi kandydatami na klucze są instancje takich klas jak <code>String<&#47;code> czy <code>Integer<&#47;code> &ndash; są to obiekty, kt&oacute;rych po zainicjalizowaniu nie możemy zmodyfikować. Ponadto klasy kluczy muszą poprawnie implementować metody <code>hashCode<&#47;code>&#47;<code>equals<&#47;code>. Jeśli jakaś para (klucz, wartość1) istnieje jest w mapie a ty spr&oacute;bujesz dodać kolejną (klucz, wartość2) (ten sam klucz). W&oacute;wczas ta ostatnia para będzie przechowywana przez mapę, nadpisze ona poprzedni element.</p>
<p>Podobnie jak <code>Set<&#47;code> i <code>List<&#47;code>, <code>Map<&#47;code> jest interfejsem generycznym, jednak w tym przypadku wymaga on dw&oacute;ch klas &ndash; pierwsza z nich definiuje typ kluczy, druga typ wartości przechowywanych w mapie.</p>
<p>Standardową implementacją mapy w języku Java jest klasa <code>java.util.HashMap<&#47;code>.</p>
<h2>Przydatne metody w <code>java.util.Map<&#47;code><&#47;h2></p>
<ul>
<li><code>put<&#47;code> &ndash; dodaje parę klucz&#47;wartość do mapy,<&#47;li>
<li><code>putAll<&#47;code> &ndash; jako parametr przyjmuje inną mapę i dodaje wszystkie elementy z do mapy,<&#47;li>
<li><code>containsKey<&#47;code> &ndash; jako parametr przyjmuje klucz i zwraca flagę informującą czy dany klucz już istnieje,<&#47;li>
<li><code>containsValue<&#47;code> &ndash; jako parametr przyjmuje wartość i zwraca flagę informującą czy dana wartość już istnieje,<&#47;li>
<li><code>isEmpty<&#47;code> &ndash; bezargumentowa metoda zwracająca flagę informującą czy mapa jest pusta,<&#47;li>
<li><code>size<&#47;code> &ndash; bezargumentowa metoda zwracająca liczbę element&oacute;w w mapie,<&#47;li>
<li><code>remove<&#47;code> &ndash; metoda jako parametr przyjmuje klucz i usuwa parę klucz&#47;wartość z mapy,<&#47;li>
<li><code>get<&#47;code> &ndash; metoda jako parametr przyjmuje klucz i zwraca odpowiadającą mu wartość.<&#47;li><br />
<&#47;ul><br />
Przykłady użycia metod znajdziesz we fragmencie kodu poniżej.</p>
<pre class="lang:default decode:true ">Map<String, String> pairsMap = new HashMap<>();<br />
pairsMap.put("Marcin", "Adela");<br />
pairsMap.put("Marek", "Magda");</p>
<p>Map<String, String> otherPairsMap = new HashMap<>();<br />
otherPairsMap.put("Marek", "Ewa");<br />
otherPairsMap.put("Adam", "Ewa");</p>
<p>pairsMap.putAll(otherPairsMap);</p>
<p>System.out.println(pairsMap.get("Marek"));<br />
System.out.println(pairsMap.remove("Marek"));<br />
System.out.println(pairsMap.size());<br />
System.out.println(pairsMap.isEmpty());<br />
System.out.println(pairsMap.containsKey("Jan"));<br />
System.out.println(pairsMap.containsValue("Adela"));<&#47;pre><br />
Pełna lista metod dostępna w interfejsie <code>Map<&#47;code> znajduje się w <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Map.html" target="_blank" rel="noopener">dokumentacji<&#47;a>.</p>
<h1>Skr&oacute;ty klawiaturowe<&#47;h1><br />
W IDE, kt&oacute;re proponowałem na początku (InteliJ) jest skr&oacute;t klawiaturowy, kt&oacute;ry bardzo może Ci się przydać w odkrywaniu nowych metod. Po wpisaniu zmiennej i kropki po niej naciśnij <code><Ctrl+Spacja><&#47;code> pojawi się menu kontekstowe z dostępnymi atrybutami&#47;metodami tego obiektu.</p>
<p><a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;wp-content&#47;uploads&#47;2016&#47;08&#47;tooltip.png"><img class="aligncenter wp-image-308 size-medium" src="http:&#47;&#47;www.samouczekprogramisty.pl&#47;wp-content&#47;uploads&#47;2016&#47;08&#47;tooltip-300x169.png" alt="skr&oacute;ty klawiaturowe intelij idea" width="300" height="169" &#47;><&#47;a></p>
<p>Kolejny przydatny skr&oacute;t klawiaturowy to <code><Ctrl + H><&#47;code>. Najedź kursorem na interfejs <code>List<&#47;code>, po naciśnięciu tego skr&oacute;tu pojawi się panel zawierający hierarchię dziedziczenia dla elementu pod kursorem. Także ten panel jest widoczny na zrzucie ekranu powyżej.</p>
<p>Dzięki szybkiemu wglądowi w hierarchii dziedziczenia możesz w łatwy spos&oacute;b odnaleźć inne implementacje danego interfejsu.</p>
<h1>Ograniczenia kolekcji<&#47;h1><br />
Jak już napisałem wyżej &bdquo;kolekcje to tablice na sterydach&rdquo;. Z tymi sterydami przychodzą także pewne ograniczenia. Gł&oacute;wnym ograniczeniem jest to że wraz z kolekcjami opisanymi powyżej nie możesz używać typ&oacute;w prymitywnych (<code>Integer<&#47;code> tak, <code>int<&#47;code> nie). Możesz to łatwo obejść poprzez używanie odpowiadających im obiekt&oacute;w, jednak obiekty takie zajmują więcej miejsca w pamięci niż typy prymitywne.</p>
<p>Istnieją implementacje kolekcji, kt&oacute;re pozwalają na używanie typ&oacute;w prymitywnych jednak na tym etapie nauki Javy nie zaprzątałbym sobie nimi głowy. Standardowe kolekcje są w zupełności wystarczające.</p>
<h1>Iterowanie po kolekcjach<&#47;h1><br />
Z artykułu opisującego pętle dowiedziałeś się o r&oacute;żnych rodzajach pętli i to właśnie na nich tutaj się skupimy[3. Na początku pominiemy strumienie, kt&oacute;rymi zajmiemy się w osobnym artykule.].</p>
<h2>Iterowanie po listach<&#47;h2><br />
Najprostszym sposobem jest iterowanie przy użyciu pętli <code>foreach<&#47;code>. Zgodnie z definicją listy elementy będą zwracane w kolejności dodawania ich do listy.</p>
<p>Jeśli potrzebujemy dostępu do indeksu elementu możemy użyć także standardowej pętli <code>for<&#47;code>. Jeśli takie podejście jest wymagane lepiej jest używać implementacji <code>ArrayList<&#47;code> niż <code>LinkedList<&#47;code>.</p>
<pre class="lang:default decode:true ">List<String> sampleList = new ArrayList<>();<br />
sampleList.add("Marcin");<br />
sampleList.add("Adela");<br />
sampleList.add("Marek");<br />
sampleList.add("Magda");</p>
<p>System.out.println("Iterowanie po liscie (foreach)");<br />
for(String item : sampleList) {<br />
    System.out.println(item);<br />
}</p>
<p>System.out.println("Iterowanie po liscie (for)");<br />
for(int index = 0; index < sampleList.size(); index++) {<br />
    System.out.println(sampleList.get(index));<br />
}<&#47;pre></p>
<h2>Iterowanie po zbiorach<&#47;h2><br />
Podobnie jak w przypadku list z pomocą przychodzi pętla <code>foreach<&#47;code>, jednak tutaj nie mamy już gwarancji zwr&oacute;cenia obiekt&oacute;w zbioru w tej samej kolejności, w kt&oacute;rej były one do niego dodawane (zachęcam do sprawdzenia tego samodzielnie).</p>
<pre class="lang:default decode:true">Set<String> sampleSet = new HashSet<>();<br />
sampleSet.add("Marcin");<br />
sampleSet.add("Adela");<br />
sampleSet.add("Marek");<br />
sampleSet.add("Magda");</p>
<p>System.out.println("Iterowanie po zbiorze");<br />
for(String item : sampleSet) {<br />
&nbsp;&nbsp;&nbsp; System.out.println(item);<br />
}<&#47;pre></p>
<h2>Iterowanie po mapach<&#47;h2><br />
Z racji tego, że w mapach mamy zbi&oacute;r kluczy mapowanych na wartości możemy iterować po samych kluczach, samych wartościach bądź parach klucz, wartość. Powinniśmy używać odpowiedniego sposobu w zależności od naszych potrzeb.</p>
<blockquote><p>Tutaj drobna dygresja, nowością może być dla Ciebie zapis <code>Map.Entry<String, String><&#47;code>. Jest to notacja wskazująca na tak zwaną klasę wewnętrzną (bądź inerfejs). Interfejs <code>Entry<&#47;code> został zdefiniowana wewnątrz <code>Map<&#47;code> dlatego odwołujemy się do niego poprzez <code>Map.Entry<&#47;code>. Jest to interfejs generyczny, kt&oacute;ry odpowiada parze klucz&#47;wartość, dlatego typowany jest tymi samymi typami co mapa z przykładu.<&#47;blockquote></p>
<pre class="lang:default decode:true">Map<String, String> sampleMap = new HashMap<>();<br />
sampleMap.put("Marek", "Magda");<br />
sampleMap.put("Marcin", "Adela");</p>
<p>System.out.println("Iterowanie po wartosciach");<br />
for(String value : sampleMap.values()) {<br />
&nbsp;&nbsp;&nbsp; System.out.println(value);<br />
}</p>
<p>System.out.println("Iterowanie po kluczach i pobieranie wartosci");<br />
for(String key : sampleMap.keySet()) {<br />
&nbsp;&nbsp;&nbsp; String value = sampleMap.get(key);<br />
&nbsp;&nbsp;&nbsp; System.out.println(key + ": " + value);<br />
}</p>
<p>System.out.println("Iterowanie po kluczach i wartosciach");<br />
for(Map.Entry<String, String> entry : sampleMap.entrySet()) {<br />
&nbsp;&nbsp;&nbsp; String key = entry.getKey();<br />
&nbsp;&nbsp;&nbsp; String value = entry.getValue();<br />
&nbsp;&nbsp;&nbsp; System.out.println(key + ": " + value);<br />
}<&#47;pre></p>
<h1>Por&oacute;wnanie typ&oacute;w kolekcji<&#47;h1><br />
Na koniec dla ułatwienia przygotowałem dla Ciebie tabelkę, kt&oacute;ra grupuje właściwości poszczeg&oacute;lnych kolekcji w jednym miejscu wraz z przykładem użycia.</p>
<table>
<thead>
<tr>
<th><&#47;th></p>
<th>Lista<&#47;th></p>
<th>Zbi&oacute;r<&#47;th></p>
<th>Mapa<&#47;th><br />
<&#47;tr><br />
<&#47;thead></p>
<tbody>
<tr>
<td>Zachowuje kolejność element&oacute;w<&#47;td></p>
<td>Tak<&#47;td></p>
<td>Nie<&#47;td></p>
<td>Nie<&#47;td><br />
<&#47;tr></p>
<tr>
<td>Pozwala na przechowywanie kliku takich samych element&oacute;w&#47;kluczy<&#47;td></p>
<td>Tak<&#47;td></p>
<td>Nie<&#47;td></p>
<td>Nie<&#47;td><br />
<&#47;tr></p>
<tr>
<td>Przykład użycia (podr&oacute;żowałeś przez Europę pociągiem)<&#47;td></p>
<td>Miasta, kt&oacute;re odwiedziłeś (cała trasa z drogą powrotną, niekt&oacute;re miasta odwiedziłeś także przy powrocie)<&#47;td></p>
<td>Zbi&oacute;r miast, kt&oacute;re odwiedziłeś (bez duplikat&oacute;w).<&#47;td></p>
<td>Nazwy państw, kt&oacute;re odwiedziłeś wraz z odpowiadającymi im stolicami.<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table></p>
<h1>Zadania<&#47;h1></p>
<ol>
<li>Napisz program, kt&oacute;ry będzie pobierał od użytkownika imiona. Program powinien pozwolić użytkownikowi na wprowadzenie dowolnej liczby imion (wprowadzenie &bdquo;-&rdquo; jako imienia przerwie wprowadzanie). Na zakończenie wypisz liczbę unikalnych imion.<&#47;li>
<li>Napisz program, kt&oacute;ry będzie pobierał od użytkownika imiona par dop&oacute;ki nie wprowadzi imienia &bdquo;-&rdquo;, następnie poproś użytkownika o podanie jednego z wcześniej wprowadzonych imion i wyświetl imię odpowiadającego mu partnera.<&#47;li><br />
<&#47;ol><br />
Jeśli będziesz miał problemy z rozwiązaniem kt&oacute;regokolwiek z zadań na githubie umieściłem przykładowe rozwiązania. Zachęcam do ich sprawdzenia dopiero po przygotowaniu swojej wersji :)</p>
<h1>Dodatkowe materiały do nauki<&#47;h1><br />
Materiał&oacute;w na temat kolekcji w internecie jest całkiem sporo, poniżej przygotowałem dla Ciebie zestaw link&oacute;w do innych blog&oacute;w&#47;kurs&oacute;w gdzie autorzy także opisują kolekcje. Jeśli będzie brakowało Ci materiał&oacute;w, bądź będziesz chciał poznać temat z innej strony zachęcam do zapoznania się z nimi. Na początek kod źr&oacute;dłowy przykład&oacute;w i rozwiązań zadań oraz&nbsp; dokumentacja biblioteki standardowej.</p>
<ul>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Map.html" target="_blank" rel="noopener">https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Map.html<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Set.html" target="_blank" rel="noopener">https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Set.html<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;List.html" target="_blank" rel="noopener">https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;List.html<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;KursJava&#47;tree&#47;master&#47;15_kolekcje&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;kursjava" target="_blank" rel="noopener">Kod źr&oacute;dłowy i przykłady rozwiązań zadań na githubie<&#47;a><&#47;li><br />
<&#47;ul><br />
No i zestaw pozostałych materiał&oacute;w :)</p>
<ul>
<li><a href="http:&#47;&#47;wazniak.mimuw.edu.pl&#47;index.php?title=PO_Kolekcje_wst%C4%99p" target="_blank" rel="noopener">http:&#47;&#47;wazniak.mimuw.edu.pl&#47;index.php?title=PO_Kolekcje_wst%C4%99p<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;wazniak.mimuw.edu.pl&#47;index.php?title=PO_Kolekcje_-_przegląd" target="_blank" rel="noopener">http:&#47;&#47;wazniak.mimuw.edu.pl&#47;index.php?title=PO_Kolekcje_-_przegląd<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;www.youtube.com&#47;watch?v=gvtt4m1aiwI" target="_blank" rel="noopener">ArrayList przykład użycia (youtube)<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;naukajavy.pl&#47;kurs-jezyka-java&#47;109-listy" target="_blank" rel="noopener">http:&#47;&#47;naukajavy.pl&#47;kurs-jezyka-java&#47;109-listy<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;naukajavy.pl&#47;kurs-jezyka-java&#47;105-zbiory" target="_blank" rel="noopener">http:&#47;&#47;naukajavy.pl&#47;kurs-jezyka-java&#47;105-zbiory<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;naukajavy.pl&#47;kurs-jezyka-java&#47;111-mapy" target="_blank" rel="noopener">http:&#47;&#47;naukajavy.pl&#47;kurs-jezyka-java&#47;111-mapy<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;tutorials.jenkov.com&#47;java-collections&#47;index.html" target="_blank" rel="noopener">http:&#47;&#47;tutorials.jenkov.com&#47;java-collections&#47;index.html<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;kobietydokodu.pl&#47;05-kolekcje-w-javie&#47;" target="_blank" rel="noopener">http:&#47;&#47;kobietydokodu.pl&#47;05-kolekcje-w-javie&#47;<&#47;a><&#47;li><br />
<&#47;ul></p>
<h1>Podsumowanie<&#47;h1><br />
Cieszę się, że dotrwałeś do końca. Musisz wiedzieć, że bez kolekcji nie ma programowania, ten artykuł jest naprawdę ważny :). Na koniec mam do Ciebie prośbę, proszę pom&oacute;ż mi dotrzeć do kolejnych samouk&oacute;w, podziel się z nimi adresem tego bloga, polub stronkę na fb, z g&oacute;ry wielkie dzięki!</p>
<p>Do następnego razu!</p>
<p>[FM_form id="3"]</p>
