---
layout: post
title: Konstrukcja try-with-resources w języku Java
excerpt: "Artykuł opisuje konstrukcję try-with-resources występującą w języku Java.
  Na przykładowym programie będziesz mógł dowiedzieć się jak ona działa. W
  artykule przeczytasz też o tym czym jest &bdquo;cukier syntaktyczny&rdquo;. Całość
  zakończymy jak zwykle zadaniem, które pozwoli Ci przećwiczyć materiał opisany
  w artykule. Zapraszam!\r\n\r\n"
date: '2016-08-25 18:45:08 +0200'
categories:
- Kurs programowania Java
---
<p>Artykuł opisuje konstrukcję try-with-resources występującą w języku Java. Na przykładowym programie będziesz mógł dowiedzieć się jak ona działa. W artykule przeczytasz też o tym czym jest &bdquo;cukier syntaktyczny&rdquo;. Całość zakończymy jak zwykle zadaniem, które pozwoli Ci przećwiczyć materiał opisany w artykule. Zapraszam!</p>
<p><a id="more"></a><a id="more-347"></a></p>
<p>[idea]To jest jeden z artykułów w ramach <a href="http://www.samouczekprogramisty.pl/kurs-programowania-java/">darmowego kursu programowania w Javie</a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[/idea]</p>
<h1>Try-with-resources</h1><br />
Pamiętasz w jaki sposób musieliśmy <a href="http://www.samouczekprogramisty.pl/operacje-na-plikach-w-jezyku-java/">obchodzić się ze strumieniami danych</a>? Trzeba było koniecznie pamiętać o ich zamknięciu. Generowało to sporą masę powtarzalnego kodu (ang. <em>boilerplate code</em>). Dobrą praktyką jest unikanie, powtórzeń &ndash; mniej kodu źródłowego, mniej miejsc do popełniania potencjalnego błędu :). Tutaj z pomocą przyszli twórcy Javy, wprowadzając konstrukcję &bdquo;try-with-resources&rdquo;.</p>
<p>Tego typu konstrukcję możemy nazwać cukrem syntaktycznym (ang. <em>syntactic sugar</em>). Takie konstrukcje upraszczają kod, jednak nie są niezbędne dla języka programowania. Innymi słowy programista mógłby sobie bez takich konstrukcji poradzić, jednak ich obecność zmniejsza ilość kodu, która jest potrzebna do wykonania tego samego zadania.</p>
<p>Najlepiej będzie jeśli zobaczymy to na przykładzie. Poniższy fragment kodu prezentuje odczytanie linijki z pliku tekstowego. W tym przykładzie także obsługujemy wyjątki, nie są one wspomniane w sygnaturze metody po klauzuli <code>throws</code> więc odpowiednie bloki <code>catch</code> muszą się znaleźć aby kompilator pozwolił nam ten kod skompilować (pamiętasz <a href="http://www.samouczekprogramisty.pl/wyjatki-w-jezyku-java/">wyjątki typu checked i unchecked</a>?)</p>
<pre class="lang:default decode:true">BufferedReader fileReader = null;<br />
try {<br />
    fileReader = new BufferedReader(new FileReader(inputPath));<br />
    fileReader.readLine();<br />
} catch (FileNotFoundException e) {<br />
    e.printStackTrace();<br />
} catch (IOException e) {<br />
    e.printStackTrace();<br />
} finally {<br />
    if (fileReader != null) {<br />
        try {<br />
            fileReader.close();<br />
        } catch (IOException e) {<br />
            e.printStackTrace();<br />
        }<br />
    }<br />
}</pre><br />
Prawda, że dużo tego? I tu z pomocą przychodzi konstrukcja try-with-resources, zobacz proszę jak ona wygląda:</p>
<pre class="lang:default decode:true ">try(BufferedReader fileReader = new BufferedReader(new FileReader(inputPath))) {<br />
    fileReader.readLine();<br />
} catch (FileNotFoundException e) {<br />
    e.printStackTrace();<br />
} catch (IOException e) {<br />
    e.printStackTrace();<br />
}</pre><br />
Konstrukcja wygląda jak <code>try</code>/<code>catch</code> z tym, że przez blokiem objętym <code>try</code> możemy zainicjalizować zmienne, które zostaną automatycznie zamknięte. Kompilator widząc konstrukcję try-with-resources wygeneruje za nas kod zbliżony do tego z pierwszego przykładu (w podobny sposób generuje np. domyślne konstruktory).</p>
<p>Konstrukcję try-with-resources możemy nazwać także &bdquo;menadżerem kontekstu&rdquo;, automatycznie zarządza ona za nas kontekstem, w ramach którego dostępne są zmienne zdefiniowane wewnątrz nawiasów <code>()</code>. Co więcej, wewnątrz tych nawiasów możemy zainicjalizować więcej zmiennych, każda z nich zostanie poprawnie zamknięta (zostanie na nich wywołana metoda <code>close</code>). W przykładzie poniżej odczytujemy linijkę z pliku wejściowego i zapisujemy ją do pliku wyjściowego (tutaj pominąłem obsługę wyjątków):</p>
<pre class="lang:default decode:true ">try(<br />
        BufferedReader fileReader = new BufferedReader(new FileReader(inputPath));<br />
        BufferedWriter fileWriter = new BufferedWriter(new FileWriter(outputPath))<br />
) {<br />
    String line = fileReader.readLine();<br />
    fileWriter.write(line);<br />
}</pre><br />
Taka struktura tłumaczona jest przez kompilator na sekwencję zagnieżdżonych bloków <code>try</code>/<code>catch</code>/<code>finally</code>. W każdym z tych zagnieżdżonych bloków zarządza kolejną zmienną. Zmienne zamykane są w odwrotnej kolejności niż są deklarowane, zatem w naszym przykładzie pierwszy zostanie zamknięty <code>fileWriter</code> po nim <code>fileReader</code>.</p>
<h1>Własne menadżery kontekstu</h1><br />
Całość działa, ponieważ klasy takie jak <code>BufferedFileWriter</code> czy <code>BufferedFileReader</code> implementują interfejs <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html" target="_blank"><code>java.lang.AutoCloseable</code></a>. Właściwie to wszystkie znane mi klasy do obsługi strumieni wejściowych/wyjściowych w standardowej bibliotece Javy implementują ten interfejs. To jest właśnie główne wymaganie, które musi być spełnione przez zmienne definiowane wewnątrz <code>()</code> gdy używamy konstrukcji try-with-resources.</p>
<p>Nasunąć się zatem może pytanie, czy&nbsp; możemy stworzyć własną klasę, która będzie działała z tą konstrukcją? Oczywiście! :) Poniżej przykład:</p>
<pre class="lang:default decode:true ">public class MyContextManager implements AutoCloseable {<br />
    public MyContextManager() {<br />
        System.out.println("Wlasnie sie tworze!");<br />
    }   </p>
<p>    public void doSomething() {<br />
        System.out.println("Wlasnie cos robie :)");<br />
    }   </p>
<p>    public void close() {<br />
        System.out.println("Ktos mnie teraz zamyka!");<br />
    }<br />
}</p>
<p>public class MyContextManagerMain {<br />
    public static void main(String[] args) {<br />
        try (MyContextManager manager = new MyContextManager()) {<br />
            manager.doSomething();<br />
        }<br />
    }<br />
}</pre><br />
<code>MyContextManager</code> implementuje interfejs <code>AutoCloseable</code> dzięki czemu możemy użyć go wewnątrz konstrukcji try-with-resources. Jeśli uruchomiłbyś metodę main z powyższego przykładu na konsoli pojawiłyby się następujące linijki:</p>
<pre class="lang:default highlight:0 decode:true ">Wlasnie sie tworze!<br />
Wlasnie cos robie :)<br />
Ktos mnie teraz zamyka!</pre><br />
Widzisz? Metody <code>close</code> nie wywoływałem nigdzie a mimo to została automatycznie wykonana podczas działania programu. Stało się tak właśnie dzięki kompilatorowi, który przetłumaczył konstrukcję try-with-resources na kod, który poprawnie zamyka zmienne.</p>
<h1>Zadanie</h1><br />
Teraz nadszedł czas na zadanie dla Ciebie. Strony w internecie tworzone są przy pomocy <code>HTML</code>, jest to język znaczników, który jest&nbsp; interpretowany przez przeglądarki internetowe wyświetlające strony www. Przykładem znaczników jest para <code><em></em></code>, jak widzisz jest tu znacznik otwierający <code><em></code> oraz zamykający <code></em></code> (akurat ta para odpowiedzialna jest za wyróżnianie tekstu). Wewnątrz znaczników znajduje się treść np. <code><em>tekst</em></code>. Istnieje wiele innych par znaczników np. <code>
<pre></pre></code>, <code><code></code></code>, <code><b></b></code> itd.,</p>
<p>Zaimplementuj klasę <code>HtmlTag</code>, która będzie menadżerem kontekstu. W konstruktorze powinna przyjmować nazwę znacznika np. <code>em</code>. Klasa powinna mieć metodę <code>body</code>, która przyjmie parametr typu <code>String</code> i wypisze go na konsoli. Uruchamiając kod</p>
<pre class="lang:default decode:true ">try (<br />
        HtmlTag h1 = new HtmlTag("h1");<br />
        HtmlTag em = new HtmlTag("em")<br />
) {<br />
    em.body("moj tekst");<br />
}</pre><br />
Na konsoli powinien znaleźć się tekst</p>
<pre class="lang:default highlight:0 decode:true">
<h1>
<em><br />
moj tekst<br />
</em><br />
</h1></pre><br />
Jak zwykle zachęcam do samodzielnego rozwiązania zadania, jeśli jednak utknąłbyś przygotowałem <a href="https://github.com/SamouczekProgramisty/KursJava/blob/master/17_manager_kontekstu/src/main/java/pl/samouczekprogramisty/kursjava/context/exercise/HtmlTag.java" target="_blank">przykładowe rozwiązanie</a>, które może Ci pomóc.</p>
<h1>Materiały dodatkowe</h1></p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html" target="_blank">dokumentacja interfejsu AutoCloseable</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20.3" target="_blank">sekcja z Java Language Specification opisująca konstrukcję try-with-resources</a></li>
<li><a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/17_manager_kontekstu/src/main/java/pl/samouczekprogramisty/kursjava/context" target="_blank">kod źródłowy przykładów i rozwiązanie zadania</a></li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Po przeczytaniu artykułu wiesz już jak używać konstrukcji try-with-resources, wiesz czym jest cukier syntaktyczny. Mam nadzieję, że spędziłeś trochę czasu rozwiązując zadanie, które pozwoliło Ci przećwiczyć wiedzę w praktyce. Na koniec mam do Ciebie wielką prośbę, zależy mi na dotarciu do jak największej liczby czytelników, możesz mi w tym pomóc polecając bloga znajomym i udostępniając link na facebooku, z góry dziękuję i do następnego razu.</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/livinginmonrovia</p>
