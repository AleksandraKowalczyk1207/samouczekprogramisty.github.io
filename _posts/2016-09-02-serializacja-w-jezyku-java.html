---
layout: post
status: publish
published: true
title: Serializacja w języku Java
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "W artykule tym dowiesz się czym jest serializacja obiekt&oacute;w w Javie.
  Przeczytasz o klasach takich jak <code>ObjectInputStream<&#47;code> czy <code>ObjectOutputStream<&#47;code>
  i dowiesz się czym r&oacute;żnią się od innych strumieni. Poznasz nowe słowo kluczowe
  <code>transient<&#47;code>. Po przeczytaniu artykułu będziesz w stanie napisać swoją
  mini bazę danych z użyciem mechanizmu serializacji. Zapraszam do lektury.\r\n\r\n"
wordpress_id: 379
wordpress_url: http://www.samouczekprogramisty.pl/?p=379
date: '2016-09-02 17:26:33 +0200'
date_gmt: '2016-09-02 15:26:33 +0200'
categories:
- Kurs programowania Java
tags: []
---
<p>W artykule tym dowiesz się czym jest serializacja obiekt&oacute;w w Javie. Przeczytasz o klasach takich jak <code>ObjectInputStream<&#47;code> czy <code>ObjectOutputStream<&#47;code> i dowiesz się czym r&oacute;żnią się od innych strumieni. Poznasz nowe słowo kluczowe <code>transient<&#47;code>. Po przeczytaniu artykułu będziesz w stanie napisać swoją mini bazę danych z użyciem mechanizmu serializacji. Zapraszam do lektury.</p>
<p><a id="more"></a><a id="more-379"></a></p>
<p>[idea]To jest jeden z artykuł&oacute;w w ramach <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;kurs-programowania-java&#47;">darmowego kursu programowania w Javie<&#47;a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[&#47;idea]</p>
<h1>Czym jest serializacja<&#47;h1><br />
W jednym z poprzednich artykuł&oacute;w przeczytałeś o <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;operacje-na-plikach-w-jezyku-java&#47;">strumieniach danych<&#47;a>, kt&oacute;re pozwalały na zapisywanie oraz odczytywanie danych. Poznałeś w&oacute;wczas między innymi klasy <code>DataInputStream<&#47;code> oraz <code>DataOutputStream<&#47;code>. Klasy te pomagają zapisywać typy proste i łańcuchy znak&oacute;w.</p>
<p>Serializacja to wbudowany mechanizm zapisywania obiekt&oacute;w, kt&oacute;ry pozwala na binarny zapis całego drzewa obiekt&oacute;w. Oznacza to tyle, że jeśli mamy obiekt X, kt&oacute;ry posiada referencję do obiektu Y to serializując X r&oacute;wnież Y zostanie automatycznie zapisany w strumieniu wyjściowym.</p>
<p>Tak zapisany obiekt możesz p&oacute;źniej otworzyć przy kolejnym uruchomieniu programu. Jednak serializacja ma więcej zastosowań.</p>
<p>Dzięki temu mechanizmowi można na przykład przesyłać obiekty przez sieć. Obiekt, kt&oacute;ry stworzyliśmy na jednym komputerze (wewnątrz pamięci jednej wirtualnej maszyny Java) może być zserializowany, przesłany przez sieć i zdeserializowany na drugim komputerze tworząc nową instancję obiektu (wewnątrz pamięci drugiej wirtualnej maszyny Javy). Na obu tych komputerach wirtualna maszyna Javy musi mieć dostęp do skompilowanej wersji klasy.</p>
<h1>Warunki wymagane do serializacji<&#47;h1><br />
Chociaż serializacja dostępna jest automatycznie dla większości obiekt&oacute;w z biblioteki standardowej to jeśli chcesz m&oacute;c serializować instancje klas, kt&oacute;re sam napiszesz musisz spełnić kilka warunk&oacute;w.</p>
<h2>Interfejs <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;Serializable.html" target="_blank"><code>java.io.Serializable<&#47;code><&#47;a><&#47;h2><br />
Jest to tak zwany interfejs znacznikowy, innymi słowy nie zwiera on żadnej metody. Służy on do pokazania wirtualnej maszynie, że instancje danej klasy implementującej ten interfejs mogą być serializowane. Musisz implementować ten interfejs jeśli chcesz aby twoje klasy były serilizowalne. Jeśli będziesz pr&oacute;bował zserializować klasę, kt&oacute;ra nie implementuje tego interfejsu zostanie rzucony wyjątek typu <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;NotSerializableException.html" target="_blank"><code>NotSerializableException<&#47;code><&#47;a>.</p>
<h2>Konstruktor bezparametrowy<&#47;h2><br />
Tutaj reguła niestety nie jest trywialna. Pierwsza klasa w hierarchii dziedziczenia, kt&oacute;ra nie jest serializowalna musi mieć dostępny konstruktor bezparametrowy. Łatwiej to będzie zrozumieć na przykładzie:</p>
<pre class="lang:default decode:true">public class Fruit {}<br />
public class Apple extends Fruit implements Serializable {}<br />
public class Tomato implements Serializable {}<&#47;pre><br />
W przykładzie powyżej klasa <code>Fruit<&#47;code> musi mieć konstruktor bezparametrowy abyśmy mogli poprawnie serializować instancje klasy <code>Apple<&#47;code>. Natomiast ani <code>Apple<&#47;code>, ani <code>Tomato<&#47;code> takiego konstruktora już nie wymagają (<code>Tomato<&#47;code> dziedziczy po <code>Object<&#47;code>, kt&oacute;ry taki konstruktor posiada).</p>
<p>Dodatkowo istnieje interfejs <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;Externalizable.html" target="_blank"><code>java.io.Externalizable<&#47;code><&#47;a> (opiszę go dokładnie kilka akapit&oacute;w niżej), kt&oacute;ry r&oacute;wnież zapewnia, że obiekty go implementujące są serializowalne. Jednak w tym przypadku obiekt taki musi także zapewnić konstruktor bezparametrowy, kt&oacute;ry jest wywoływany w trakcie deserializacji.</p>
<h2>Określić pola, kt&oacute;re nie są serializowalne<&#47;h2><br />
Ten krok jest opcjonalny, jednak w bardziej zaawansowanych przypadkach niezbędny. Wyobraź sobie, że napisałeś klasę <code>Human<&#47;code>, kt&oacute;ra jako jeden z atrybut&oacute;w posiada wiek zapisany w minutach od urodzenia. Zapisanie tego pola mogłoby prowadzić do odczytania niepoprawnego stanu (zapisujemy obiekt dzisiaj, odczytujemy jutro, wiek w minutach jest zupełnie inny).</p>
<p>Tutaj dochodzimy do słowa kluczowego <code>transient<&#47;code>. Ot&oacute;ż słowo to może być stosowane przed atrybutami klasy. Oznacza ono, że dany atrybut nie jest serializowalny i zostanie pominięty przez mechanizm serializacji[1. Istnieje też inny, mniej popularny spos&oacute;b ominięcia p&oacute;l podczas serializacjim&ndash; użycie pola <code>serialPersistentFields<&#47;code> (jest ono dokładniej opisane w <a href="http:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;platform&#47;serialization&#47;spec&#47;serial-arch.html#a6250" target="_blank">specyfikacji<&#47;a>).].</p>
<h1>Przykład serializacji obiektu<&#47;h1><br />
Proszę zwr&oacute;ć uwagę na fragment kodu poniżej, kt&oacute;ry pokazuje jak mechanizm serializacji działa w praktyce.</p>
<pre class="lang:default decode:true ">try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("objects.bin"))) {<br />
    outputStream.writeObject(Integer.valueOf(1));<br />
    outputStream.writeObject(Integer.valueOf(2));<br />
}</p>
<p>try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("objects.bin"))) {<br />
    Integer number = (Integer) inputStream.readObject();<br />
    System.out.println(number);<br />
    number = (Integer) inputStream.readObject();<br />
    System.out.println(number);<br />
}<&#47;pre><br />
W pierwszym bloku <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;konstrukcja-try-with-resources-w-jezyku-java&#47;">try-with-resources<&#47;a> otwieramy strumień typu <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;ObjectOutputStream.html" target="_blank"><code>ObjectOutputStream<&#47;code><&#47;a>, na kt&oacute;rym następnie wywołujemy metodę <code>writeObject<&#47;code> zapisując do strumienia dwie liczby.</p>
<p>W kolejnym bloku dzięki instancji <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;ObjectInputStream.html"><code>ObjectInputStream<&#47;code><&#47;a> odczytujemy wcześniej zapisane obiekty. Obiekty odczytywane są w takiej samej kolejności w jakiej zostały zapisane, w naszym przypadku na konsoli zostaną wyświetlone liczby 1 a p&oacute;źniej 2.</p>
<h1>Serializacja drzewa obiekt&oacute;w<&#47;h1><br />
Wspomniałem już wcześniej, że mechanizm serializacji automatycznie obsługuje drzewa obiekt&oacute;w. W przykładzie poniżej pokazana jest właśnie taka sytuacja. Instancja klasy <code>Car<&#47;code> posiada atrybuty typ&oacute;w <code>Engine<&#47;code> oraz <code>Tyre[]<&#47;code>. Serializując a następnie deserializując instancję tej klasy wszystkie jej atrybuty zostały także zapisane.</p>
<pre class="lang:default decode:true">Tyre[] tyres = new Tyre[] {new Tyre(16), new Tyre(16), new Tyre(16), new Tyre(16)};<br />
Engine engine = new Engine("some model");<br />
Car serializedCar = new Car(engine, tyres);<br />
try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("object-graph.bin"))) {<br />
    outputStream.writeObject(serializedCar);<br />
}</p>
<p>Car deserializedCar = null;<br />
try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("object-graph.bin"))) {<br />
    deserializedCar = (Car) inputStream.readObject();<br />
    System.out.println(deserializedCar.getEngine().getModel());<br />
    System.out.println(deserializedCar.getTyres().length);<br />
}</p>
<p>System.out.println(serializedCar == deserializedCar);<&#47;pre><br />
Zwr&oacute;ć proszę uwagę na ostatnią linię. W linijce tej por&oacute;wnywane są dwa adresy instancji klasy <code>Car<&#47;code> (pamiętasz <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;porownywanie-obiektow-metody-equals-i-hashcode-w-jezyku-java&#47;">r&oacute;żnicę między <code>==<&#47;code> a <code>equals<&#47;code><&#47;a>?). Oczywiście linijka ta wyświetli <code>false<&#47;code> na konsoli co dowodzi, że w procesie deserializacji został stworzony zupełnie nowy obiekt klasy <code>Engine<&#47;code>.</p>
<h1>Deserializacja atrybut&oacute;w <code>transient<&#47;code><&#47;h1><br />
Zaraz, jak to? Przecież kilka akapit&oacute;w wyżej napisałem, że atrybuty poprzedzone słowem kluczowym transient nie są serializowane. Tak to prawda, jednak podczas deserializacji atrybuty tego typu należy zainicjalizować pewną wartością. Ot&oacute;ż dla każdego typu mamy taką domyślną wartość:</p>
<ul>
<li><code>boolean<&#47;code> - <code>false<&#47;code>,<&#47;li>
<li>liczby całkowite (<code>int<&#47;code>, <code>long<&#47;code>, itd.) - <code>0<&#47;code>,<&#47;li>
<li>liczby ułamkowe (<code>float<&#47;code>, <code>duble<&#47;code>) - <code>0.0<&#47;code>,<&#47;li>
<li>obiekty (<code>Integer<&#47;code>, <code>Float<&#47;code>, <code>String<&#47;code>, <code>CustomClass<&#47;code>, itd.) - <code>null<&#47;code><&#47;li><br />
<&#47;ul></p>
<pre class="lang:default decode:true ">public class Human implements Serializable {<br />
    private static final long serialVersionUI<code>D = 1L;</p>
<p>    private transient Integer age;<br />
    private String name;</p>
<p>    public Human(String name, Integer age) {<br />
        this.age = age;<br />
        this.name = name;<br />
    }</p>
<p>    public Integer getAge() {<br />
        return age;<br />
    }</p>
<p>    public String getName() {<br />
        return name;<br />
    }</p>
<p>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br />
        Human human = new Human("Krzysiek", 21);</p>
<p>        try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("human.bin"))) {<br />
            output.writeObject(human);<br />
        }</p>
<p>        try (ObjectInputStream input = new ObjectInputStream(new FileInputStream("human.bin"))) {<br />
            Human readHuman = (Human) input.readObject();<br />
            System.out.println(readHuman.getName());<br />
            System.out.println(readHuman.getAge());<br />
        }<br />
    }<br />
}<&#47;code><&#47;pre><br />
W przykładzie powyżej po deserializacji pole <code>age<&#47;code> będzie miało wartość <code>null<&#47;code> ponieważ jest to wartość domyślna dla atrybut&oacute;w poprzedzonych słowem kluczowym <code>transient<&#47;code>, kt&oacute;re są obiektami.</p>
<h1>Pola statyczne a serializacja<&#47;h1><br />
Serializacja dotyczy instancji klasy, nie samej klasy. Zatem jeśli zmodyfikowałeś pole statyczne a następnie zdeserializowałeś taki obiekt wprowadzone zmiany zostaną pominięte. Proszę sp&oacute;jrz na przykład poniżej.</p>
<pre class="lang:default decode:true ">StaticSerialization object = new StaticSerialization();<br />
object.someField = 200;<br />
System.out.println(object.someField);</p>
<p>try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("static.bin"))) {<br />
    output.writeObject(object);<br />
}<&#47;pre><br />
W przykładzie tym modyfikujemy wartość pola statycznego <code>someField<&#47;code> a następnie serializujemy instancję klasy do pliku.</p>
<pre class="lang:default decode:true">try (ObjectInputStream input = new ObjectInputStream(new FileInputStream("static.bin"))) {<br />
    StaticSerialization otherObject = (StaticSerialization) input.readObject();<br />
    System.out.println(otherObject.someField);<br />
}<&#47;pre><br />
W drugim uruchomieniu programu (w kt&oacute;rym nie zmodyfikowaliśmy wartości atrybutu statycznego <code>someField<&#47;code>) deserializujemy ten sam plik. W tym przypadku otrzymamy wartość 100 a nie 200, kt&oacute;re miał obiekt zapisywany do pliku.</p>
<p>To co trzeba zapamiętać to to, że pola statyczne nie są serializowane a są pobierane z <em>aktualnej<&#47;em> definicji klasy (nie z klasy z momentu serializacji).</p>
<p>Możemy powiedzieć, że atrybuty <code>static<&#47;code> są też domyślnie <code>transient<&#47;code>. Jak zatem takie zmiany odzwierciedlić podczas deserializacji? Jest na to spos&oacute;b :)</p>
<h1>Specjalna obsługa serializacji&#47;deserializacji<&#47;h1><br />
W specyficznych przypadkach masz możliwość zmodyfikowania domyślnego zachowania mechanizmu serializacji. Możesz to zrobić jeśli zaimplementujesz poniższe metody.</p>
<pre class="lang:default decode:true">private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException<br />
private void writeObject(java.io.ObjectOutputStream stream) throws IOException<&#47;pre><br />
Poniższy przykład powinien Ci pom&oacute;c w zrozumieniu tego mechanizmu</p>
<pre class="lang:default decode:true ">public class CustomSerialization implements Serializable {<br />
    private static final long serialVersionUID = 1L;</p>
<p>    private transient int someField;<br />
    private String otherField;</p>
<p>    public CustomSerialization(int someField, String otherField) {<br />
        this.someField = someField;<br />
        this.otherField = otherField;<br />
    }</p>
<p>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br />
        CustomSerialization writtenObject = new CustomSerialization(10, "something");</p>
<p>        try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("custom-serialization.bin"))) {<br />
            outputStream.writeObject(writtenObject);<br />
        }</p>
<p>        try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("custom-serialization.bin"   ))) {<br />
            CustomSerialization readObject = (CustomSerialization) inputStream.readObject();<br />
            System.out.println(readObject.someField);<br />
            System.out.println(readObject.otherField);<br />
        }<br />
    }</p>
<p>    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {<br />
        someField = stream.readInt();<br />
        otherField = stream.readUTF();<br />
    }</p>
<p>    private void writeObject(ObjectOutputStream stream) throws IOException {<br />
        stream.writeInt(someField);<br />
        stream.writeUTF(otherField + " SERIALIZED!");<br />
    }<br />
}<&#47;pre><br />
Jak widzisz obie metody są tu zaimplementowane. <code>writeObject<&#47;code> jako argument dostaje strumień, do kt&oacute;rego powinniśmy zapisać nasz obiekt. W przykładzie zapisuję zar&oacute;wno wartość pola z modyfikatorem <code>transient<&#47;code> jak i delikatnie zmienioną wartość atrybutu <code>otherField<&#47;code>.</p>
<p>Metoda <code>readObject<&#47;code> jako jedyny argument przyjmuje strumień, z kt&oacute;rego powinniśmy odczytać stan obiektu. Podobnie jak w przypadku samej serializacji, pola odczytujemy w tej samej kolejności w kt&oacute;rej je wcześniej zapisywaliśmy.</p>
<p>Warto tutaj zwr&oacute;cić uwagę na to, że klasa <code>ObjectInputStream<&#47;code> posiada metodę <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;ObjectInputStream.html#defaultReadObject&mdash;" target="_blank"><code>defaultReadObject<&#47;code><&#47;a>, kt&oacute;ra przeprowadza standardową deserializację, kt&oacute;rą możesz rozszerzyć. Podobnie wygląda to w przypadku klasy <code>ObjectOutputStream<&#47;code> i metody <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;ObjectOutputStream.html#defaultWriteObject--" target="_blank"><code>defaultWriteObject<&#47;code><&#47;a>. Metody te mogą być wywołane wyłącznie w trakcie (de)serializacji obiektu.</p>
<h1>Serializacja a dziedziczenie<&#47;h1><br />
W poprzednich przykładach użyliśmy klasy <code>Engine<&#47;code>, kt&oacute;ra implementuje interfejs <code>Serializable<&#47;code>. Zał&oacute;żmy, że utworzyliśmy klasę <code>DieselEngine<&#47;code>, kt&oacute;ra dziedziczy po <code>Engine<&#47;code>. Automatycznie instancje klasy <code>DieselEngine<&#47;code> będą implementowały interfejs <code>Serializable<&#47;code> (dziedzicząc go z <code>Engine<&#47;code>). Co powinniśmy zrobić jeśli nie chcielibyśmy aby nasz <code>DieselEngine<&#47;code> był serializowalny? Należy użyć wspomnianego już wyjątku <code>NotSerializableException<&#47;code> jak w przykładzie poniżej:</p>
<pre class="lang:default decode:true">public class DieselEngine extends Engine {<br />
    public DieselEngine() {<br />
        super("diesel");<br />
    }</p>
<p>    private void writeObject(ObjectOutputStream out) throws IOException {<br />
        throw new NotSerializableException("DieselEngine isn't serializable!");<br />
    }</p>
<p>    private void readObject(ObjectInputStream in) throws IOException {<br />
        throw new NotSerializableException("DieselEngine isn't serializable!");<br />
    }<br />
}<&#47;pre></p>
<h1>Pełny wpływ na mechanizm serializacji<&#47;h1><br />
Istnieje jeszcze jeden, dużo mniej popularny spos&oacute;b zapewnienia iż obiekt może być serializowany. Jest nim interfejs <code>Externalizable<&#47;code>. W tym przypadku interfejs ten zawiera dwie metody, kt&oacute;re musimy zaimplementować. Dodatkowo takie klasy muszą mieć konstruktor bezparametrowy, reszta pozostaje bez zmian. W przypadku tego podejścia cały protok&oacute;ł serializacji, kolejność zapisanych p&oacute;l, format etc. leży po naszej stronie. Poniżej prosty przykład, w kt&oacute;rym używam właśnie takiego podejścia.</p>
<p>W tym przypadku do utworzenia obiektu mechanizm serializacji używa standardowego konstruktora bezparametrowego. Po czym wywołuje na tej instancji metodę <code>readExternal<&#47;code>.</p>
<pre class="lang:default decode:true">public class CustomProtocolSerialization implements Externalizable {<br />
&nbsp;&nbsp;&nbsp; private String field;</p>
<p>&nbsp;&nbsp;&nbsp; public CustomProtocolSerialization() {<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; public CustomProtocolSerialization(String field) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.field = field;<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws IOException, ClassNotFoundException {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomProtocolSerialization object = new CustomProtocolSerialization("field value");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("externalizable.bin"))) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output.writeObject(object);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try (ObjectInputStream input = new ObjectInputStream(new FileInputStream("externalizable.bin"))) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CustomProtocolSerialization readObject = (CustomProtocolSerialization) input.readObject();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(readObject.field);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; public void writeExternal(ObjectOutput out) throws IOException {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.writeUTF(field);<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; field = in.readUTF();<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<&#47;pre></p>
<h1>Pole <code>serialVersionUID<&#47;code><&#47;h1><br />
Dodatkowo musisz wiedzieć o statycznym polu w klasie o nazwie <code>serialVersionUID<&#47;code>. Jego pełna definicja wygląda następująco:<br />
<span class="lang:default decode:true crayon-inline "> private static long serialVersionUID<&#47;span></p>
<p>Pole to ma specyficzne zastosowanie. Mechanizm serializacji używa go do upewnienia się, że deserializowany obiekt &bdquo;pasuje&rdquo; do danych zapisanych w strumieniu. Wie o tym na podstawie wartości tego pola. Jeśli w zdeserializowanym obiekcie wartość tego pola jest taka sama jak aktualnej definicji klasy w&oacute;wczas można bezpiecznie przeprowadzić deserializację.</p>
<p>Kiedy taka sytuacja może wystąpić? Zał&oacute;żmy, że dzisiaj napiszesz klasę <code>Human<&#47;code>, zdeserializujesz jej instancję i zapiszesz w pliku na dysku. Po jakimś czasie wprowadzisz zmiany w klasie i będziesz chciał odczytać starą wersję z pliku. W niekt&oacute;rych przypadkach taka operacja nie będzie dozwolona. Właśnie wtedy pole <code>serialVersionUID<&#47;code> może pom&oacute;c w wykryciu takiej sytuacji.</p>
<p>Pole to możesz ustawić samodzielnie, jeśli tego nie zrobisz kompilator wygeneruje tę wartość za Ciebie na podstawie definicji klasy.</p>
<h1>Materiały dodatkowe<&#47;h1><br />
Na początek zestaw dokumentacji do klas, związanych z tematem, jak zwykle znajdziesz tam ogrom informacji.</p>
<ul>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;Serializable.html" target="_blank">Serializable<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;Externalizable.html">Externalizable<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;ObjectOutputStream.html" target="_blank">ObjectOutputStream<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;ObjectInputStream.html">ObjectInputStream<&#47;a><&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;io&#47;NotSerializableException.html" target="_blank">NotSerializableException<&#47;a><&#47;li><br />
<&#47;ul><br />
Dodatkowo możesz zajrzeć do <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;platform&#47;serialization&#47;spec&#47;serialTOC.html" target="_blank">specyfikacja mechanizmu serializacji<&#47;a> albo <a href="http:&#47;&#47;www.oracle.com&#47;technetwork&#47;articles&#47;java&#47;javaserial-1536170.html" target="_blank">artykułu na stronie Oracle<&#47;a>. Znalazłem też inne opracowanie, kt&oacute;re poruszą także zagadnienie <a href="http:&#47;&#47;wazniak.mimuw.edu.pl&#47;index.php?title=PO_Serializacja" target="_blank">serializacji, także do formatu XML<&#47;a>. Możesz też rzucić okiem na <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;KursJava&#47;tree&#47;master&#47;18_serializacja&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;kursjava&#47;serialization" target="_blank">przykłady użyte w tym artykule<&#47;a>.</p>
<h1>Zadania<&#47;h1><br />
Na koniec jak zwykle zadania dla Ciebie do przećwiczenia materiału z tego artykułu.</p>
<ul>
<li>Napisz program, kt&oacute;ry poprosi użytkownika o wprowadzenie kilku imion, imiona te zapisz w liście a następnie zserializuj ją do pliku. Napisz metodę, kt&oacute;ra odczyta ten plik i wyświetli zawartość listy na konsoli. Wiesz, że właśnie napisałeś prostą bazę danych? ;)<&#47;li>
<li>Napisz klasę <code>Human<&#47;code>, kt&oacute;ra będzie miała dwa atrybuty <code>name<&#47;code> typu <code>String<&#47;code> oraz <code>age<&#47;code> typu <code>int<&#47;code>. Jak należałoby serializować instancje tej klasy aby zawsze poprawnie deserializować wiek (z dokładnością do roku)? (Wskaz&oacute;wka, możesz użyć metody <code>Calendar.getInstance().get(Calendar.YEAR)<&#47;code>, kt&oacute;ra zwraca aktualny rok)<&#47;li><br />
<&#47;ul><br />
Przygotowałem też dla Ciebie <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;KursJava&#47;tree&#47;master&#47;18_serializacja&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;kursjava&#47;serialization&#47;exercise" target="_blank">przykładowe rozwiązania<&#47;a> powyższych zadań, jednak traktuj je proszę jako ostatnią deskę ratunku :) Więcej nauczysz się pr&oacute;bując samemu rozwiązać powyższe zadania.</p>
<h1>Podsumowanie<&#47;h1><br />
Po przeczytaniu tego artykułu wiesz już czym są klasy <code>ObjectOutputStream<&#47;code> i <code>ObjectInputStream<&#47;code>. Znasz zasady serializacji, poznałeś słowo kluczowe <code>transient<&#47;code>. Teraz jesteś w stanie zapisać i odczytać każdą instancję klasy, kt&oacute;rą stworzysz.</p>
<p>Bardzo się cieszę, że przeczytałeś cały artykuł. Na koniec mam do Ciebie prośbę. Proszę przekaż adres bloga swoim znajomym, w grupie uczy się raźniej ;) Jeśli nie chcesz ominąć nowych artykuł&oacute;w dopisz się do newslettera i polub stronę Samouczka na facebooku. Miłego dnia i do następnego razu :)</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https:&#47;&#47;www.flickr.com&#47;photos&#47;28653536@N07&#47;.</p>
