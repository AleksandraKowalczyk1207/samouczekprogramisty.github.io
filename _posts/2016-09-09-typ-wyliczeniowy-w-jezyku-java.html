---
layout: default
title: Typ wyliczeniowy w języku Java
excerpt: "W artykule tym przeczytasz o typie wyliczeniowym. Poznasz słowo kluczowe
  <code>enum</code>. Na koniec czeka na Ciebie zestaw zadań, w którym przećwiczysz
  wiedzę z tego artykułu. Dowiesz się kiedy używamy typu enum. Napiszesz też prosty
  kalkulator w oparciu o Twój typ wyliczeniowy. Zapraszam do lektury.\r\n\r\n"
date: '2016-09-09 15:30:32 +0200'
categories:
- Kurs programowania Java
---
<p>W artykule tym przeczytasz o typie wyliczeniowym. Poznasz słowo kluczowe <code>enum</code>. Na koniec czeka na Ciebie zestaw zadań, w którym przećwiczysz wiedzę z tego artykułu. Dowiesz się kiedy używamy typu enum. Napiszesz też prosty kalkulator w oparciu o Twój typ wyliczeniowy. Zapraszam do lektury.</p>
<p><a id="more"></a><a id="more-400"></a></p>
<p>[idea]To jest jeden z artykułów w ramach <a href="http://www.samouczekprogramisty.pl/kurs-programowania-java/">darmowego kursu programowania w Javie</a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[/idea]</p>
<h1>Enum, typ wyliczeniowy</h1><br />
Wyobraź sobie, że mamy klasę <code>Tshirt</code>, która posiada kilka atrybutów takich jak kolor, rozmiar czy producent. O ile producentów koszulek, podobnie jak ich kolorów jest dość dużo to rozmiary są już bardzo często wspólne dla różnych producentów. Rozmiary możemy wyliczyć: S, M, L czy XL. I właśnie do przechowywania danych tego typu Java ma specjalny typ. Jest to enum zwany także typem wyliczeniowym. Przejdźmy od razu do przykładu:</p>
<pre class="lang:default decode:true ">public enum SimpleSize {<br />
    S,<br />
    M,<br />
    L,<br />
    XL<br />
}</pre><br />
Fragment kodu powyżej pokazuje typ wyliczeniowy <code>TshirtSize</code>, który może mieć jedną z czterech wartości <code>S</code>, <code>M</code>, <code>L</code> lub <code>XL</code>. Kolejne wartości typu wyliczeniowego oddzielamy przecinkiem.</p>
<p>Konwencja nadawania nazw zaleca aby wartości dla typu enum pisane były drukowanymi literami. Zatem <code>TshirtSize.S</code> jest w porządku, podczas gdy <code>TshirtSize.s</code> już nie.</p>
<p>Proszę spójrz na przykład użycia:</p>
<pre class="lang:default decode:true ">public class Tshirt {<br />
    private TshirtSize size;<br />
    private String manufacturer;</p>
<p>    public Tshirt(TshirtSize size, String manufacturer) {<br />
        this.size = size;<br />
        this.manufacturer = manufacturer;<br />
    }   </p>
<p>    public static void main(String[] args) {<br />
        Tshirt tshirt = new Tshirt(TshirtSize.L, "Polex");<br />
        System.out.println(tshirt.size);<br />
    }<br />
}</pre><br />
Jak widzisz w przykładzie wyżej mamy klasę <code>Tshirt</code>, reprezentującą koszulkę, która jako jeden z atrybutów ma właśnie rozmiar, który jest typu <code>TshirtSize</code>.</p>
<p>Do wartości typu wyliczeniowego odnosimy się jak do pól statycznych klasy, zatem w naszym przypadku do rozmiaru L możemy odwołać się jako <code>TshirtSize.L</code>. Dzieję się tak ponieważ w rzeczywistości wartości typu wyliczeniowego mają automatycznie dodane modyfikatory <code>public static final</code>.</p>
<h2>Typ wyliczeniowy a blok <code>switch</code></h2><br />
W jednym z <a href="http://www.samouczekprogramisty.pl/petle-i-nstrukcje-warunkowe-w-jezyku-java/">poprzednich artykułów</a> poznałeś konstrukcję <code>switch</code>. W tamtej części wspomniałem, o tym, że wewnątrz tej konstrukcji możemy używać liczb całkowitych czy łańcuchów znaków. Pominąłem wówczas jedną z dodatkowych wartości konstrukcji <code>switch</code>. Otóż wewnątrz możemy użyć także typu wyliczeniowego jak w przykładzie poniżej:</p>
<pre class="lang:default decode:true ">switch (tshirt.size) {<br />
    case S:<br />
        System.out.println("Kupiles koszulke w rozmiarze small");<br />
        break;<br />
    case M:<br />
        System.out.println("Kupiles koszulke w rozmiarze medium");<br />
        break;<br />
    case L:<br />
        System.out.println("Kupiles koszulke w rozmiarze large");<br />
        break;<br />
    case XL:<br />
        System.out.println("Kupiles koszulke w rozmiarze extra large");<br />
        break;<br />
}</pre><br />
W takim przypadku w zależności od wartości zmiennej size zostanie wywołana odpowiedni blok konstrukcji <code>switch</code>. Proszę zauważ, że w tym przypadku kompilator dokładnie wie jakiego typu są wartości <code>L</code>, <code>M</code>, <code>S</code> czy <code>XL</code> i nie możemy się do nich odwoływać poprzez pełną nazwę <code>TshirtSize.M</code>.</p>
<h2>Typ wyliczeniowy to też klasa</h2><br />
Podobnie jak w przypadku normalnych klas tak i w przypadku typów wyliczeniowych może on posiadać atrybuty czy metody. Możesz także stworzyć klasę wyliczeniową, która będzie miała swój własny konstruktor inny od domyślnego. Spójrz na przykład poniżej</p>
<pre class="lang:default decode:true ">public enum TshirtSize {<br />
    S(48, 71, 36),<br />
    M(52, 74, 38),<br />
    L(56, 76, 41),<br />
    XL(61, 79, 41);</p>
<p>    private int chestWidth;<br />
    private int shirtLength;<br />
    private int sleeveLength;</p>
<p>    TshirtSize(int chestWidth, int shirtLength, int sleeveLength) {<br />
        this.chestWidth = chestWidth;<br />
        this.shirtLength = shirtLength;<br />
        this.sleeveLength = sleeveLength;<br />
    }   </p>
<p>    public int getChestWidth() {<br />
        return chestWidth;<br />
    }</p>
<p>    public int getShirtLength() {<br />
        return shirtLength;<br />
    }</p>
<p>    public int getSleeveLength() {<br />
        return sleeveLength;<br />
    }<br />
}</pre><br />
W przykładzie nasz enum został rozszerzony o trzy atrybuty: szerokość klatki piersiowej, długość koszulki i długość rękawa. Dzięki dodaniu atrybutów do typu wyliczeniowego wszystkie potrzebne dane związane z jednym rozmiarem mamy zgrupowane w jednym miejscu.</p>
<p>Każdy typ wyliczeniowy, który napiszesz domyślnie tworzony jest jako typ <code>final</code>. Ograniczone są także modyfikatory dostępu, które możesz użyć, w przypadków enumów dopuszczalny jest wyłącznie modyfikator <code>public</code> lub brak jakiegokolwiek modyfikatora dostępu.</p>
<p>Typ wyliczeniowy nie może określić żadnej nadklasy po której dziedziczy. Dzieje się tak ponieważ każdy enum domyślnie dziedziczy po <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html" target="_blank"><code>java.lang.Enum</code></a>. Dzięki tej nadklasie wszystkie typy wyliczeniowe zyskują kilka dodatkowych metod opisanych w kolejnych akapitach.</p>
<p>Jeśli nasz enum ma także metody czy konstruktory to lista jego wartości musi znajdować się na początku.</p>
<h2>Słów kilka o konstruktorze enuma</h2><br />
Mimo tego, że jesteś w stanie utworzyć swój konstruktor dla typu wyliczeniowego to nie możesz go wywołać poza definicją enuma. Każde inne użycie powoduje błąd kompilacji. To ile wartości ma typ wyliczeniowy określasz w kodzie, nie możesz tworzyć nowych instancji w trakcie działania programu. Konstruktor domyślne ma przypisane słowo kluczowe private &bdquo;dodawane przez kompilator&rdquo;.</p>
<h2>Porównywanie typów wyliczeniowych</h2><br />
Poza konstrukcją <code>switch</code> typy wyliczeniowe możemy także stosować w blokach <code>if</code>. Możemy porównywać ich wartości przy pomocy operatora <code>==</code>. Oczywiście metoda <code>equals</code> też będzie działała jak się tego spodziewasz. W rzeczywistości wewnątrz metody <code>equals</code> w typie wyliczeniowym do porównania użyty jest właśnie operator <code>==</code>.</p>
<h2>Metody dostępne w każdym typie wyliczeniowym</h2><br />
Dzięki nadklasie <code>Enum</code>, o której wspomniałem w jednym z poprzednich akapitów mamy dostęp do kilku dodatkowych metod.</p>
<p><code>ordinal</code>, metoda zwraca indeks aktualnej wartości typu wyliczeniowego. Indeks pierwszego elementu to zawsze 0. W związku z tym kolejność definiowania wartości typu wyliczeniowego jest istotna.</p>
<p>Przydatna jest także metoda <code>name</code>, która zwraca nazwę wartości typu wyliczeniowego. W naszym przypadku <code>TshirtSize.L.name()</code> zwróci <code>"L"</code>.</p>
<p>Wszystkie typy wyliczeniowe mają także przydatne metody statyczne. Jedną z nich jest metoda <code>values</code>. Pozwala ona na iterowanie po wartościach typu wyliczeniowego. Zwraca tablicę wartości typu wyliczeniowego</p>
<p>Dostępna jest także metoda <code>valueOf</code>, która przyjmuje łańcuch znaków i zwraca wartość typu wyliczeniowego. W naszym przypadku <code>TshirtSize.valueOf("L")</code> zwróci <code>TshirtSize.L</code>.</p>
<h1>Kiedy i po co używać typów wyliczeniowych</h1><br />
Typów wyliczeniowych/enumów używamy w momencie jeśli jakiś atrybut/zmienna może mieć określoną, ograniczoną listę wartości. Zastosowanie typu wyliczeniowego może pomóc ograniczyć liczbę błędów, na przykład w miejscu gdzie normalnie używalibyśmy łańcucha znaków reprezentującego rozmiar używamy dokładnie zdefiniowanego typu wyliczeniowego.</p>
<p>Dzięki typom wyliczeniowym możemy w jednym miejscu zgrupować wszystkie dopuszczalne wartości. Pozwala to także na łatwe rozszerzanie tej listy.</p>
<h1>Metody abstrakcyjne w typie wyliczeniowym</h1><br />
Poza zwykłymi metodami, konstruktorami czy atrybutami enumy mogą posiadać metody abstrakcyjne. Tylko gdzie mielibyśmy je zaimplementować jeśli jedyne instancje typu wyliczeniowego musimy zdefiniować w klasie? Proszę spójrz na przykład poniżej.</p>
<pre class="lang:default decode:true ">public enum Formatter {<br />
    CALM {<br />
        public String format(String message) {<br />
            return "Here is your message: " + message;<br />
        }<br />
    },<br />
    NERVOUS {<br />
        public String format(String message) {<br />
            return "ARGH! STOP BOTHERING ME WITH YOUR MESSAGE! " + message + " I'M NOT GOING TO ACCEPT ANYTHING MORE!";<br />
        }<br />
    };</p>
<p>    public abstract String format(String message);<br />
}</pre><br />
Konstrukcja taka jak na przykładzie powyżej to nic innego jak zdefiniowanie ciała metody <code>format</code> wewnątrz poszczególnych wartości. Dzięki takiemu podejściu metody <code>Formatter.CALM.format()</code> i <code>Formatter.NERVOUS.format()</code> mogą mieć różną implementację.</p>
<h1>Materiały dodatkowe</h1><br />
Przygotowałem dla Ciebie zestaw materiałów dodatkowych jeśli chciałbyś poczytać na temat typów wyliczeniowch w innych miejscach.</p>
<ul>
<li><a href="https://rpodhajny.wordpress.com/2009/02/17/typ-enum" target="_blank">https://rpodhajny.wordpress.com/2009/02/17/typ-enum</a></li>
<li><a href="https://www.youtube.com/watch?v=IHcTGxFQSm8" target="_blank">https://www.youtube.com/watch?v=IHcTGxFQSm8</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html" target="_blank">https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9" target="_blank">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9</a></li>
<li><a href="http://tutorials.jenkov.com/java/enums.html" target="_blank">http://tutorials.jenkov.com/java/enums.html</a></li><br />
</ul><br />
Kod źródłowy dla wszystkich przykładów użytych w artykule znajduje się na <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/19_typ_wyliczeniowy/src/main/java/pl/samouczekprogramisty/kursjava/enums" target="_blank">githubie</a>.</p>
<h1>Zadania</h1></p>
<ol>
<li>Napisz klasę <code>Human</code>, która będzie reprezentowała człowieka. Niech klasa ta posiada atrybuty takie jak imię, wiek, kolor oczu, kolor włosów. Niech te dwa ostatnie atrybuty będą typami wyliczeniowymi. Stwórz instancję takiej klasy.</li>
<li>Napisz typ wyliczeniowy <code>Computation</code>, który będzie reprezentował prosty kalkulator. Niech typ ten posiada następujące wartości <code>MULTIPY</code>, <code>DIVIDE</code>, <code>ADD</code>, <code>SUBTRACT</code>. Niech typ ten posiada metodę <code>public double perform(double x, double y)</code>, która zwróci wynik odpowiedniej operacji. Na przykład <code>Computation.ADD.perform(1, -5)</code> powinno zwrócić -4.</li><br />
</ol><br />
Przygotowałem dla Ciebie przykładowe rozwiązania. Proszę jednak abyś spróbował rozwiązać zadania samodzielnie, wówczas najwięcej się nauczysz. Kod rozwiązań znajdziesz w <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/19_typ_wyliczeniowy/src/main/java/pl/samouczekprogramisty/kursjava/enums/exercise" target="_blank">repozytorium na githubie</a>.</p>
<h1>Podsumowanie</h1><br />
Po przeczytaniu artykułu i zrobieniu zadań wiesz już wszystko na temat typów wyliczeniowych w Javie. Żadne zakamarki enumów nie są Ci obce :) Na koniec mam do Ciebie prośbę, proszę podziel się informacją o blogu ze swoimi znajomymi, udostępnienie linka do artykułu na facebooku naprawdę pomaga mi dotrzeć do jak największej liczby czytelników a na tym właśnie mi zależy. Jeśli masz jakiekolwiek pytania zadaj je w komentarzach, postaram się pomóc.</p>
<p>A.. zapomniałbym, jeśli chcesz być jako pierwszy informowany o nowościach na stronie zapisz się do mojego newslettera :)</p>
<p>Do następnego razu!</p>
<p>[FM_form id="3"]</p>
