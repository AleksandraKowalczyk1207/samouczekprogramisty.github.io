---
layout: post
status: publish
published: true
title: Klasy wewnętrzne i anonimowe w języku Java
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "W artykule tym przeczytasz o klasach wewnętrznych i klasach anonimowych
  w Javie. Dowiesz się jak wyglądają, jakie mają ograniczenia oraz kiedy możemy ich
  używać. Na końcu, jak zwykle, czeka na Ciebie zestaw zadań, w kt&oacute;rych przećwiczysz
  materiał z tego artykułu.\r\n\r\n"
wordpress_id: 465
wordpress_url: http://www.samouczekprogramisty.pl/?p=465
date: '2016-10-13 21:42:15 +0200'
date_gmt: '2016-10-13 19:42:15 +0200'
categories:
- Kurs programowania Java
tags: []
---
<p>W artykule tym przeczytasz o klasach wewnętrznych i klasach anonimowych w Javie. Dowiesz się jak wyglądają, jakie mają ograniczenia oraz kiedy możemy ich używać. Na końcu, jak zwykle, czeka na Ciebie zestaw zadań, w kt&oacute;rych przećwiczysz materiał z tego artykułu.</p>
<p><a id="more"></a><a id="more-465"></a></p>
<p>[idea]To jest jeden z artykuł&oacute;w w ramach <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;kurs-programowania-java&#47;">darmowego kursu programowania w Javie<&#47;a>. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.[&#47;idea]</p>
<p>Na początku pewne zastrzeżenie. W całym artykule posługuję się określeniem &bdquo;klasy wewnętrzne&rdquo;. Ważne jest żebyś zdawał sobie sprawę z tego, że r&oacute;wnie dobrze możemy mieć do czynienia z wewnętrznym typem wyliczeniowym czy wewnętrznym interfejsem. Poznając klasy wewnętrzne, poznajesz także &bdquo;interfejsy wewnętrzne&rdquo; czy &bdquo;wewnętrzne typy wyliczeniowe&rdquo;.</p>
<p>Istnieje kilka typ&oacute;w klas wewnętrznych:</p>
<ul>
<li>(standardowe) klasy wewnętrzne,<&#47;li>
<li>statyczne klasy wewnętrzne,<&#47;li>
<li>lokalne klasy wewnętrzne,<&#47;li>
<li>anonimowe klasy wewnętrzne.<&#47;li><br />
<&#47;ul><br />
Często m&oacute;wimy po prostu o klasie wewnętrznej odwołując się do kt&oacute;rejkolwiek z powyższych. W kolejnych akapitach postaram się pokazać r&oacute;żnice pomiędzy tymi typami klas.</p>
<h1>Klasy wewnętrzne<&#47;h1><br />
Standardowe klasy już znasz. Ot zwykłe <code>public class Example {}<&#47;code> i już mamy klasę. A czym jest klasa wewnętrzna? Zacznijmy od przykładu:</p>
<pre class="lang:default decode:true">public class OuterClass {<br />
    public class InnerClass {<br />
    }   </p>
<p>    public InnerClass intantiate() {<br />
        return new InnerClass();<br />
    }<br />
}<&#47;pre><br />
W naszym przykładzie widzisz dwie klasy. Standardowa klasa <code>OuterClass<&#47;code> i klasa wewnętrzna <code>InnerClass<&#47;code>.</p>
<p>Podobnie jak w przypadku atrybut&oacute;w czy metod, klasy wewnętrzne mogą mieć standardowe modyfikatory dostępu <code>public<&#47;code>, <code>protected<&#47;code> czy <code>private<&#47;code>. Brak modyfikatora dostępu także i tutaj jest poprawny.</p>
<p>Modyfikatory dostępu użyte przed definicją klasy wewnętrznej działają identycznie jak w przypadku atrybut&oacute;w, metod czy konstruktor&oacute;w. Jeśli chcesz przeczytać o nich więcej osobny akapit na ich temat znajdziesz w artykule o dziedziczeniu (http:&#47;&#47;www.samouczekprogramisty.pl&#47;dziedziczenie-w-jezyku-java&#47;).</p>
<p>Ważne jest także to, że klasa wewnętrzna ma dostęp do wszystkich atrybut&oacute;w czy metod klasy zewnętrznej, w kt&oacute;rej została zdefiniowana.</p>
<h2>Tworzenie instancji klasy wewnętrznej<&#47;h2><br />
Do stworzenia instancji klasy wewnętrznej potrzebujemy instancji klasy zewnętrznej. Proszę sp&oacute;jrz na przykład poniżej.</p>
<pre class="lang:default decode:true ">private static void innerClassInstantiation() {<br />
    OuterClass outerClass = new OuterClass();<br />
    OuterClass.InnerClass instance1 = outerClass.intantiate();<br />
    OuterClass.InnerClass instance2 = outerClass.new InnerClass();<br />
}<&#47;pre><br />
Widzisz tam typ <code>OuterClass.InnerClass<&#47;code>, to nic innego jak odwołanie się do typu wewnętrznego. W tym fragmencie kodu tworzymy dwie instancje. Pierwsza z nich powstaje w wyniku wywołania metody <code>instantiate<&#47;code> z klasy <code>OuterClass<&#47;code>. Ciało tej metody możesz zobaczyć w poprzednim fragmencie kodu.</p>
<p>Proszę zwr&oacute;ć uwagę, że wewnątrz metody <code>instantiate<&#47;code> nie musimy podawać pełnej nazwy klasy, samo <code>new InnerClass()<&#47;code> wystarczy (jest to odpowiednik <code>this.new InnerClass()<&#47;code>).</p>
<p><code>instance2<&#47;code> tworzymy posługując się instancją klasy <code>OuterClass<&#47;code>. Taka konstrukcja jest niezbędna w przypadku standardowych klas wewnętrznych.</p>
<h1>Statyczne klasy wewnętrzne<&#47;h1><br />
W języku Java istnieją także statyczne klasy wewnętrzne. Są to klasy wewnętrzne poprzedzone modyfikatorem <code>static<&#47;code>. Proszę sp&oacute;jrz na przykład poniżej.</p>
<pre class="lang:default decode:true ">public class OuterClass2 {<br />
    public static class InnerClass2 {<br />
    }   </p>
<p>    private InnerClass2 instantiate() {<br />
        return new InnerClass2();<br />
    }<br />
}<&#47;pre><br />
Jak widzisz przykład ten jest bardzo podobny do pierwszego z tego artykułu. Nowością tutaj jest modyfikator <code>static<&#47;code>, reszta pozostaje bez zmian.</p>
<p>Ważna jest natomiast r&oacute;żnica przy tworzeniu instancji statycznej klasy wewnętrznej.</p>
<p>Domyślnie, wszystkie wewnętrzne interfejsy i typy wyliczeniowe są statyczne, modyfikator <code>static<&#47;code> jest przed nimi zbędny (możesz spr&oacute;bować go dodać, IDE powinno zwr&oacute;cić Ci na to uwagę).</p>
<h2>Tworzenie instancji statycznej klasy wewnętrznej<&#47;h2><br />
W odr&oacute;żnieniu od standardowych klas wewnętrznych, nie potrzebujemy instancji klasy zewnętrznej do stworzenia instancji statycznej klasy wewnętrznej. Może się to wydać trochę skomplikowane jednak całość na pewno będzie bardziej zrozumiała gdy popatrzysz na przykład.</p>
<pre class="lang:default decode:true ">private static void staticInnerClassInstantiation() {<br />
    OuterClass2 outerClass = new OuterClass2();<br />
    OuterClass2.InnerClass2 instance1 = outerClass.instantiate();<br />
    OuterClass2.InnerClass2 instance2 = new OuterClass2.InnerClass2();<br />
}<&#47;pre><br />
R&oacute;żnica jest taka, że wystarczy nam po prostu pełne odwołanie się do typu klasy wewnętrznej aby stworzyć jej instancję. W naszym przypadku jest to <code>new OuterClass2.InnerClass2()<&#47;code>.</p>
<h1>Lokalne klasy wewnętrzne<&#47;h1><br />
Jako ostatni typ klas wewnętrznych zostały nam lokalne klasy wewnętrzne. I wiesz co? W sumie poza tym, że możemy je zdefiniować wewnątrz bloku (wewnątrz metody, bloku <code>if<&#47;code> itp.) i nie poprzedzają ich modyfikatory dostępu (<code>public<&#47;code>, <code>private<&#47;code>, <code>protected<&#47;code>) niczym szczeg&oacute;lnym nie r&oacute;żnią się od pozostałych klas wewnętrznych. Proszę sp&oacute;jrz na przykład:</p>
<pre class="lang:default decode:true ">private static void localClassInstantiation(String[] args) {<br />
    class LocalClass {<br />
        @Override<br />
        public String toString() {<br />
            return "Argumenty metody: " + Arrays.toString(args);<br />
        }<br />
    }<br />
    LocalClass localClassInstance = new LocalClass();<br />
    System.out.println(localClassInstance);<br />
}<&#47;pre><br />
Tutaj wewnątrz metody tworzymy naszą lokalną klasę wewnętrzną <code>LocalClass<&#47;code>. Linijkę p&oacute;źniej tworzymy jej instancję i wywołujemy na niej metodę.</p>
<p>Gł&oacute;wnym ograniczeniem&#47;zaletą klas lokalnych jest ich zasięg. Podobnie jak w przypadku zmiennych lokalnych, dostęp do klas lokalnych jest wyłącznie w bloku, w kt&oacute;rym zostały zdefiniowane.</p>
<h1>Kiedy używać klas wewnętrznych<&#47;h1><br />
Właśnie, po co w og&oacute;le są nam one potrzebne? Mam nadzieję, że przykład ze standardowej biblioteki Javy pomoże Ci to zrozumieć.</p>
<p>W artykule o <a href="http:&#47;&#47;www.samouczekprogramisty.pl&#47;kolekcje-w-jezyku-java&#47;">kolekcjach<&#47;a> opisałem mapę i spos&oacute;b w jaki możemy po niej iterować.</p>
<pre class="lang:default decode:true ">Map<String, Integer> dayInMonths = new HashMap<>();<br />
dayInMonths.put("styczen", 31);<br />
dayInMonths.put("luty", 28);<br />
dayInMonths.put("marzec", 31);</p>
<p>for(Map.Entry<String, Integer> entry : dayInMonths.entrySet()) {<br />
    System.out.println(entry.getKey() + " ma " + entry.getValue() + " dni.");<br />
}<&#47;pre><br />
W naszej mapie trzymamy nazwę miesiąca i odpowiadającą mu liczbę dni. Każda instancja obiektu implementującego interfejs <code>Map<&#47;code> posiada metodę <code>entrySet<&#47;code>, kt&oacute;ra zwraca typ <code>Set<Map.Entry<K, V>><&#47;code>.</p>
<p>Rozł&oacute;żmy ten typ na części pierwsze. <code>K<&#47;code> to nasz klucz (ang. key), <code>V<&#47;code> to wartość (ang. value) przechowywana w mapie. <code>Map.Entry<K, V><&#47;code> to typ generyczny kt&oacute;ry parametryzowany jest typem klucza i wartości. <code>Set<Map.Entry<K, V>><&#47;code> to zbi&oacute;r element&oacute;w mapy. Każdy element ma klucz i wartość. A czym jest <code>Map.Entry<&#47;code>? To nic innego jak interfejs wewnętrzny :) Jest to interfejs <code>Entry<&#47;code> zdefiniowany wewnątrz interfejsu <code>Map<&#47;code>.</p>
<p>Więc po co używać klas wewnętrznych? Powod&oacute;w jest kilka. Jak w przykładzie z <code>Map.Entry<&#47;code> dobrym pomysłem użycia klas wewnętrznych jest sytuacja, w kt&oacute;rej klasa wewnętrzna nie ma sensu bez klasy zewnętrznej i jest z nią ściśle związana.</p>
<p>Kolejnym powodem może być lepsza enkapsulacja kodu (ukrywanie szczeg&oacute;ł&oacute;w działania klasy wewnątrz). Dzięki temu, że klasy wewnętrzne mają dostęp nawet do prywatnych zasob&oacute;w klas otaczających, te drugie możemy bardziej &bdquo;opakować&rdquo;. Ukryć więcej szczeg&oacute;ł&oacute;w wewnątrz.</p>
<h1>Klasy anonimowe<&#47;h1><br />
Zacznijmy od prostej definicji. Klasy anonimowe to klasy definiowane w kodzie, kt&oacute;re mają dokładnie jedną instancję. Definicja klasy anonimowej połączona jest z tworzeniem jej jedynej instancji. Klasy anonimowe zawsze są klasami wewnętrznymi.</p>
<p>Proszę sp&oacute;jrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">public interface GreetingModule {<br />
    void sayHello();<br />
}</p>
<p>new GreetingModule() {<br />
    @Override<br />
    public void sayHello() {<br />
        System.out.println("good morning");<br />
    }<br />
}<&#47;pre><br />
Na początku definicja interfejsu z jedną metodą sayHello. Ciekawsze są jednak ostatnie cztery linijki. To właśnie definicja klasy anonimowej.</p>
<pre class="lang:default decode:true ">new TYP([ARGUMENTY]) {<br />
    CIAŁO KLASY<br />
}<&#47;pre><br />
Konstrukcja ta pozwala nam na stworzenie instancji klasy anonimowej. W naszym przykładzie tworzymy nową klasę, kt&oacute;ra implementuje interfejs <code>GreetingModule<&#47;code> oraz tworzymy jej nową instancję przy pomocy słowa kluczowego <code>new<&#47;code>.</p>
<p>Wewnątrz definicji klasy anonimowej możemy definiować atrybuty czy metody. W praktyce sprowadza się to przeważnie do zaimplementowania metod interfejsu dla kt&oacute;rego tworzymy klasę anonimową.</p>
<p>W większym fragmencie kodu użycie klas anonimowych może wyglądać następująco.</p>
<pre class="lang:default decode:true ">public class AnonymousClasses {<br />
    public static class Robot {<br />
        private final GreetingModule greetingModule;</p>
<p>        public Robot(GreetingModule greetingModule) {<br />
            this.greetingModule = greetingModule;<br />
        }</p>
<p>        public void saySomething() {<br />
            greetingModule.sayHello();<br />
        }<br />
    }</p>
<p>    public interface GreetingModule {<br />
        void sayHello();<br />
    }</p>
<p>    public static void main(String[] args) {<br />
        Robot jan = new Robot(new GreetingModule() {<br />
            @Override<br />
            public void sayHello() {<br />
                System.out.println("dzien dobry");<br />
            }<br />
        });<br />
        Robot john = new Robot(new GreetingModule() {<br />
            @Override<br />
            public void sayHello() {<br />
                System.out.println("good morning");<br />
            }<br />
        });</p>
<p>        jan.saySomething();<br />
        john.saySomething();<br />
    }<br />
}<&#47;pre><br />
W naszym przykładzie tworzymy dwie instancje robot&oacute;w <code>jan<&#47;code> i <code>john<&#47;code>, kt&oacute;re używają innych &bdquo;moduł&oacute;w powitań&rdquo;. Każdy z nich jest instancją anonimowej klasy wewnętrznej.</p>
<p>Niekt&oacute;re z klas anonimowych można zastąpić wyrażeniami lambda, o kt&oacute;rych przeczytasz w jednym z kolejnych artykuł&oacute;w.</p>
<h1>Używanie zmiennych z klas zewnętrznych<&#47;h1><br />
Wewnątrz definicji klas wewnętrznych (także klas anonimowych) możemy używać zmiennych z otaczającego je kontekstu. Sp&oacute;jrz na przykład poniżej:</p>
<pre class="lang:default decode:true">public void someMethod() {<br />
    final String finalVariable = "final variable";<br />
    String effectivelyFinalVariable = "effectively final variable";<br />
    String nonFinalVariable = "non final variable";</p>
<p>    class InnerClass {<br />
        public void saySomething() {<br />
            System.out.println(finalVariable);<br />
            System.out.println(effectivelyFinalVariable);<br />
        }<br />
    }   </p>
<p>    InnerClass instance = new InnerClass();<br />
    instance.saySomething();            </p>
<p>    nonFinalVariable = "new value";<br />
}<&#47;pre><br />
W metodzie <code>saySomething<&#47;code> używamy dw&oacute;ch zmiennych z klasy otaczającej <code>finalVariable<&#47;code> i <code>effectivelyFinalVariable<&#47;code>. Jest jednak jedno ograniczenie. Zmienna z &bdquo;zewnątrz&rdquo; użyta w klasie wewnętrznej musi być finalna albo &bdquo;właściwie finalna&rdquo;.</p>
<p>Zmienna jest finalna jeśli poprzedza ją słowo kluczowe <code>final<&#47;code>. Kiedy jest &bdquo;właściwie finalna&rdquo;? Kiedy nie zmieniamy jej wartości i kompilator za nas wstawia brakujące słowo final ;).</p>
<p>W związku z tym użycie zmiennej <code>nonFinalVariable<&#47;code> nie jest dozwolone ponieważ jej wartość jest zmieniana.</p>
<h1>Zadania<&#47;h1><br />
Na koniec czekają na Ciebie dwa zadania, w kt&oacute;rych przećwiczysz zagadnienia om&oacute;wione w artykule. Przygotowałem też zestaw przykładowych rozwiązań i umieściłem je na <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;KursJava&#47;tree&#47;master&#47;21_klasy_wewnetrzne&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;kursjava&#47;inner&#47;exercise" target="_blank">githubie<&#47;a>. Jak zwykle zachęcam do samodzielnego rozwiązywania zadań, wtedy nauczysz się najwięcej. Samo przeczytanie artykułu nie wystarczy, do dzieła!</p>
<ol>
<li>Rozszerz przykład z robotami z akapitu o klasach anonimowych o robota witającego się w innym języku np. niemieckim.<&#47;li>
<li>Zadanie to będzie wymagało dodatkowej lektury na temat interfejsu <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Comparator.html" target="_blank"><code>Comparator<&#47;code><&#47;a> ze standardowej biblioteki Javy. Pobierz od użytkownika 5 wyraz&oacute;w, zapisz je w <code>List<String><&#47;code>. Użyj metody <a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;util&#47;Collections.html#sort-java.util.List-java.util.Comparator-" target="_blank"><code>Collections.sort<&#47;code><&#47;a>, przekazując jako argumenty listę oraz klasę anonimową, kt&oacute;ra posortuje ją na podstawie długości wyraz&oacute;w (najkr&oacute;tsze wyrazy powinny być pierwsze). Do sprawdzenia długości słowa możesz użyć metody <a href="http:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;lang&#47;String.html#length--" target="_blank"><code>String.length<&#47;code><&#47;a>. Wyświetl zawartość listy przed i po sortowaniu.<&#47;li><br />
<&#47;ol></p>
<h1>Materiały dodatkowe<&#47;h1><br />
Przygotowałem też dla Ciebie zestaw materiał&oacute;w dodatkowych zawierających informacje na temat klas wewnętrznych i anonimowych. Dodatkowo wszystkie przykłady kodu użyte w tym artykule możesz znaleźć na <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;KursJava&#47;tree&#47;master&#47;21_klasy_wewnetrzne&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;kursjava&#47;inner" target="_blank">samouczkowym githubie<&#47;a>.</p>
<ul>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;tutorial&#47;java&#47;javaOO&#47;nested.html" target="_blank">Tutorial na stronie Oracle dotyczący klas wewnętrznych i anonimowych<&#47;a>,<&#47;li>
<li><a href="http:&#47;&#47;docstore.mik.ua&#47;orelly&#47;java-ent&#47;jnut&#47;ch03_12.htm" target="_blank">Fragment książki opisujący klasy wewnętrzne<&#47;a>,<&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;jls&#47;se8&#47;html&#47;jls-8.html#jls-8.1.3" target="_blank">Rozdział w JLS na temat klas wewnętrznych<&#47;a>,<&#47;li>
<li><a href="https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;jls&#47;se8&#47;html&#47;jls-15.html#jls-15.9.5" target="_blank">Rozdział w JLS na temat klas anonimowych<&#47;a>.<&#47;li><br />
<&#47;ul></p>
<h1>Podsumowanie<&#47;h1><br />
Bardzo się cieszę, że przeczytałeś artykuł do końca. Po lekturze artykułu wiesz czym są klasy wewnętrzne. Wiesz też jakie rodzaje klas wewnętrznych występują. Znasz także klasy anonimowe i wiesz kiedy ich używać. Rozwiązując zadanie przećwiczyłeś całość w praktyce. Innymi słowy kawał solidnej wiedzy :)</p>
<p>Na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze znajomymi i polub moją stronę na facebooku. Zależy mi na dotarciu do jak największej liczby os&oacute;b, kt&oacute;re chcą uczyć się programowania. Z g&oacute;ry dziękuję i do następnego razu.</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https:&#47;&#47;www.flickr.com&#47;photos&#47;alfmelin&#47;</p>
