---
layout: post
status: publish
published: true
title: Wyrażenia regularne w języku Java
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "Artykuł ten poświęcony jest wyrażeniom regularnym. Dowiesz się w nim czym
  są wyrażenia regularne, jak i kiedy ich używać. Poznasz klasy biblioteki standardowej
  pozwalające na pracę z wyrażeniami regularnymi. Przeczytasz praktyczne wskazówki
  kiedy można używać wyrażeń regularnych i jakie są ich wady. Nie obędzie się też
  bez wskazówek do InteliJ Idea. Na końcu przećwiczysz wiedzę z artykułu rozwiązując
  zadania, które wymagały będą wykorzystania wyrażeń regularnych. Zapraszam
  do lektury.\r\n\r\n"
wordpress_id: 562
wordpress_url: http://www.samouczekprogramisty.pl/?p=562
date: '2016-11-28 07:24:36 +0100'
date_gmt: '2016-11-28 06:24:36 +0100'
categories:
- Kurs programowania Java
tags: []
---
<p>Artykuł ten poświęcony jest wyrażeniom regularnym. Dowiesz się w nim czym są wyrażenia regularne, jak i kiedy ich używać. Poznasz klasy biblioteki standardowej pozwalające na pracę z wyrażeniami regularnymi. Przeczytasz praktyczne wskazówki kiedy można używać wyrażeń regularnych i jakie są ich wady. Nie obędzie się też bez wskazówek do InteliJ Idea. Na końcu przećwiczysz wiedzę z artykułu rozwiązując zadania, które wymagały będą wykorzystania wyrażeń regularnych. Zapraszam do lektury.</p>
<p><a id="more"></a><a id="more-562"></a></p>
<h1>Czym są wyrażenia regularne</h1><br />
Słowo wstępu zanim przejdziemy do teorii. W kilku poniższych akapitach pokażę kilka wyrażeń regularnych bez dokładnego ich omawiania. Posłużą one jako przykłady zastosowania wyrażeń. Proszę nie zrażaj się widząc kilka dziwnych znaczków, później dokładnie je opiszę :).</p>
<p>Wyrażenie regularne (ang. <em>regular expression</em>) to &bdquo;wzorzec&rdquo;, który opisuje grupę łańcuchów znaków. Możemy powiedzieć, że łańcuch znaków pasuje do wzorca jeśli dane wyrażenie regularne go opisuje. Na przykład wyrażenie regularne <code>\d{2}-\d{3}</code> opisuje zbiór kodów pocztowych w Polsce. Wyrażenia regularne składają się ze znaków, część z nich w pewnych kontekstach ma specjalne znaczenie. Znaczenie to interpretowane jest przez tak zwany silnik wyrażeń regularnych.</p>
<p>Istnieje wiele silników wyrażeń regularnych, w związku z tym istnieją też pewne różnice pomiędzy wyrażeniami regularnymi rozumianymi przez te silniki. Mówimy wówczas o dialekcie języka wyrażeń regularnych. Dialekty mogą różnić się między sobą pewnymi niuansami, jednak mają wspólną bazę, zrozumiałą dla pozostałych silników wyrażeń regularnych.</p>
<p>Wyrażenia regularne są mechanizmem uniwersalnym, dostępne są w wielu językach programowania. Ucząc się ich raz, poznajesz język wyrażeń regularnych dostępny także w innych językach programowania. Siłą rzeczy skupię się tutaj na dialekcie wyrażeń regularnych w języku Java.</p>
<p>Wyrażenie regularne to tak zwany wzorzec, który następne jest kompilowany przez silnik wyrażeń regularnych do wewnętrznej postaci. Po tym etapie używana jest &bdquo;wewnętrzna reprezentacja&rdquo; wyrażenia regularnego. Jeśli spróbujesz skompilować wzorzec, który nie jest poprawny zostaniesz o tym poinformowany odpowiednim wyjątkiem w trakcie działania programu.</p>
<p>Sam etap kompilacji wyrażenia jest procesem relatywnie długim[1. Mówię to o długim w kontekście innych operacji takich jak dodawanie czy pobranie trzeciej litery z łańcucha znaków.]. Z tego właśnie powodu zaleca się kompilowanie wyrażeń przed ich pierwszym użyciem. Podobnie sprawa ma się jeśli chodzi o tworzenie nowych instancji klasy wzorca. Im ich mniej tym lepiej. Ma to szczególne znaczenie w sytuacji w której używamy wyrażenia wielokrotnie[2. Co prawda w języku Java każda instancja klasy <code>Pattern</code> kompilowana jest dokładnie raz jednak warto zapamiętać tę regułę w przypadku innych języków programowania.].</p>
<p>W wyrażeniach regularnych poza &bdquo;dziwnymi znaczkami&rdquo; używa się także zwyczajnych liter. Domyślnie w wyrażeniach regularnych wielkość liter ma znaczenie. Wyrażenie regularne <code>Kawa</code> to nie to samo co <code>kawa</code>.</p>
<h1>Kiedy używamy wyrażeń regularnych</h1><br />
No właśnie, do czego używamy wyrażeń regularnych? Ogólnie można powiedzieć, że wyrażeń regularnych używamy do pracy z łańcuchami znaków. Wyszukiwanie, dzielenie, czy modyfikacja łańcuchów znaków, to wszystko można zrobić przy pomocy wyrażeń regularnych.</p>
<p>W praktyce jednym z głównych zastosowań jest weryfikacja czy dany łańcuch znaków pasuje do wzorca. Wzorcem tym jest wyrażenie regularne.</p>
<p>To czy łańcuch znaków pasuje do wzorca wykorzystywane jest w trakcie walidacji danych wejściowych. Dzięki wyrażeniom regularnym możemy sprawdzić, czy dane pochodzące od użytkownika mają poprawny format. Na przykład następujące wyrażenie regularne pozwala sprawdzić czy użytkownik podał poprawne imię <code>[A-Z][a-z]+</code>, czy rzeczywiście adres email może być poprawny <code>.+@.+\.pl</code>[3. Oczywiście to wyrażenie regularne można "oszukać". Nawet jeśli łańcuch znaków pasuje do wzorca nie musi być poprawnym adresem email.], czy format daty, który prowadził użytkownik jest w porządku <code>\d{4}-\d{2}-\d{2}</code>.</p>
<p>Ponadto, wyrażeń regularnych możemy używać do &bdquo;parsowania&rdquo; łańcuchów znaków. Jeśli mamy większy łańcuch, z którego chcemy wyciągnąć jakąś część wyrażenia regularne mogą nam w tym pomóc. Na przykład jeśli w telefonie zapisujemy znajomych jako "imię (pseudonim) nazwisko", wyrażenie regularne <code>\w+ \((\w+)\) \w+</code> pomoże nam wyciągnąć pseudonim.</p>
<h1>Wyrażenia regularne w języku Java</h1><br />
W języku Java wyrażenia regularne obsługiwane są przez dwie klasy z biblioteki standardowej. Są to <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank"><code>Pattern</code></a> i <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html" target="_blank"><code>Matcher</code></a>. Spójrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">Pattern compiledPattern = Pattern.compile("Marcin");<br />
Matcher matcher = compiledPattern.matcher("Nazywam sie Marcin Pietraszek");</p>
<p>System.out.println(matcher.find());<br />
System.out.println(matcher.matches());</pre><br />
W przykładzie tym w pierwszej linijce kompiluję wyrażenie regularne <code>Marcin</code> uzyskując instancję klasy <code>Pattern</code>. W kolejnej linijce wywołując metodę <code>matcher</code> otrzymuję instancję klasy <code>Matcher</code>. Parametr przekazany w metodzie <code>matcher</code> to łańcuch znaków, na którym używamy wyrażenia regularnego.</p>
<p>Klasa <code>Matcher</code> posiada, między innymi, następujące metody:</p>
<ul>
<li><code>find()</code> - metoda zwraca <code>true</code> jeśli w łańcuchu znaków znajduje się coś co pasuje do wyrażenia regularnego,</li>
<li><code>matches()</code> - metoda zwraca <code>true</code> jeśli łańcuch znaków pasuje w całości do wyrażenia regularnego.</li><br />
</ul><br />
Proszę spójrz na poniższą tabelkę. W nagłówkach kolumn umieściłem łańcuchy znaków, które dopasowywane są do wyrażeń umieszczonych w pierwszej kolumnie.</p>
<table>
<thead>
<tr>
<th></th></p>
<th>Mam na imię Marcin</th></p>
<th>Marcinkowski</th></p>
<th>Marcin</th><br />
</tr><br />
</thead></p>
<tbody>
<tr>
<th>Marcin</th></p>
<td><code>find - true<br />
matches - false</code></td></p>
<td><code>find - true<br />
matches - false</code></td></p>
<td><code>find - true<br />
matches - true</code></td><br />
</tr></p>
<tr>
<th>Marcinkowski</th></p>
<td><code>find - false<br />
matches - false</code></td></p>
<td><code>find - true<br />
matches - true<br />
</code></td></p>
<td><code>find - false<br />
matches - false</code></td><br />
</tr><br />
</tbody><br />
</table><br />
Jak widzisz wyrażenia regularne mogą wyglądać jak &bdquo;normalne&rdquo; łańcuchy znaków. Jednak takie raczej nie są ciekawe i zbytnio użyteczne. Prawdziwa siła wyrażeń regularnych tkwi w tych wszystkich magicznych znaczkach :). Postaram się je teraz omówić.</p>
<h1>Składnia wyrażeń regularnych</h1><br />
Wszystkie przykłady kodu to poprawne testy jednostkowe (więcej o testach przeczytasz w <a href="http://www.samouczekprogramisty.pl/testy-jednostkowe-z-junit/">osobnym artykule</a>). Zachęcam do ich skopiowania do IDE i samodzielnego kombinowania :).</p>
<p>Jak już widziałeś w poprzednim przykładzie wyrażenia regularne mogą zawierać zwykłe literały znakowe, na przykład <code>kot czy pies</code> to poprawne wyrażenie regularne. Jednak są znaki, które interpretowane są w specjalny sposób. Wyrażenie takie jak <code>1 + 2 = 3</code> zawiera jeden ze znaków specjalnych &ndash; znak <code>+</code>. W związku z tym, jeśli znak <code>+</code> chcemy interpretować dosłownie musimy poprzedzić go znakiem <code>\</code>, wówczas pomijamy jego specjalne znaczenie. W takim przypadku otrzymasz wyrażenie regularne <code>1 \+ 2 = 3</code>.</p>
<h2>Wyrażenia regularne a typ <code>String</code></h2><br />
Jednak to nie koniec &bdquo;kłopotów&rdquo;. W języku Java wyrażenia regularne zapisujemy używając typu <code>String</code>. Znak <code>\</code> jest w literałach znakowych traktowany specjalnie (podobnie jak w samych wyrażeniach regularnych). Na przykład literał znakowy <code>"\t"</code> oznacza znak tabulacji, więc przy zapisie <code>"1 \+ 2 = 3"</code> kompilator Javy doszukiwałby się specjalnego znaczenia dla <code>"\+"</code> (podobnie jak przy <code>"\t"</code>) a nie o to nam tutaj chodzi. Dlatego właśnie w języku Java w wyrażeniach regularnych musimy &bdquo;dublować&rdquo; każdy ukośnik.</p>
<p>Biorąc pod uwagę powyższe wytłumaczenie nasze wyrażenie regularne, w którym chcemy uciec od specjalnego znaczenia <code>+</code> musimy zapisać jako <code>"1 \\+ 2 = 3</code>.</p>
<p>Mi łatwiej jest to zrozumieć jeśli pomyślę o tym co dzieje się pod spodem:</p>
<ul>
<li>pierwszy etap interpretacji literału znakowego (<code>"1 \\+ 2 = 3"</code>) to etap w którym kompilator tworzy reprezentację łańcucha znaków zapisanego w definicji klasy, w trakcie tego etapu ukośniki interpretowane są przez kompilator,</li>
<li>kolejny etap to etap interpretacji łańcucha znaków z definicji klasy (<code>1 \+ 2 = 3</code>) przez silnik wyrażeń regularnych. W tym etapie silnik wyrażeń regularnych interpretuje łańcuch znaków, który zapisał kompilator.</li><br />
</ul><br />
W naszym przykładzie kompilator interpretując literał znakowy <code>"1 \\+ 2 = 3"</code> w pliku class zawierającym skompilowaną klasę zapisze <code>1 \+ 2 = 3</code>. Taka postać zostanie zinterpretowana przez silnik wyrażeń regularnych, który zobaczy, że ma pominąć specjalne znaczenie symbolu <code>+</code>.</p>
<p>Pójdźmy o krok dalej. Ten przykład jest już zakręcony więc trzymaj się mocno ;). Co jeśli chcemy sprawdzić numer mieszkania. Załóżmy, że numer mieszkania to kilka cyfr oddzielonych ukośnikiem od kolejnej grupy cyfr. Przykładowy numer pasujący do tego opisu może wyglądać tak 123\5.</p>
<p>Jak już wiesz <code>+</code> dla silnika wyrażeń regularnych jest jednym z symboli specjalnych więc jego użycie trzeba poprzedzać <code>\</code>. W związku&nbsp; z tym sam symbol <code>\</code> także jest traktowany w specjalny sposób więc i tu jego dosłowne użycie musi być poprzedzone <code>\</code>. Więc w tym przypadku nasze wyrażenie regularne wygląda następująco <code>123\\5</code>.</p>
<p>A jak takie wyrażenie zapisać jako literał znakowy? Tak, trzeba zdublować każdy ukośnik, więc wychodzi nam taki potworek <code>"123\\\\5"</code>.</p>
<p>W dalszej części artykułu jeśli otoczę wyrażenie regularne <code>""</code> wówczas będzie to poprawny literał (instancja <code>String</code>, z powtórzonymi ukośnikami). Jeśli nie będzie tych znaków, będzie to poprawne wyrażenie regularne (bez powtórzonych ukośników).</p>
<h2>Obsługa powtórzeń</h2><br />
W wyrażeniach regularnych istnieje kilka mechanizmów, które pozwalają nam na obsługę powtórzeń, poniżej opiszę wszystkie z nich.</p>
<h3>Znak <code>?</code></h3><br />
Znak <code>?</code> oznacza &ndash; element znajdujący się wcześniej jest opcjonalny. Innymi słowy to co występuje przed <code>?</code> może wystąpić raz lub może zostać pominięte. Na przykład do wyrażenia regularnego <code>kr?at</code> pasują&nbsp; zarówno <code>"krat"</code> jak i <code>"kat"</code> ale nie pasuje <code>"kot"</code> czy <code>"krrat"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testSymbolQuestionMark() {<br />
    Pattern pattern = Pattern.compile("kr?at");<br />
    assertTrue(pattern.matcher("krat").matches());<br />
    assertTrue(pattern.matcher("kat").matches());<br />
    assertFalse(pattern.matcher("krrat").matches());<br />
    assertFalse(pattern.matcher("kot").matches());<br />
}</pre></p>
<h3>Znak <code>*</code></h3><br />
Znak <code>*</code> oznacza &ndash; powtórz dowolną liczbę razy element znajdujący się wcześniej. Dowolna liczba to powtórzenie 0 lub więcej razy. Na przykład wyrażenie regularne <code>uwa*ga</code> jest w stanie dopasować następujące łańcuchy znaków <code>"uwga"</code>, <code>"uwaga"</code>, <code>"uwaaaaaaga"</code> ale nie pasuje do <code>"uwagaaa"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testSymbolAsterix() {<br />
    Pattern pattern = Pattern.compile("uwa*ga");<br />
    assertTrue(pattern.matcher("uwga").matches());<br />
    assertTrue(pattern.matcher("uwaga").matches());<br />
    assertTrue(pattern.matcher("uwaaaaaaga").matches());<br />
    assertFalse(pattern.matcher("uwagaaaa").matches());<br />
}</pre></p>
<h3>Znak <code>+</code></h3><br />
Znak <code>+</code> jest podobny do <code>*</code>. Oznacza on, że występujący po nim element musi być powtórzony 1 lub więcej razy. Na przykład wyrażenie regularne <code>trampo+lina</code> może dopasować następujące łańcuchy znaków: <code>"trampolina"</code>, <code>"trampooolina"</code> ale nie pasuje do <code>"tramplina"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testSymbolPlus() {<br />
    Pattern pattern = Pattern.compile("trampo+lina");<br />
    assertTrue(pattern.matcher("trampolina").matches());<br />
    assertTrue(pattern.matcher("trampoooolina").matches());<br />
    assertFalse(pattern.matcher("tramplina").matches());<br />
}</pre></p>
<h3>Powtórzenia inaczej</h3><br />
Poza znakami <code>?</code>, <code>+</code> i <code>*</code>, które określają dopuszczalną liczbę powtórzeń możesz też użyć <code>{}</code>. Jednak <code>{}</code> ma większe możliwości:</p>
<ul>
<li><code>{x}</code> - oznacza że element poprzedzający musi wystąpić dokładnie x razy,</li>
<li><code>{x,y}</code> - oznacza, że element poprzedzający musi wystąpić od x do y razy,</li>
<li><code>{x,}</code> - oznacza, że element poprzedzający musi wystąpić co najmniej x razy,</li>
<li><code>{,y}</code> - oznacza, że element poprzedzający musi wystąpić co najwyżej y razy.</li><br />
</ul><br />
Zauważ, że symbole <code>?</code>, <code>*</code> i <code>+</code> możemy zastąpić <code>{}</code>. Na przykład wyrażenia regularne <code>al*a</code> i <code>al{0,}a</code> czy <code>al+a</code> i <code>al{1,}a</code> są sobie równoznaczne. Jednak zapis z <code>?</code>, <code>+</code> czy <code>*</code> jest krótszy przez co częściej stosowany.</p>
<h2>Znak <code>.</code></h2><br />
Znak oznacza dowolny symbol (poza znakiem nowej linii). Innymi słowy do wyrażenia regularnego <code>ko.ek</code> pasują zarówno <code>"kotek"</code> jak i <code>"korek"</code> ale nie pasuje <code>"koek"</code> czy <code>"ktek"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testSymbolDot() {<br />
    Pattern pattern = Pattern.compile("ko.ek");<br />
    assertTrue(pattern.matcher("kotek").matches());<br />
    assertTrue(pattern.matcher("korek").matches());<br />
    assertFalse(pattern.matcher("koek").matches());<br />
    assertFalse(pattern.matcher("ktek").matches());<br />
}</pre><br />
Zauważ, że wszystkie dotychczas omówione znaki możemy ze sobą połączyć uzyskując bardziej zaawansowane wyrażenie regularne. Na przykład <code>k+a.*ta</code>. Rozłóżmy to wyrażenie regularne na czynniki pierwsze:</p>
<ul>
<li><code>k+</code> - oznacza literę k powtórzoną co najmniej raz,</li>
<li><code>a</code> - litera a,</li>
<li><code>.*</code> - oznacza dowolny znak (poza znakiem nowej linii) powtórzony 0 lub więcej razy,</li>
<li><code>ta</code> - litery ta.</li><br />
</ul><br />
Do takiego wyrażenia regularnego pasują następujące łańcuchy znaków <code>"kata"</code>, <code>"katapulta"</code>, <code>"karta"</code>, <code>"kasia ma kota"</code> czy <code>"kkkka#$*&amp;JHDFStatata</code> ale nie pasuje <code>"ata"</code> czy <code>"kta"</code>.</p>
<pre class="lang:default decode:true">@Test<br />
public void testSymbolDotWithOthers() {<br />
    Pattern pattern = Pattern.compile("k+a.*ta");<br />
    assertTrue(pattern.matcher("katapulta").matches());<br />
    assertTrue(pattern.matcher("karta").matches());<br />
    assertTrue(pattern.matcher("kasia ma kota").matches());<br />
    assertTrue(pattern.matcher("kkkka#$*&amp;JHDFSta").matches());<br />
    assertFalse(pattern.matcher("ata").matches());<br />
    assertFalse(pattern.matcher("kta").matches());<br />
}</pre><br />
[idea]Teraz już wiesz jak można odczytać wyrażenie regularne użyte na początku artykułu do którego mogą pasować poprawne adresy email <code>.+@.+\.pl.</code> Rozkładając je na czynniki pierwsze mamy:</p>
<ul>
<li><code>.+</code> - dowolny symbol użyty co najmniej raz,</li>
<li><code>@</code> - małpka,</li>
<li><code>.+</code> - ponownie dowolny symbol użyty co najmniej raz,</li>
<li><code>\.</code> - kropka rozumiana dosłownie (nie jako specjalny znak wyrażenia regularnego),</li>
<li><code>pl</code> - następujące po sobie litery p i l.[/idea]</li><br />
</ul></p>
<h2>Klasy</h2><br />
W wyrażeniach regularnych też istnieją klasy, jednak nie są to klasy jak w języku Java :). W kontekście wyrażeń regularnych klasy oznaczają grupy symboli, klasy oznaczamy przy pomocy nawiasów <code>[</code> i <code>]</code>. Na przykład wyrażenie regularne <code>[rtmp]aca</code> opisuje łańcuchy znaków <code>"raca"</code>, <code>"taca"</code>,&nbsp;<code>"maca"</code> czy <code>"paca"</code> ale już nie <code>"praca"</code> czy <code>"pacanów"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testSimpleClasses() {<br />
    Pattern pattern = Pattern.compile("[rtmp]aca");<br />
    assertTrue(pattern.matcher("raca").matches());<br />
    assertTrue(pattern.matcher("taca").matches());<br />
    assertTrue(pattern.matcher("maca").matches());<br />
    assertTrue(pattern.matcher("paca").matches());<br />
    assertFalse(pattern.matcher("praca").matches());<br />
    assertFalse(pattern.matcher("pacanow").matches());<br />
}</pre></p>
<h3>Zakresy znaków</h3><br />
Aby ułatwić zapisywanie grup znaków klasy pozwalają na definiowanie zakresów. Można to zrobić przy pomocy <code>-</code>. Na przykład do wyrażenia regularnego <code>[a-d]uma</code> pasują łańcuchy znaków <code>"auma"</code>, <code>"buma"</code>, <code>"cuma"</code> czy <code>"duma"</code> ale nie pasuje <code>"fuma"</code> czy <code>"abuma"</code>. W podobnym sposób możemy podawać zakresy cyfr. Do wyrażenia regularnego <code>[0-7]xyz</code>&nbsp; pasują łańcucy znaków <code>"0xyz"</code>, <code>"1xyz"</code> czy <code>"7xyz"</code> ale nie pasuje <code>"8xyz"</code> czy <code>"07xyz"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testClassWithRangeNumber() {<br />
    Pattern pattern = Pattern.compile("[0-7]xyz");<br />
    assertTrue(pattern.matcher("0xyz").matches());<br />
    assertTrue(pattern.matcher("1xyz").matches());<br />
    assertTrue(pattern.matcher("7xyz").matches());<br />
    assertFalse(pattern.matcher("8xyz").matches());<br />
    assertFalse(pattern.matcher("07xyz").matches());<br />
}</pre><br />
Jak widzisz znak <code>-</code> wewnątrz klasy ma specjalne znaczenie, jeśli chcesz aby był interpretowany dosłownie umieść go jako ostatni w klasie <code>[abc-]</code>.</p>
<p>Zakresy w klasie znaków można ze sobą łączyć. Na przykład do wyrażenia regularnego <code>[a-cA-C0-3]bum</code> pasują łańcucy znaków <code>"abum"</code>, <code>"Bbum"</code> czy <code>"0bum"</code> ale nie pasują już <code>"dbum"</code> czy <code>"aA0bum"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testClassWithMultipleRanges() {<br />
    Pattern pattern = Pattern.compile("[a-cA-C0-3]bum");<br />
    assertTrue(pattern.matcher("abum").matches());<br />
    assertTrue(pattern.matcher("Bbum").matches());<br />
    assertTrue(pattern.matcher("0bum").matches());<br />
    assertFalse(pattern.matcher("dbum").matches());<br />
    assertFalse(pattern.matcher("aA0bum").matches());<br />
}</pre></p>
<h3>Negacja klasy</h3><br />
A co jeśli chcę dopasować wszystkie znaki prócz x, y i z? Klasy też na to pozwalają. Służy do tego znak <code>^</code> umieszczony jako pierwszy w klasie. Na przykład do wyrażenia regularnego <code>[^xyz]awa</code> pasują słowa <code>"kawa"</code>, <code>"pawa"</code> czy <code>"Wawa"</code> ale nie pasują <code>"zawa"</code> czy <code>"yawa"</code>.</p>
<pre class="lang:default decode:true ">@Test<br />
public void testClassNegation() {<br />
    Pattern pattern = Pattern.compile("[^xyz]awa");<br />
    assertTrue(pattern.matcher("kawa").matches());<br />
    assertTrue(pattern.matcher("pawa").matches());<br />
    assertTrue(pattern.matcher("Wawa").matches());<br />
    assertFalse(pattern.matcher("zawa").matches());<br />
    assertFalse(pattern.matcher("yawa").matches());<br />
}</pre><br />
Jeśli chcesz aby <code>^</code> był rozumiany dosłownie wewnątrz klasy nie umieszczaj go na pierwszy miejscu.</p>
<p>[idea]Teraz już wiesz jak można odczytać wyrażenie regularne użyte na początku artykułu do którego pasują imiona: <code>[A-Z][a-z]+</code>. Rozłóżmy je na czynniki pierwszej</p>
<ul>
<li><code>[A-Z]</code> - znak z tej klasy znaków, wielka litera,</li>
<li><code>[a-z]+</code> - mała litera użyta co najmniej raz.[/idea]</li><br />
</ul></p>
<h2>Predefiniowane klasy znaków</h2><br />
Klasy poznałeś w poprzednich akapitach. Tak się składa, że mechanizm ten jest dość często wykorzystywany w wyrażeniach regularnych. Co więcej, bardzo często zdarzają się klasy, które są częściej używane od innych. Na przykład wszystkie cyfry, czy wszystkie znaki użyte w słowach.</p>
<p>Takie często używane klasy zostały wbudowane w wyrażenia regularne pod postacią predefiniowanych klas. Wszystkie predefiniowane klasy prezentuje lista poniżej:</p>
<ul>
<li><code>\d</code> - jakakolwiek cyfra <code>[0-9]</code>,</li>
<li><code>\D</code> - jakikolwiek znak, który nie jest cyfrą <code>[^0-9]</code>,</li>
<li><code>\w</code> - znak używany w słowach <code>[a-zA-Z0-9_]</code> (zauważ, że mamy tu znak <code>_</code>),</li>
<li><code>\w</code> - jakikolwiek znak, który nie jest używany w słowach <code>[^a-zA-Z0-9_]</code>,</li>
<li><code>\s</code> - tak zwane białe znaki czyli znak spacji czy tabulacji <code>[ \t\n\r\f\x0B]</code>. Możesz je opisać jako znaki, które nie są widoczne podczas wydruku,</li>
<li><code>\S</code> - negacja grupy <code>\s</code> czyli <code>[^ \t\n\r\f\x0B]</code>.</li><br />
</ul><br />
Dla przykładu do wyrażenia regularnego <code>\d\w\d</code> pasują łąńcuchy znaków <code>"0_0"</code> czy <code>"0X1"</code> ale nie pasują <code>"a0b"</code> czy <code>"0 0"</code>.</p>
<pre class="lang:default decode:true">@Test<br />
public void testPredefinedClases() {<br />
    Pattern pattern = Pattern.compile("\\d\\w\\d");<br />
    assertTrue(pattern.matcher("0_0").matches());<br />
    assertTrue(pattern.matcher("0X1").matches());<br />
    assertFalse(pattern.matcher("a0b").matches());<br />
    assertFalse(pattern.matcher("0 0").matches());<br />
}</pre><br />
[alert style="warning"]Pamiętasz o ukośniku? Wyrażenie regularne <code>\d</code> zapisane jako <code>String</code> w języku Java potrzebuje dodatkowego ukośnika, powstaje nam zatem <code>"\\d"</code>.[/alert]</p>
<p>[idea]Teraz już wiesz, jak można odczytać wyrażenie regularne użyte na początku artykułu, do którego pasują daty: \d{4}-\d{2}-\d{2}</p>
<ul>
<li><code>\d{4}</code> - cztery cyfry oznaczające rok,</li>
<li><code>-</code> - minus oddzielający rok od miesiąca,</li>
<li><code>\d{2}</code> - dwie cyfry oznaczające miesiąc,</li>
<li><code>-</code> - minus oddzielający miesiąc od dnia,</li>
<li><code>\d{2}</code> - dwie cyfry oznaczające dzień.</li><br />
</ul><br />
Dasz też sobie radę z <code>\d{2}-\d{3}</code> opisującym kody pocztowe.[/idea]</p>
<h2>Grupy</h2><br />
Do tej pory poznałeś mechanizmy wyrażeń regularnych które pozwalają na sprawdzenie czy dany łańcuch pasuje do danego wyrażenia regularnego. Teraz przejdziemy do mechanizmu grup, który pozwala na wyłuskanie z łańcucha znaków pewnego fragmentu wewnątrz.</p>
<p>Weźmy za przykład zdanie <code>"Ala ma kota. Kot ma na imię --Zygmunt--. Kot jest czarny."</code>. Załóżmy, że chcielibyśmy wyciągnąć z tego zdania imię kota. Dla uproszczenia umieściłem je pomiędzy dwoma minusami. Następujące wyrażenie regularne może nam w tym pomóc: <code>[^-]*--(\w+)--.*</code>. Rozłóżmy je na czynniki pierwsze:</p>
<ul>
<li><code>[^-]*</code> - Jakikolwiek znak tylko nie minus powtórzony dowolną ilość razy,</li>
<li><code>--</code> - dwa minusy,</li>
<li><code>(</code> - rozpoczęcie grupy,</li>
<li><code>\w+</code> - znak użyty w słowach występujący co najmniej raz,</li>
<li><code>)</code> - zamknięcie grupy,</li>
<li><code>--</code> - dwa minusy,</li>
<li><code>.*</code> - dowolny znak występujący co najmniej raz.</li><br />
</ul><br />
W naszym przykładzie imię Zygmunt znajdujące się pomiędzy podwójnymi minusami zostanie przypisane do grupy. Grupowanie oznaczamy nawiasami <code>()</code>. W wyrażeniu regularnym może być kilka grup, numerowane są one zawsze od jedynki.</p>
<p>Jeśli dany łańcuch znaków pasuje do wyrażenia regularnego wówczas domyślnie ląduje on w grupie z numerem 0.</p>
<p>Obiekt klasy <code>Matcher</code> posiada zestaw metod, które operują na grupach. Skupimy się na dwóch z nich:</p>
<ul>
<li><code>groupCount()</code> - zwraca liczbę grup w wyrażeniu regularnym (pomijając tę domyślną z indeksem 0),</li>
<li><code>group(int groupNumber)</code> - zwraca grupę pod konkretnym numerem.</li><br />
</ul></p>
<pre class="lang:default decode:true ">@Test<br />
public void testBasicGroups() {<br />
    Pattern pattern = Pattern.compile("[^-]*--(\\w+)--.*");<br />
    Matcher matcher = pattern.matcher("Ala ma kota. Kota ma na imie --Zygmunt--. Kot jest czarny.");<br />
    matcher.matches();<br />
    assertEquals("Zygmunt", matcher.group(1));<br />
}</pre><br />
W przykładzie powyżej widzisz, kod który używa grupowania do pobrania imienia kota ze zdania.</p>
<p>[idea]Teraz już wiesz, jak można odczytać wyrażenie regularne użyte na początku artykułu, do odczytywania pseudonimu z książki adresowej <code>\w+ \((\w+)\) \w+</code>. Rozkładając wyrażenie na czynniki pierwsze otrzymujemy:</p>
<ul>
<li><code>\w+</code> - cyfry, litery lub podkreślnik użyte co najmniej raz,</li>
<li><code>\(</code> - znak nawiasów użyty dosłownie,</li>
<li><code>(\w+)</code> - ponownie cyfry, litery lub podkreślnik użyte co najmniej raz ale tym razem złapane w grupę,</li>
<li><code>\)</code> - znak nawiasów użyty dosłownie,</li>
<li><code>\w+</code> - po raz kolejny fragment pasujący tym razem do nazwiska.[/idea]</li><br />
</ul><br />
Operatory powtórzeń można stosować do grup zatem wyrażenie regularne <code>(\w+ ){3}</code> pasuje do trzech słów, które mogą być oddzielone spacją.</p>
<h1>IDE pomaga</h1><br />
InteliJ Idea ma dość przydatną funkcję, która pomaga przy pracy z wyrażeniami regularnymi. Naciskając <code><Alt + Enter></code> na wyrażeniu regularnym i klikając na &bdquo;Check RegExp&rdquo; pokaże się okienko, w którym na żywo możesz sprawdzić działanie wyrażenia regularnego.</p>
<p><img class="aligncenter size-full wp-image-567" src="http://www.samouczekprogramisty.pl/wp-content/uploads/2016/11/check_regexp_menu.jpg" alt="Check RegExp menu" width="502" height="240" /></p>
<p><img class="aligncenter size-full wp-image-566" src="http://www.samouczekprogramisty.pl/wp-content/uploads/2016/11/check_regexp_dialog.jpg" alt="check_regexp_dialog" width="502" height="240" /></p>
<h1>Wady wyrażeń regularnych i praktyczne wskazówki</h1><br />
Wyrażenia regularne to bardzo wszechstronne i skomplikowane narzędzie. Narzędzie, które ma dużo możliwości. Jednak niestety ma też swoje wady.</p>
<p>Używanie wyrażeń regularnych gdzie zwykła manipulacja łańcuchami znaków jest możliwa nie zawsze jest dobrym rozwiązaniem. Jeśli można to zrobić prostymi metodami używaj ich zamiast wyrażeń regularnych.</p>
<p>Wyrażenia regularne są wolne. Kompilacja wyrażenia i później ciężka praca silnika wyrażeń regularnych zajmuje więcej czasu niż zwykłe pobranie części łańcucha znaków na przykład od trzeciego do dziesiątego znaku włącznie.</p>
<p>Skomplikowane wyrażenie regularne są ciężkie w utrzymaniu i zrozumieniu. Nadziubać potworka każdy może, gorzej jest później ze zrozumieniem takiego fragmentu miesiąc czy trzy miesiące później. Jeśli to możliwe, lepiej upraszczać je maksymalnie jak się da.</p>
<p>Wyrażenia regularne nie zawsze są w stanie sprawdzić wszystko. Bo jak na przykład napisać wyrażenie regularne, które ze stuprocentową pewnością powie, że data jest poprawna? Podejmujesz się napisania takiego wyrażenia? :) Czy na przykład data 2015-02-29 jest poprawna? Na pierwszy rzut oka wszystko jest z nią w porządku prawda? Napisać wyrażenie regularne, które &bdquo;udowodni&rdquo;, że jest ona błędna jest nie lada sztuką, ja bym się chyba takiego zadania nie podjął ;).</p>
<p>Jeśli w Twoim wyrażeniu regularnym jest dużo <code>*</code> zastanów się jeszcze raz czy aby na pewno <code>+</code> nie będzie w tym przypadku wystarczający. Rzadko kiedy zależy nam na &bdquo;zerowej liczbie znaków&rdquo;.</p>
<h1>Zadanie do wykonania</h1><br />
Twoim dzisiejszym zadaniem będzie napisanie kilku wyrażeń regularnych, które będą potrafiły walidować przykładowe dane pochodzące od użytkownika. Napisz wyrażenie regulane, które:</p>
<ul>
<li>Sprawdza czy liczba zmiennoprzecinkowa podana przez użytkownika ma poprawny format. Na przykład liczba 123,2341515132135 czy -10 są poprawne ale 18-12 czy 123, już nie,</li>
<li>sprawdza czy numer domu jest w formacie numer\numer. Poprawnym numerem jest 123\2A, 24B\3 czy 12\5, ale już numer abc\cba nie,</li>
<li>sprawdza czy użytkownik wprowadził poprawną nazwę miasta. Na przykład Wroclaw, Zielona Gora czy Bielsko-Biala jest ok, jednak Ptysiow123 już nie. Dla uproszczenia załóżmy, że żadna nazwa miejscowości nie zwiera polskich znaków.</li><br />
</ul><br />
Rozwiązania jak zwykle są na <a href="https://github.com/SamouczekProgramisty/KursJava/blob/master/23_wyrazenia_regularne/src/test/java/pl/samouczekprogramisty/kursjava/regexp/exercise/ExerciseTest.java" target="_blank">githubie</a> jednak zachęcam do samodzielnej pracy. Próbując rozwiązać zadania samodzielnie nauczysz się najwięcej.</p>
<h1>Dodatkowe materiały do nauki</h1><br />
Poniżej przygotowałem dla Ciebie kilka dodatkowych linków, które zawierają materiały związane z wyrażeniami regularnymi.</p>
<ul>
<li><a href="http://rubular.com/" target="_blank">Rubular</a> - narzędzie pozwalające na sprawdzenie wyrażenia regularnego. Co prawda dotyczy wyrażeń regularnych dla języka Ruby jednak w przypadku Javy też znajduje zastosowanie,</li>
<li><a href="http://regexr.com" target="_blank">Regexr</a> - kolejne narzędzie pomagające w testowaniu wyrażeń regularnych.</li>
<li><a href="http://www.regular-expressions.info" target="_blank">http://www.regular-expressions.info</a> - bezsprzecznie najlepszy materiał w sieci jaki znalazłem na temat wyrażeń regularnych. Zawiera szczegółowy opis zarówno tych podstawowych jak i zaawansowanych technik. Sam bardzo często korzystam z tego źródła,</li>
<li>artykuł na temat wyrażeń regularnych na <a href="https://pl.wikipedia.org/wiki/Wyra%C5%BCenie_regularne" target="_blank">wikipedii</a>,</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank">dokumentacja</a> dla klasy Pattern,</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html" target="_blank">dokumentacja</a> dla klasy Matcher,</li>
<li><a href="http://docs.oracle.com/javase/tutorial/essential/regex/index.html" target="_blank">tutorial</a> dotyczący wyrażeń regularnych na stronie Oracle,</li>
<li><a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/23_wyrazenia_regularne" target="_blank">kod źródłowy</a> przykładów użytych w artykule.</li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Mimo, że artykuł zawiera dość sporą ilość informacji na temat wyrażeń regularnych nie mówi o wszystkich możliwościach. Pominąłem tu celowo na przykład kwestie tak zwanego backtrackingu, zachłanności, alternatyw, nazwanych grup, ponownego użycia grup w wyrażeniu, flag, kotwic itd. Jeśli jesteś zainteresowany dodatkowym materiałem daj znać, nadziubię kolejny artykuł ;).</p>
<p>Tymczasem dzięki za lekturę i na koniec mam do Ciebie prośbę. Proszę podziel się linkiem do artykułu ze swoimi znajomymi, zależy mi na dotarciu do jak największej grupy czytelników i możesz mi w tym pomóc.</p>
<p>Jeśli nie chcesz pominąć żadnego kolejnego artykułu zapisz się do newslettera i polub moją stronę na facebooku. Do następnego razu!</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/thomashawk/3191454610/sizes/l.</p>
