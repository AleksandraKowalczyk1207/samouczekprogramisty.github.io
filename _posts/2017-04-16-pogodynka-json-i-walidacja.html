---
layout: post
status: publish
published: true
title: Pogodynka - JSON i walidacja
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "Kolejny raport z frontu Pogodynki. Tym razem krótko, w kilku żołnierskich
  słowach opiszę o postępy w Pogodynce.\r\n\r\n"
wordpress_id: 856
wordpress_url: http://www.samouczekprogramisty.pl/?p=856
date: '2017-04-16 21:07:18 +0200'
date_gmt: '2017-04-16 19:07:18 +0200'
categories:
- DSP2017
- Projekty
- Pogodynka
tags: []
comments: []
---
<p>Kolejny raport z frontu Pogodynki. Tym razem krótko, w kilku żołnierskich słowach opiszę o postępy w Pogodynce.</p>
<p><a id="more"></a><a id="more-856"></a></p>
<h1>Zabawa z JSONem<&#47;h1><br />
Nie mogę powiedzieć, że zrobiłem to &ldquo;w tym tygodniu&rdquo;. Nad pogodynką pracowałem wyłącznie dzisiaj :). Pierwszym problemem, który musiałem rozwiązać była serializacja i deserializacja obiektów klasy <a href="http:&#47;&#47;joda-time.sourceforge.net&#47;apidocs&#47;org&#47;joda&#47;time&#47;DateTime.html" target="_blank">DateTime<&#47;a> z biblioteki <a href="http:&#47;&#47;www.joda.org&#47;joda-time&#47;" target="_blank">Joda<&#47;a>.</p>
<p>Okazuje się, że biblioteka <a href="https:&#47;&#47;github.com&#47;google&#47;gson" target="_blank">Gson<&#47;a>, którą wybrałem domyślnie robi to w &ldquo;dziwaczny sposób&rdquo;. Jako proste i przejrzyste rozwiązanie zaimplementowałem sw&oacute;j własny konwerter DateTime -> String -> DateTime. Data przekazywana jest jako łańcuch znak&oacute;w zapisany w formacie <a href="https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;ISO_8601" target="_blank">ISO8601<&#47;a>.</p>
<p>Na tym etapie funkcjonalność testowałem wyłącznie z linii poleceń używając programu curl. Przykładowe zapytanie, które wysyła pomiar temperatury do komponentu Data Vault może wyglądać następująco:</p>
<pre class="lang:default highlight:0 decode:true ">$ curl -H 'Content-Type: application&#47;json' http:&#47;&#47;localhost:8080&#47;datavault&#47;temperatures -d '{"temperature": 123, "whenMeasured": "2017-04-16T17:06:36.652+02:00"}' -v<br />
* Trying 127.0.0.1...<br />
* Connected to localhost (127.0.0.1) port 8080 (#0)<br />
> POST &#47;datavault&#47;temperatures HTTP&#47;1.1<br />
> Host: localhost:8080<br />
> User-Agent: curl&#47;7.47.0<br />
> Accept: *&#47;*<br />
> Content-Type: application&#47;json<br />
> Content-Length: 69<br />
><br />
* upload completely sent off: 69 out of 69 bytes<br />
< HTTP&#47;1.1 201 Created<br />
< Date: Sun, 16 Apr 2017 18:32:07 GMT<br />
< Content-Type: application&#47;json;charset=UTF-8<br />
< Content-Length: 30<br />
< Server: Jetty(9.2.15.v20160210)<br />
<<br />
* Connection #0 to host localhost left intact<br />
{"result":"Temperature added"}<&#47;pre><br />
W wyniku widzimy &ldquo;piękną&rdquo; odpowiedź w formacie JSON. Oczywiście sama temperatura jeszcze się nigdzie nie zapisuje - nie podłączyłem do tego bazy danych. Zajmę się tym w najbliższym tygodniu.</p>
<p>Cała konwersja możliwa jest dzięki klasie <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;Pogodynka&#47;blob&#47;master&#47;datavault&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;pogodynka&#47;datavault&#47;configuration&#47;conversion&#47;CustomDateTimeAdapter.java" target="_blank">CustomDateTimeAdapter<&#47;a>. Następnie do automatycznego mechanizmu konwersji Springa <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;Pogodynka&#47;blob&#47;master&#47;datavault&#47;src&#47;main&#47;java&#47;pl&#47;samouczekprogramisty&#47;pogodynka&#47;datavault&#47;configuration&#47;WebAppConfiguration.java#L27" target="_blank">dodaję<&#47;a> to właśnie rozszerzenie. Dzięki takiej konfiguracji obiekty zawierające instancję DateTime poprawnie tworzone są na podstawie zapytań zawierających dane w formacie JSON.</p>
<h1>Walidacja danych wejściowych<&#47;h1><br />
Nie można ufać użytkownikom. Nawet jeśli jedynym użytkownikiem w trym przypadku jest aplikacja, którą ja napisałem. Zakrawa to trochę o schizofrenię, ale takie są &ldquo;dobre praktyki&rdquo; pisania aplikacji. Dane wejściowe trzeba walidować, koniec i kropka.</p>
<p>Specyfikacja <a href="https:&#47;&#47;jcp.org&#47;en&#47;jsr&#47;detail?id=303" target="_blank">Bean Validation 1.0<&#47;a> doczekała się swojego następcy <a href="https:&#47;&#47;jcp.org&#47;en&#47;jsr&#47;detail?id=349" target="_blank">Bean Validation 1.1<&#47;a> i <a href="https:&#47;&#47;jcp.org&#47;en&#47;jsr&#47;detail?id=380" target="_blank">Bean Validation 2.0<&#47;a>. Na dzień dzisiejszy wersja 1.1 jest &ldquo;obowiązującą&rdquo;. Jako implementację walidatora wybrałem <a href="http:&#47;&#47;hibernate.org&#47;validator&#47;" target="_blank">Hibernate<&#47;a>.</p>
<p>Proste dołączenie biblioteki w pliku <a href="https:&#47;&#47;github.com&#47;SamouczekProgramisty&#47;Pogodynka&#47;blob&#47;master&#47;datavault&#47;datavault.gradle" target="_blank">datavault.gradle<&#47;a> wraz z użyciem adnotacji <a href="http:&#47;&#47;docs.oracle.com&#47;javaee&#47;7&#47;api&#47;javax&#47;validation&#47;constraints&#47;NotNull.html" target="_blank">@NotNull<&#47;a> i <a href="http:&#47;&#47;docs.oracle.com&#47;javaee&#47;7&#47;api&#47;javax&#47;validation&#47;Valid.html" target="_blank">@Valid<&#47;a> pokazuje siłę Springa:</p>
<pre class="lang:default highlight:0 decode:true">curl -H 'Content-Type: application&#47;json' http:&#47;&#47;localhost:8080&#47;datavault&#47;temperatures -d '{"temperature": 123}' -v<br />
* Trying 127.0.0.1...<br />
* Connected to localhost (127.0.0.1) port 8080 (#0)<br />
> POST &#47;datavault&#47;temperatures HTTP&#47;1.1<br />
> Host: localhost:8080<br />
> User-Agent: curl&#47;7.47.0<br />
> Accept: *&#47;*<br />
> Content-Type: application&#47;json<br />
> Content-Length: 20<br />
><br />
* upload completely sent off: 20 out of 20 bytes<br />
< HTTP&#47;1.1 400 Bad Request<br />
< Date: Sun, 16 Apr 2017 18:46:30 GMT<br />
< Content-Type: application&#47;json;charset=UTF-8<br />
< Content-Length: 52<br />
< Server: Jetty(9.2.15.v20160210)<br />
<<br />
* Connection #0 to host localhost left intact<br />
{"errors":["Field whenMeasured must not be empty!"]}<&#47;pre></p>
<h1>Kontroler - serce aplikacji<&#47;h1><br />
Ta aplikacja to w praktyce jeden kontroller. Dodatkowo aplikacja zawiera drobną konfigurację rozszerzającą domyślne ustawienia.</p>
<pre class="lang:default decode:true">@Controller<br />
@RequestMapping("&#47;temperatures")<br />
public class TemperatureController {</p>
<p>    private static final Logger LOG = LoggerFactory.getLogger(TemperatureController.class);</p>
<p>    private final TemperatureService temperatureService;</p>
<p>    private final MessageSource messageSource;</p>
<p>    @Autowired<br />
    public TemperatureController(TemperatureService temperatureService, MessageSource messageSource) {<br />
        this.messageSource = messageSource;<br />
        this.temperatureService = temperatureService;<br />
    }</p>
<p>    @PostMapping(consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br />
    @ResponseBody<br />
    public ResponseEntity addTemperature(@Valid @RequestBody TemperatureMeasurement temperature, Errors errors) {<br />
        if (errors.hasErrors()) {<br />
            List<String> errorMessages = errors.getAllErrors().stream()<br />
                .map(e -> messageSource.getMessage(e.getCode(), e.getArguments(), null))<br />
                .collect(Collectors.toList());<br />
            return new ResponseEntity<>(Collections.singletonMap("errors", errorMessages), HttpStatus.BAD_REQUEST);<br />
        }</p>
<p>        temperatureService.addTemperature(temperature);</p>
<p>        return new ResponseEntity<>(Collections.singletonMap("result", "Temperature added"), HttpStatus.CREATED);<br />
    }</p>
<p>    @GetMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br />
    @ResponseBody<br />
    public Map<String, List<TemperatureMeasurement>> listTemperatures() {<br />
        LOG.debug("Listing all temperatures");<br />
        List<TemperatureMeasurement> temperatures = temperatureService.getTemperatures();<br />
        Map<String, List<TemperatureMeasurement>> responseMap = new HashMap<>();<br />
        responseMap.put("temperatures", temperatures);<br />
        return responseMap;<br />
    }<br />
}<&#47;pre></p>
<h1>Podsumowanie<&#47;h1><br />
Czasu już dużo nie zostało. Teraz zamierzam pracować nad pogodynką także w tygodniu, nie tylko w weekendy jak do tej pory. Trzymajcie za mnie kciuki ;)</p>
<p>Zdjęcie dzięki uprzejmości https:&#47;&#47;www.flickr.com&#47;photos&#47;littlekoshka&#47;4647737233&#47;sizes&#47;l</p>
