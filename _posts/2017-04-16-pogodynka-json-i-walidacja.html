---
layout: default
title: Pogodynka - JSON i walidacja
excerpt: "Kolejny raport z frontu Pogodynki. Tym razem krótko, w kilku żołnierskich
  słowach opiszę o postępy w Pogodynce.\r\n\r\n"
date: '2017-04-16 21:07:18 +0200'
categories:
- DSP2017
- Projekty
- Pogodynka
---
<p>Kolejny raport z frontu Pogodynki. Tym razem krótko, w kilku żołnierskich słowach opiszę o postępy w Pogodynce.</p>
<p><a id="more"></a><a id="more-856"></a></p>
<h1>Zabawa z JSONem</h1><br />
Nie mogę powiedzieć, że zrobiłem to &ldquo;w tym tygodniu&rdquo;. Nad pogodynką pracowałem wyłącznie dzisiaj :). Pierwszym problemem, który musiałem rozwiązać była serializacja i deserializacja obiektów klasy <a href="http://joda-time.sourceforge.net/apidocs/org/joda/time/DateTime.html" target="_blank">DateTime</a> z biblioteki <a href="http://www.joda.org/joda-time/" target="_blank">Joda</a>.</p>
<p>Okazuje się, że biblioteka <a href="https://github.com/google/gson" target="_blank">Gson</a>, którą wybrałem domyślnie robi to w &ldquo;dziwaczny sposób&rdquo;. Jako proste i przejrzyste rozwiązanie zaimplementowałem swój własny konwerter DateTime -> String -> DateTime. Data przekazywana jest jako łańcuch znaków zapisany w formacie <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO8601</a>.</p>
<p>Na tym etapie funkcjonalność testowałem wyłącznie z linii poleceń używając programu curl. Przykładowe zapytanie, które wysyła pomiar temperatury do komponentu Data Vault może wyglądać następująco:</p>
<pre class="lang:default highlight:0 decode:true ">$ curl -H 'Content-Type: application/json' http://localhost:8080/datavault/temperatures -d '{"temperature": 123, "whenMeasured": "2017-04-16T17:06:36.652+02:00"}' -v<br />
* Trying 127.0.0.1...<br />
* Connected to localhost (127.0.0.1) port 8080 (#0)<br />
> POST /datavault/temperatures HTTP/1.1<br />
> Host: localhost:8080<br />
> User-Agent: curl/7.47.0<br />
> Accept: */*<br />
> Content-Type: application/json<br />
> Content-Length: 69<br />
><br />
* upload completely sent off: 69 out of 69 bytes<br />
< HTTP/1.1 201 Created<br />
< Date: Sun, 16 Apr 2017 18:32:07 GMT<br />
< Content-Type: application/json;charset=UTF-8<br />
< Content-Length: 30<br />
< Server: Jetty(9.2.15.v20160210)<br />
<<br />
* Connection #0 to host localhost left intact<br />
{"result":"Temperature added"}</pre><br />
W wyniku widzimy &ldquo;piękną&rdquo; odpowiedź w formacie JSON. Oczywiście sama temperatura jeszcze się nigdzie nie zapisuje - nie podłączyłem do tego bazy danych. Zajmę się tym w najbliższym tygodniu.</p>
<p>Cała konwersja możliwa jest dzięki klasie <a href="https://github.com/SamouczekProgramisty/Pogodynka/blob/master/datavault/src/main/java/pl/samouczekprogramisty/pogodynka/datavault/configuration/conversion/CustomDateTimeAdapter.java" target="_blank">CustomDateTimeAdapter</a>. Następnie do automatycznego mechanizmu konwersji Springa <a href="https://github.com/SamouczekProgramisty/Pogodynka/blob/master/datavault/src/main/java/pl/samouczekprogramisty/pogodynka/datavault/configuration/WebAppConfiguration.java#L27" target="_blank">dodaję</a> to właśnie rozszerzenie. Dzięki takiej konfiguracji obiekty zawierające instancję DateTime poprawnie tworzone są na podstawie zapytań zawierających dane w formacie JSON.</p>
<h1>Walidacja danych wejściowych</h1><br />
Nie można ufać użytkownikom. Nawet jeśli jedynym użytkownikiem w trym przypadku jest aplikacja, którą ja napisałem. Zakrawa to trochę o schizofrenię, ale takie są &ldquo;dobre praktyki&rdquo; pisania aplikacji. Dane wejściowe trzeba walidować, koniec i kropka.</p>
<p>Specyfikacja <a href="https://jcp.org/en/jsr/detail?id=303" target="_blank">Bean Validation 1.0</a> doczekała się swojego następcy <a href="https://jcp.org/en/jsr/detail?id=349" target="_blank">Bean Validation 1.1</a> i <a href="https://jcp.org/en/jsr/detail?id=380" target="_blank">Bean Validation 2.0</a>. Na dzień dzisiejszy wersja 1.1 jest &ldquo;obowiązującą&rdquo;. Jako implementację walidatora wybrałem <a href="http://hibernate.org/validator/" target="_blank">Hibernate</a>.</p>
<p>Proste dołączenie biblioteki w pliku <a href="https://github.com/SamouczekProgramisty/Pogodynka/blob/master/datavault/datavault.gradle" target="_blank">datavault.gradle</a> wraz z użyciem adnotacji <a href="http://docs.oracle.com/javaee/7/api/javax/validation/constraints/NotNull.html" target="_blank">@NotNull</a> i <a href="http://docs.oracle.com/javaee/7/api/javax/validation/Valid.html" target="_blank">@Valid</a> pokazuje siłę Springa:</p>
<pre class="lang:default highlight:0 decode:true">curl -H 'Content-Type: application/json' http://localhost:8080/datavault/temperatures -d '{"temperature": 123}' -v<br />
* Trying 127.0.0.1...<br />
* Connected to localhost (127.0.0.1) port 8080 (#0)<br />
> POST /datavault/temperatures HTTP/1.1<br />
> Host: localhost:8080<br />
> User-Agent: curl/7.47.0<br />
> Accept: */*<br />
> Content-Type: application/json<br />
> Content-Length: 20<br />
><br />
* upload completely sent off: 20 out of 20 bytes<br />
< HTTP/1.1 400 Bad Request<br />
< Date: Sun, 16 Apr 2017 18:46:30 GMT<br />
< Content-Type: application/json;charset=UTF-8<br />
< Content-Length: 52<br />
< Server: Jetty(9.2.15.v20160210)<br />
<<br />
* Connection #0 to host localhost left intact<br />
{"errors":["Field whenMeasured must not be empty!"]}</pre></p>
<h1>Kontroler - serce aplikacji</h1><br />
Ta aplikacja to w praktyce jeden kontroller. Dodatkowo aplikacja zawiera drobną konfigurację rozszerzającą domyślne ustawienia.</p>
<pre class="lang:default decode:true">@Controller<br />
@RequestMapping("/temperatures")<br />
public class TemperatureController {</p>
<p>    private static final Logger LOG = LoggerFactory.getLogger(TemperatureController.class);</p>
<p>    private final TemperatureService temperatureService;</p>
<p>    private final MessageSource messageSource;</p>
<p>    @Autowired<br />
    public TemperatureController(TemperatureService temperatureService, MessageSource messageSource) {<br />
        this.messageSource = messageSource;<br />
        this.temperatureService = temperatureService;<br />
    }</p>
<p>    @PostMapping(consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br />
    @ResponseBody<br />
    public ResponseEntity addTemperature(@Valid @RequestBody TemperatureMeasurement temperature, Errors errors) {<br />
        if (errors.hasErrors()) {<br />
            List<String> errorMessages = errors.getAllErrors().stream()<br />
                .map(e -> messageSource.getMessage(e.getCode(), e.getArguments(), null))<br />
                .collect(Collectors.toList());<br />
            return new ResponseEntity<>(Collections.singletonMap("errors", errorMessages), HttpStatus.BAD_REQUEST);<br />
        }</p>
<p>        temperatureService.addTemperature(temperature);</p>
<p>        return new ResponseEntity<>(Collections.singletonMap("result", "Temperature added"), HttpStatus.CREATED);<br />
    }</p>
<p>    @GetMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br />
    @ResponseBody<br />
    public Map<String, List<TemperatureMeasurement>> listTemperatures() {<br />
        LOG.debug("Listing all temperatures");<br />
        List<TemperatureMeasurement> temperatures = temperatureService.getTemperatures();<br />
        Map<String, List<TemperatureMeasurement>> responseMap = new HashMap<>();<br />
        responseMap.put("temperatures", temperatures);<br />
        return responseMap;<br />
    }<br />
}</pre></p>
<h1>Podsumowanie</h1><br />
Czasu już dużo nie zostało. Teraz zamierzam pracować nad pogodynką także w tygodniu, nie tylko w weekendy jak do tej pory. Trzymajcie za mnie kciuki ;)</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/littlekoshka/4647737233/sizes/l</p>
