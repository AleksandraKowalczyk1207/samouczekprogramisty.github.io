---
layout: default
title: Pogodynka - JPA i Spring Data
excerpt: "Raport z frontu Pogodynki część 6. Dzisiaj pokrótce opisuję konfigurację
  warstwy dostępu do bazy danych. Sama konfiguracja skończyła się na dodaniu kilku
  zależności i magicznych adnotacji, które postaram się wyjaśnić.\r\n\r\n"
date: '2017-04-23 20:45:31 +0200'
categories:
- DSP2017
- Projekty
- Pogodynka
---
<p>Raport z frontu Pogodynki część 6. Dzisiaj pokrótce opisuję konfigurację warstwy dostępu do bazy danych. Sama konfiguracja skończyła się na dodaniu kilku zależności i magicznych adnotacji, które postaram się wyjaśnić.</p>
<p><a id="more"></a><a id="more-873"></a></p>
<h1>Baza danych</h1><br />
Dla celów testowych i na &ldquo;środowisku developerskim&rdquo; (czytaj moim własnym komputerze) używam prostej bazy danych. Mam tu na myśli <a href="http://hsqldb.org/" target="_blank" rel="noopener noreferrer">HyperSQL</a>. Jest to baza danych, której zawartość może być trzymana wyłącznie w pamięci.</p>
<p>Tego typu rozwiązanie idealnie nadaje się do pracy na środowisku programistycznym. Często też bazy danych tego typu używane są w trakcie testów integracyjnych. W trakcie takich testów możliwe jest testowanie właściwej integracji z bazą danych.</p>
<p>Dostęp do tej bazy danych możliwy jest po dodaniu jednej linijki do konfiguracji Gradle</p>
<p><span class="lang:default highlight:0 decode:true crayon-inline ">compile group: 'org.hsqldb', name: 'hsqldb', version: '2.4.0'</span></p>
<p>Jeśli chcesz dowiedzieć się czegoś więcej o samym Gradle zachęcam do przeczytania <a href="http://www.samouczekprogramisty.pl/wstep-do-gradle/">wprowadzenia do Gradle</a>.</p>
<h1>JPA i ORM</h1><br />
I tu wchodzą nam dwie wielkie kobyły ;). JPA czyli <em>Java Persistence API</em> i ORM czyli <em>Object-Relational Mapping</em>. JPA to specyfikacja, która została włączona do specyfikacji EJB (ang. <em>Enterprise Java Beans</em>). Specyfikacja ta określa mechanizmy, które pozwalają na "proste" zarządzanie zawartością bazy danych przez obiekty w Java.</p>
<p>Innymi słowy instancje klas odpowiadają wierszom w bazie danych. Mapowanie zawartości bazy danych na obiekty Javy to &ldquo;mapowanie obiektowo-relacyjne&rdquo; - ORM. Najszerzej stosowaną implementacją JPA jest Hibernate. To właśnie tę implementację użyłem w Pogodynce. Aby uzyskać wsparcie Hibernate niezbędne są następujące zależności:</p>
<pre class="lang:default highlight:0 decode:true">compile group: 'org.hibernate', name: 'hibernate-entitymanager', version: '5.2.10.Final'<br />
compile group: 'org.hibernate', name: 'hibernate-core', version: '5.2.10.Final'</pre></p>
<h2>ORM</h2><br />
Nie wchodząc w szczegóły samego JPA i Hibernate opiszę co udało mi się osiągnąć. Przy pomocy odpowiednich adnotacji w kodzie Javy mapuję obiekty klasy <a href="https://github.com/SamouczekProgramisty/Pogodynka/blob/master/datavault/src/main/java/pl/samouczekprogramisty/pogodynka/datavault/model/TemperatureMeasurement.java" target="_blank" rel="noopener noreferrer"><code>TemperatureMeasurement</code></a> na wiersze w tabeli <code>temperature_measurements</code>. Całość wymagała kilku adnotacji w kodzie oraz dodatkowej konfiguracji, która pozwoliła na mapowanie typu DateTime na odpowiedni typ w bazie danych.</p>
<p>Jedyny obiekt modelu, który aktualnie jest dostępny wygląda następująco:</p>
<pre class="lang:default decode:true">@Entity<br />
@Table(name = "temperature_measurements",<br />
       indexes = @Index(name = "idx_temperature_measurements_when_meaasured",<br />
                        columnList = "when_measured"))<br />
public class TemperatureMeasurement {</p>
<p>    @Id<br />
    @SequenceGenerator(name = "measurements_sequence", allocationSize = 5, sequenceName = "temperature_measurements_seq")<br />
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "measurements_sequence")<br />
    private Long id;</p>
<p>    private BigDecimal temperature;</p>
<p>    @Column(name = "when_measured")<br />
    private DateTime whenMeasured;</p>
<p>    public TemperatureMeasurement() {<br />
    }</p>
<p>    public TemperatureMeasurement(BigDecimal temperature, DateTime whenMeasured) {<br />
        this.temperature = temperature;<br />
        this.whenMeasured = whenMeasured<br />
    }</p>
<p>    @NotNull<br />
    public BigDecimal getTemperature() {<br />
        return temperature;<br />
    }</p>
<p>    @NotNull<br />
    public DateTime getWhenMeasured() {<br />
        return whenMeasured;<br />
    }<br />
}</pre></p>
<h2>Warstwa dostępu do danych</h2><br />
Warstwa DAO (ang. <em>Data Access Object</em>) jest automatycznie generowana. Są to obiekty pośredniczące zarządzane przez Spring. Interfejs DAO, którym posługuję się w aplikacji sprowadza się do kilku linijek:</p>
<pre class="lang:default decode:true ">@Repository<br />
public interface TemperatureMeasurementDAO extends CrudRepository<TemperatureMeasurement, Long> {<br />
}</pre><br />
Taka &ldquo;magia&rdquo; dostępna jest dzięki użyciu Spring Data:</p>
<pre class="lang:default highlight:0 decode:true ">compile group: 'org.springframework.data', name: 'spring-data-jpa', version: '1.11.3.RELEASE</pre></p>
<h1>Magiczna konfiguracja Spring</h1><br />
Całość konfiguracji to jeden nowy plik. Tworzy on odpowiednie obiekty, które wymagane są przez specyfikację JPA</p>
<pre class="lang:default decode:true ">@Configuration<br />
@EnableTransactionManagement<br />
@EnableJpaRepositories(basePackages = "pl.samouczekprogramisty.pogodynka.datavault.model")<br />
public class JPAConfigration {</p>
<p>    @Bean<br />
    public DataSource getDataSource() {<br />
        DriverManagerDataSource dataSource = new DriverManagerDataSource();<br />
        dataSource.setDriverClassName("org.hsqldb.jdbc.JDBCDriver");<br />
        dataSource.setUrl("jdbc:hsqldb:mem:datavault_test");<br />
        dataSource.setUsername("datavault_test");<br />
        dataSource.setPassword("datavault_test");<br />
        return dataSource;<br />
    }</p>
<p>    @Bean<br />
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {<br />
        LocalContainerEntityManagerFactoryBean entityManager = new LocalContainerEntityManagerFactoryBean();<br />
        entityManager.setDataSource(getDataSource());<br />
        entityManager.setJpaVendorAdapter(new HibernateJpaVendorAdapter());<br />
        entityManager.setPackagesToScan("pl.samouczekprogramisty.pogodynka.datavault.model");</p>
<p>        Properties jpaProperties = new Properties();<br />
        jpaProperties.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");<br />
        jpaProperties.setProperty("hibernate.show_sql", "true");<br />
        jpaProperties.setProperty("hibernate.format_sql", "true");<br />
        jpaProperties.setProperty("hibernate.hbm2ddl.auto", "create-drop");<br />
        jpaProperties.setProperty("jadira.usertype.autoRegisterUserTypes", "true");</p>
<p>        entityManager.setJpaProperties(jpaProperties);</p>
<p>        return entityManager;<br />
    }</p>
<p>    @Bean<br />
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {<br />
        JpaTransactionManager transactionManager = new JpaTransactionManager();<br />
        transactionManager.setEntityManagerFactory(entityManagerFactory);</p>
<p>        return transactionManager;<br />
    }</p>
<p>    @Bean<br />
    public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {<br />
        return new PersistenceExceptionTranslationPostProcessor();<br />
    }<br />
}</pre></p>
<h1>Podsumowanie</h1><br />
Na dzień dzisiejszy mam &ldquo;gotową&rdquo; aplikację webową, która wystawia dwa adresy URL. Pozwalają one na utworzenie nowej instancji pomiaru temperatury i pobrania wszystkich istniejących pomiarów. Kolejnym krokiem będzie zaimplementowanie &ldquo;logowania&rdquo; użytkowników i wystawienia takiej aplikacji na świat. Następnie będę mógł zintegrować czujnik z tak działającą aplikacją.</p>
<p>Po kilku dniach działania aplikacji będę miał wystarczająco dużo rzeczywistych pomiarów temperatury, które pozwolą mi na pracę nad interfejsem użytkownika.</p>
<p>Jeśli chcesz zobaczyć aktualną wersję aplikacji możesz ją znaleźć na <a href="https://github.com/SamouczekProgramisty/Pogodynka/tree/master/datavault" target="_blank" rel="noopener noreferrer">samouczkowym githubie</a>. Trzymaj się i do następnego razu!</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/rubysfeast/7149704201/sizes/l</p>
