---
layout: post
status: publish
published: true
title: String cache i StringBuilder w praktyce
author:
  display_name: Marcin Pietraszek
  login: marcin
  email: m.pietraszek@gmail.com
  url: ''
author_login: marcin
author_email: m.pietraszek@gmail.com
excerpt: "Znajomość biblioteki standardowej w zakresie pracy z łańcuchami znaków
  jest niezbędna do wydajnej pracy. Świadomość pewnych ograniczeń i właściwości związanych
  z łańcuchami znaków także się przydaje. Po lekturze tego artykułu będziesz
  znał te mechanizmy. Dowiesz się także czym jest cache i jak jest on używany w przypadku
  literałów znakowych. Poznasz klasę <code>StringBuilder</code> i dowiesz
  się dlaczego jest taka ważna. Zapraszam do lektury!\r\n\r\n"
wordpress_id: 885
wordpress_url: http://www.samouczekprogramisty.pl/?p=885
date: '2017-05-06 23:46:34 +0200'
date_gmt: '2017-05-06 21:46:34 +0200'
categories:
- Kurs programowania Java
- DSP2017
tags: []
comments: []
---
<p>Znajomość biblioteki standardowej w zakresie pracy z łańcuchami znaków jest niezbędna do wydajnej pracy. Świadomość pewnych ograniczeń i właściwości związanych z łańcuchami znaków także się przydaje. Po lekturze tego artykułu będziesz znał te mechanizmy. Dowiesz się także czym jest cache i jak jest on używany w przypadku literałów znakowych. Poznasz klasę <code>StringBuilder</code> i dowiesz się dlaczego jest taka ważna. Zapraszam do lektury!</p>
<p><a id="more"></a><a id="more-885"></a></p>
<h1>Literał znakowy</h1><br />
Na początku powtórka podstaw. Literał znakowy to ciąg znaków otoczony cudzysłowami. Jest to instancja klasy <code>String</code>, jednak tworzona jest bez udziału słówka kluczowego <code>new</code>. Przykład poniżej pokazuje literał znakowy przypisany do zmiennej:</p>
<pre class="lang:default decode:true ">String someLiteral = &ldquo;some constant value&rdquo;;</pre></p>
<h1>Jak działa klasa <code>String</code></h1><br />
Instancje klasy <code>String</code> reprezentują łańcuchy znaków. Wewnętrznie znaki te przetrzymywane są w tablicy znaków. Tablica ta ma typ <code>char[]</code>. Implementacja klasy <code>String</code> chowa przed programistą mechanizmy operowania na tej tablicy.</p>
<p>Instancje klasy <code>String</code> są niemutowalne. Oznacza to tyle, że po stworzeniu instancji nie ma możliwości jej modyfikacji. Kilka metod wymienionych poniżej zwraca nowe instancje, pozostawiając tę na której zostały wywołane bez zmian:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replace-char-char" target="_blank" rel="noopener noreferrer"><code>replace</code></a> - podmienia znak w łańcuchu znaków,</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#substring-int-" target="_blank" rel="noopener noreferrer"><code>substring</code></a> - zwraca pewną część łańcucha znaków określoną indeksami,</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--" target="_blank" rel="noopener noreferrer"><code>toLowerCase</code></a> - zamienia wielkie litery na małe w nowej instancji,</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--" target="_blank" rel="noopener noreferrer"><code>toUpperCase</code></a> - zamienia łańcuch znaków na wielkie litery,</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--" target="_blank" rel="noopener noreferrer"><code>trim</code></a> - zwraca nową instancję bez początkowych i końcowych białych znaków.</li><br />
</ul></p>
<h1>Co jeśli String nie ma metody, której potrzebuję?</h1><br />
Chociaż klasa <code>String</code> zawiera spory zestaw metod, nie jest to lista kompletna. Jeśli trafisz na taki przypadek nie próbuj wynaleźć koła na nowo. Lepiej rzuć okiem na istniejące biblioteki. Na przykład na <a href="https://commons.apache.org/proper/commons-lang/" target="_blank" rel="noopener noreferrer">commons-lang</a> . Biblioteka ta zawiera klasę <a href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html" target="_blank" rel="noopener noreferrer"><code>StringUtils</code></a>, w której znajdziesz masę przydatnych metod operujących na łańcuchach znaków.</p>
<h1>Konkatenacja łańcuchów znaków</h1><br />
Najprostszym sposobem otrzymania łańcucha znaków jaki nas interesuje jest złożenie go z wielu części. Służy do tego operator <code>+</code>. Operacja ta nazywana jest konkatenacją.</p>
<pre class="lang:default decode:true ">System.out.println("some" + " " + "string" + " " + "literal");</pre><br />
W przypadku konkatenacji każdy z elementów konwertowany jest do typu <code>String</code> używając metody <code>toString</code> [0. Nie jest to do końca prawda, na przykład w przypadku typów prymitywnych stosowany jest inny mechanizm, zależny od typu zmiennej.]</p>
<pre class="lang:default decode:true ">int x = 10;<br />
Object y = new Object();<br />
System.out.println("some" + " " + x + " " + "literal" + " " + y);</pre><br />
Używanie operatora <code>+</code> może być bardzo wygodne jednak czasami może prowadzić do zaskakujących (na początku) rezultatów. Proszę porównaj dwie poniższe linijki kodu:</p>
<pre class="lang:default decode:true ">System.out.println(1 + 2 + "test"); // 3test<br />
System.out.println("test" + 1 + 2); // test12</pre><br />
Pierwsza z nich na początku doda dwie liczby uzyskując 3 a następnie dołączy do niej łańcuch znaków. Druga do łańcucha znaków dołączy dwie kolejne liczby. Dzieje się tak ponieważ operator <code>+</code> jest lewostronnie łączny. Oznacza to tyle, że w tym przypadku wyrażenie to wykonywane jest od lewej do prawej strony.</p>
<p>W pierwszym przypadku do liczby 1 dodajemy liczbę 2, następnie "dodajemy" do niej łańcuch znaków. W drugim przypadku do łańcucha znakód dodajemy kolejno dwie liczby.</p>
<p>Klasa <code>String</code> posiada także metodę <code>concat</code>, która działa w podobny sposób do operatora <code>+</code>[1. Istnieją oczywiście drobne różnice, na przykład zachowanie w odniesieniu do zmiennych o wartości <code>null</code>.].</p>
<h1>Wydajność a konkatenacja</h1><br />
Wiesz już, że instancje klasy <code>String</code> są niemutowalne. Wszystkie metody znajdujące się w klasie <code>String</code>, modyfikują łańcuch znaków tak na prawdę tworzą jego nową instancję.</p>
<p>Nie inaczej jest z konkatenacją. Proszę spójrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">String some = "some";<br />
String space = " ";<br />
String random = "random";<br />
String string = "string";</p>
<p>String someString = some + space + random + space + string;</pre><br />
Tak na prawdę, zanim powstałaby finalna instancja klasy <code>String</code> potrzebne byłoby aż trzy &ldquo;tymczasowe&rdquo; obiekty [2. Piszę &ldquo;potrzebne byłby&rdquo; ponieważ kompilator wprowadza tu pewne optymalizacje, o których przeczytasz niżej.]. Dopiero piąty obiekt byłby tym, który mógłby być przypisany do zmiennej <code>someString</code>. Dlaczego aż cztery? Wynika to z niemutowalności instancji klasy <code>String</code>. Nie możemy, posługując się wyłącznie instancjami klasy <code>String</code> od razu stworzyć finalnej wersji. Tworzone są obiekty &ldquo;pośrednie&rdquo;:</p>
<ul>
<li><code>&ldquo;some &ldquo;</code> (zwróć uwagę na spację na końcu),</li>
<li><code>&ldquo;some random&rdquo;</code>,</li>
<li><code>&ldquo;some random &ldquo;</code> (ponownie ze spacją).</li><br />
</ul><br />
Tworzenie takich nowych tymczasowych instancji nie jest wydajne. Można to zrobić lepiej. Z pomocą przychodzą klasy <code>StringBuilder</code> i <code>StringBuffer</code>.[3. Prawda jest taka, że kompilator Java w trakcie kompilacji wykrywa taką konkatenacją i zastępuje ją właśnie wywołaniem odpowiednich metod na instacji klasy <code>StringBuilder</code>. Więc w prostych przypadkach tragedii nie ma, gorzej jeśli w grę wchodzą pętle ;).]</p>
<h2>Jak używać klasy <code>StringBuilder</code></h2><br />
Klasa <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener noreferrer"><code>StringBuilder</code></a> podobnie jak <code>String</code> jest opakowaniem tablicy znaków typu <code>char[]</code>. <code>StringBuilder</code> jednak jest typem mutowalnym. Instancje tego typu w można konwertować do typu <code>String</code> używając metody <code>toString</code>.</p>
<p>Najprosztszym sposobem utworzenia instancji klasy <code>StringBuilder</code> jest użycie konstruktora bezparametrowego. Następnie możesz modyfikować ten obiekt używając dostępnych metod.</p>
<p>Bardzo przydatną metodą z tej klasy jest przeciążona metoda <code>append</code>. Pozwala ona na wydajne łączenie łańcuchów znaków. Proszę spójrz na przykład poniżej pokazujący sposób użycia klasy:</p>
<pre class="lang:default decode:true ">public void compilerConcatenationFiddling() {<br />
    String some = "some";<br />
    String space = " ";<br />
    String random = "random";<br />
    String string = "string";</p>
<p>    StringBuilder someSttringBuilder = new StringBuilder();<br />
    someSttringBuilder.append(some);<br />
    someSttringBuilder.append(space);<br />
    someSttringBuilder.append(random);<br />
    someSttringBuilder.append(space);<br />
    someSttringBuilder.append(string);</p>
<p>    String someString = someSttringBuilder.toString();<br />
}</pre></p>
<h2>Różnica pomiędzy <code>StringBuilder</code> a <code>StringBufer</code></h2><br />
Istnieje też inna implementacja tej samej funkcjonalności. Jest to klasa <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html" target="_blank" rel="noopener noreferrer"><code>StringBuffer</code></a>. Jeśli masz przed sobą rozmowę kwalifikacyjną dobrze jest znać różnicę między tymi klasami. Jest to jedno ze &ldquo;sztampowych&rdquo; pytań rekrutacyjnych ;).</p>
<p>Główną różnicą jest to, że instancję klasy <code>StringBuffer</code> można bezpiecznie używać nawet w aplikacjach wielowątkowych. Instancje klasy <code>StringBuilder</code> nie powinny być współdzielone pomiędzy wątkami. Cecha ta ma jedną ważną konsekwencję. Ze względu na brak synchronizacji instancje klasy <code>StringBuilder</code> są nieznacznie szybsze od <code>StringBuffer</code>.</p>
<p>Dodatkowo możesz zapoznać się też z klasą <a href="https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html" target="_blank" rel="noopener noreferrer"><code>StringJoiner</code></a>, która oferuje podobną funkcjonalność. Jest ona wykorzystywana na przykład podczas łączenia strumieni.</p>
<h1>Optymalizacja konkatenacji przez kompilator</h1><br />
Mamy dwa elementy układanki. Klasę <code>StringBuilder</code>, która dużo lepiej się sprawdza przy pracy z łączeniem znaków. Konkatenację, która nie jest wydajnym sposobem łączenia łańcuchów znaków.</p>
<p>Mamy też metodę <code>append</code>, którą już poznałeś. Jest ona odpowiednikiem <code>+</code> w konkatenacji. Nie można czegoś z tym zrobić?</p>
<p>Oczywiście, że można! I to właśnie jest robione przez kompilator. Tak naprawdę, pisząc kod:</p>
<pre class="lang:default decode:true ">String some = "some";<br />
String space = " ";<br />
String random = "random";<br />
String string = "string";</p>
<p>String someString = some + space + random + space + string;</pre><br />
Kompilator kompiluje go do postaci, która wygląda podobnie do fragmentu niżej:</p>
<pre class="lang:default decode:true ">String some = "some";<br />
String space = " ";<br />
String random = "random";<br />
String string = "string";</p>
<p>StringBuilder x = new StringBuilder();<br />
x.append(some);<br />
x.append(space);<br />
x.append(random);<br />
x.append(space);<br />
x.append(string);</p>
<p>String someString = x.toString();</pre><br />
Innymi słowy kompilator optymalizuje za nas kod. Czy ta optymalizacja zawsze działa? Niestety nie, są przypadki kiedy nawet taka optymalizacja nie daje rady. Proszę spójrz na przykład poniżej. Jest to pętla, która dołącza aktualny stan licznika do łańcucha znaków.</p>
<pre class="lang:default decode:true ">String finalString = "";<br />
for (int counter = 0; counter < 1000000; counter++) {<br />
    finalString = finalString + " " + counter;<br />
}</pre><br />
Jak zoptymalizuje to kompilator? Będzie to kod podobny do tego:</p>
<pre class="lang:default decode:true">String finalString = "";<br />
for (int counter = 0; counter < 1000000; counter++) {<br />
    StringBuilder x = new StringBuilder();<br />
    x.append(finalString);<br />
    x.append(" ");<br />
    x.append(counter);<br />
    finalString = x.toString();<br />
}</pre><br />
Niestety mimo optymalizacji wewnątrz pętli dalej musimy tworzyć blisko milion obiektów tymczasowych. To jest czasochłonne. Lepszym rozwiązaniem jest poniższy fragment kodu:</p>
<pre class="lang:default decode:true">StringBuilder finalStringBuilder = new StringBuilder();<br />
for (int counter = 0; counter < 1000000; counter++) {<br />
    finalStringBuilder.append(" ");<br />
    finalStringBuilder.append(counter);<br />
}<br />
String finalString = finalStringBuilder.toString();</pre><br />
W tym przypadku sam tworzę instancję klasy <code>StringBuilder</code> i używam jej wewnątrz pętli.</p>
<h1>Literały i cache</h1><br />
Specyfikacja języka Java narzuca pewne wymagania związane z optymalizacją pracy z łańcuchami znaków. Każdy łańcuch znaków, który jest literałem umieszczany jest w cache&rsquo;u.</p>
<p>[idea]Tutaj drobna dygresja. Cache to mechanizm, który pozwala na przetrzymywanie wartości jakiegoś typu. Przeważnie uzyskanie tej wartości jest czasochłonne. Założeniem tego mechanizmu jest pozwolenie na szybsze dotarcie do tych wartości w późniejszym czasie. Dodatkowo pozwala on na optymalizację zajmowanego miejsca. Elementy znajdujące się w cache&rsquo;u przeważnie się nie powtarzają. Cache może być zrealizowany na wiele sposobów, najprostszą implementacją może być zwykła instancja <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank" rel="noopener noreferrer"><code>HashMap</code></a>. W bardziej zaawansowanych zastosowaniach używa się osobnych programów/baz danych, które zapewniają tę funkcjonalność, na przykład <a href="https://memcached.org/" target="_blank" rel="noopener noreferrer">memcached</a>.[/idea]</p>
<p>Oznacza to tyle, że poniższe dwie zmienne są referencjami na dokładnie ten sam obiekt na stercie. Dzieje się tak, ponieważ są one literałami o tej samej zawartości:</p>
<p>[idea]Poniższe fragmenty kodu są testami jednostkowymi. Jeśli chcesz przeczytać więcej na ten temat zapraszam do arytkułu poświęconemu <a href="http://www.samouczekprogramisty.pl/testy-jednostkowe-z-junit/">testom jednostkowym w Javie</a>. Możesz też przeczytać kolejny artykuł poświęcony <a href="http://www.samouczekprogramisty.pl/test-driven-development-na-przykladzie/">Test Driven Development</a>.[/idea]</p>
<pre class="lang:default decode:true ">@Test<br />
public void twoLiterals() {<br />
    String someVariable = "samouczek programisty";<br />
    String otherVariable = "samouczek programisty";</p>
<p>    assertEquals(someVariable, otherVariable);<br />
    assertSame(someVariable, otherVariable);<br />
}</pre><br />
Pierwsze porównanie, sprawdza &ldquo;zawartość&rdquo; łańcucha znaków. Drugie porównuje adresy obiektów na stercie.</p>
<p>W przypadku utworzenia nowej instancji przy pomocy wywołania konstruktora, zawsze tworzone są nowe obiekty. Proszę porównaj poprzedni fragment kodu z tym poniżej:</p>
<pre class="lang:default decode:true ">@Test<br />
public void twoNewObjects() {<br />
    String someVariable = new String("samouczek programisty");<br />
    String otherVariable = new String("samouczek programisty");</p>
<p>    assertEquals(someVariable, otherVariable);<br />
    assertNotSame(someVariable, otherVariable);<br />
}</pre><br />
W tym przypadku mamy do czynienia z dwoma osobnymi obiektami. W tym przypadku adresy obiektów są różne.</p>
<h2>Metoda <code>String.intern</code></h2><br />
Istnieje sposób aby zachować wartość łańcucha znaków w cache (lub pobrać go z cache). Dzięki tej metodzie w cache'u możemy zachować nawet instancje utworzone przy pomocy konstruktora. Służy do tego metoda <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--" target="_blank" rel="noopener noreferrer"><code>intern</code></a>. Wywołanie tej metody zachowuje w cache'u dany łańcuch znaków i zwraca instancję, która jest w cache'u zachowana. Jeśli ten literał istnieje już w cache'u, będzie tam zachowany wyłącznie raz.</p>
<p>Proszę spójrz na przykład poniżej</p>
<pre class="lang:default decode:true ">@Test<br />
public void literalAndInternedObject() {<br />
    String someVariable = "samouczek programisty";<br />
    String otherVariable = new String("samouczek programisty").intern();</p>
<p>    assertEquals(someVariable, otherVariable);<br />
    assertSame(someVariable, otherVariable);<br />
}</pre><br />
W tym przypadku oba porównania zwrócą wartość <code>true</code>.</p>
<h1>Dodatkowe materiały do nauki</h1><br />
Poniżej przygotowałem dla Ciebie zestaw odnośników, które mogą pomóc w rozwijaniu wiedzy związanej z pracą z łańcuchami znaków:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.18.1" target="_blank" rel="noopener noreferrer">Java Language Specification o konkatenacji</a>,</li>
<li>dokumentacja klasy <a href="https://github.com/apache/commons-lang/blob/master/src/main/java/org/apache/commons/lang3/StringUtils.java" target="_blank" rel="noopener noreferrer"><code>StringUtils</code></a>,</li>
<li>dokumentacja klasy <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener noreferrer"><code>StringBuilder</code></a>,</li>
<li>dokumentacja klasy <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html" target="_blank" rel="noopener noreferrer"><code>StringBuffer</code></a>,</li>
<li>dokumentacja klasy <a href="https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html" target="_blank" rel="noopener noreferrer"><code>StringJoiner</code></a>,</li>
<li><a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/26_lancuchy_znakow/src" target="_blank" rel="noopener noreferrer">kod źródłowy przykładów użytych w artykule</a>.</li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Po lekturze tego artykułu sporo wiesz o pracy z łańcuchami znaków. Poznałeś jedną z optymalizacji, które wprowadza kompilator. Umiesz odpowiedzieć na jedno ze sztampowych pytań rekrutacyjnych ;). Znasz sposób pracy z klasą <code>StringBuilder</code>. Dowiedziałeś się też o przydatnych metodach operujących na instancjach klasy <code>String</code> znajdujących się w bibliotece commons-lang.</p>
<p>Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć żadnego postu polub stronę na facebooku i dopisz się do samouczkowego newslettera. Do następnego razu!</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/jasohill/54816310/sizes/l</p>
