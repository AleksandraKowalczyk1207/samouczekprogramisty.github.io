---
layout: default
title: Wyrażenia lambda w języku Java
excerpt: "W artykule tym poznasz mechanizm tworzenia wyrażeń lambda. Dowiesz się jak
  ich używać. Poznasz też praktyczne zastosowania. Dowiesz się też jak działa operator
  <code>::</code>. Jeśli jesteś początkującym zrozumienie wyrażeń lambda pozwoli
  Ci przenieść swoje umiejętności na kolejny poziom. Zdobytą wiedzę będziesz mógł
  przećwiczyć rozwiązując kilka przykładowych zadań.\r\n\r\n"
date: '2017-07-26 21:28:10 +0200'
categories:
- Kurs programowania Java
---
<p>W artykule tym poznasz mechanizm tworzenia wyrażeń lambda. Dowiesz się jak ich używać. Poznasz też praktyczne zastosowania. Dowiesz się też jak działa operator <code>::</code>. Jeśli jesteś początkującym zrozumienie wyrażeń lambda pozwoli Ci przenieść swoje umiejętności na kolejny poziom. Zdobytą wiedzę będziesz mógł przećwiczyć rozwiązując kilka przykładowych zadań.</p>
<p><a id="more"></a><a id="more-966"></a></p>
<p>[idea]Artykuł ten dotyczy bardziej zaawansowanego fragmentu składni języka Java. Z tego powodu aby móc w pełni skorzystać z artykułu warto zapoznać się z wcześniejszymi artykułami na temat:</p>
<ul>
<li><a href="http://www.samouczekprogramisty.pl/klasy-wewnetrzne-i-anonimowe-w-jezyku-java/">klas anonimowych</a><a href="http://www.samouczekprogramisty.pl/typy-generyczne-w-jezyku-java/">,</a></li>
<li><a href="http://www.samouczekprogramisty.pl/typy-generyczne-w-jezyku-java/">typów generycznych</a>,</li>
<li><a href="http://www.samouczekprogramisty.pl/adnotacje-w-jezyku-java/">adnotacji</a>.[/idea]</li><br />
</ul></p>
<h1>Czym jest wyrażenie lambda</h1><br />
Dla uproszczenia można powiedzieć, że wyrażenie lambda jest metodą[1. Nie jest to do końca prawda, na przykład wyrażenie lambda nie wprowadza nowego zakresu zmiennych, ale takie uproszczenie pomoże zrozumieć działanie wyrażeń lambda.]. Metodą, którą możesz przypisać do zmiennej. Możesz ją także wywołać czy przekazać jako argument do innej metody.</p>
<p>Wyrażenia lambda możesz także porównać do klas anonimowych [2. Podobnie jak przy poprzednim porównaniu, są różnice pomiędzy wyrażeniami lambda i klasami anonimowymi. Jednak na potrzeby tego wprowadzenia możemy je pominąć.]. Mają one jednak dużo bardziej czytelną i zwięzłą składnię.</p>
<p>Na przykład wyrażenie lambda, które podnosi do kwadratu przekazaną liczbę wygląda następująco:</p>
<pre class="lang:default decode:true ">x -> x * x</pre></p>
<h2>Składnia wyrażeń lambda</h2><br />
Wyrażenie lambda ma następującą składnię</p>
<pre class="lang:default highlight:0 decode:true ">
<lista parametrów> -> <ciało wyrażenia lambda></pre></p>
<h3>Lista parametrów</h3><br />
Lista parametrów zawiera wszystkie parametry przekazane do &ldquo;ciała&rdquo; wyrażenia lambda. W szczególności lista ta może być pusta. Wyrażenie lambda poniżej nie przyjmuje żadnych argumentów, zwraca natomiast instancję klasy <code>String</code>:</p>
<pre class="lang:default decode:true ">() -> &ldquo;some return value&rdquo;</pre><br />
Podawanie typów parametrów jest opcjonalne. Kompilator jest w stanie poznać te parametry z kontekstu w którym znajduje się dane wyrażenie lambda. Jeśli chcesz możesz je także podać:</p>
<pre class="lang:default decode:true ">(Integer x, Long y) -> System.out.println(x * y)</pre><br />
Nawiasy otaczające listę parametrów są opcjonalne jeśli wyrażenie ma wyłącznie jeden parametr bez określonego typu [3. Oczywiście w trakcie kompilacji typ jest znany, ale nie jest jawnie podany w kodzie źródłowym.].</p>
<h3>Ciało wyrażenia lambda</h3><br />
W ogromnej większości przypadków wyrażenia lambda zawierają jedną linijkę kodu:</p>
<pre class="lang:default decode:true ">x -> x * x<br />
() -> &ldquo;some return value&rdquo;<br />
(Integer x, Long y) -> System.out.println(x * y);</pre><br />
Może się jednak zdarzyć, że Twoje wyrażenie lambda będzie zawierało więcej linii. W takim przypadku musisz otoczyć je nawiasami <code>{}</code> jak w przykładzie poniżej:</p>
<pre class="lang:default decode:true ">x -> {<br />
    if (x != null &amp;&amp; x % 2 == 0) {<br />
        return (long) x * x;<br />
    }<br />
    else {<br />
        return 123L;<br />
    }<br />
}</pre><br />
Można sobie wyobrazić wyrażenie lambda, które nie przyjmuje żadnych parametrów i nie zwraca żadnych wartości. Najprostsza wersja takiego wyrażenia wygląda następująco:</p>
<pre class="lang:default decode:true">() -> {}</pre></p>
<h1>Od klasy anonimowej do wyrażenia lambda</h1><br />
Wiesz już czym jest klasa anonimowa. Dla przypomnienia powiem, że jest to stworzenie jedynej instancji klasy w miejscu jej użycia. Wiesz już też jak wyglądają wyrażenia lambda. Teraz nadszedł czas na zamianę klasy anonimowej na wyrażenie lambda. Proszę spójrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">public interface Checker<T> {<br />
    boolean check(T object);<br />
}</p>
<p>Checker<Integer> isOddAnonymous = new Checker<Integer>() {<br />
    @Override<br />
    public boolean check(Integer object) {<br />
        return object % 2 != 0;<br />
    }<br />
};</p>
<p>System.out.println(isOddAnonymous.check(123));<br />
System.out.println(isOddAnonymous.check(124));</pre><br />
W przykładzie tym zdefiniowałem interfejs <code>Checker</code>, który posiada jedną metodę <code>check</code>. Metoda ta zwraca wartość logiczną na podstawie przekazanego argumentu.</p>
<p>Fragment kodu robiący to samo jednak przy użyciu składni wyrażeń lambda wygląda następująco:</p>
<pre class="lang:default decode:true">Checker<Integer> isOddLambda = object -> object % 2 != 0;</p>
<p>System.out.println(isOddLambda.check(123));<br />
System.out.println(isOddLambda.check(124));</pre><br />
Prawda, że ładniej :)?</p>
<p>Dochodzimy teraz do momentu, w którym muszę Ci powiedzieć o typach w wyrażeniach lambda. Każde wyrażenie lambda jest instancją dowolnego interfejsu funkcyjnego. Jest to bardzo ważne, dlatego też musisz dokładnie wiedzieć czym jest interfejs funkcyjny.</p>
<h1>Interfejs funkcyjny</h1><br />
Interfejs funkcyjny to interfejs, który ma jedną abstrakcyjną metodę[5. Efektywnie abstrakcyjną, czyli dodanie do interfejsu np. metody equals, która jest w klasie Object nadal spełnia to wymaganie.]. Wprowadzono adnotację <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="noopener"><code>@FunctionalInterface</code></a>, którą możesz dodać do interfejsów tego typu.</p>
<p>Adnotacja ta zapewnia, że kompilator upewni się, że dany interfejs jest interfejsem funkcjonalnym. Jeśli nie, wówczas kompilacja się nie powiedzie.</p>
<p>Przykładem interfejsu funkcjonalnego może być zdefiniowany wcześniej interfejs Checker</p>
<pre class="lang:default decode:true ">@FunctionalInterface<br />
public interface Checker<T> {<br />
    boolean check(T object);<br />
}</pre><br />
Zawiera on wyłącznie jedną metodę <code>check</code>.</p>
<h2>Przykładowe interfejsy funkcyjne</h2><br />
Twórcy języka Java przygotowali zestaw interfejsów funkcyjnych, które możesz implementować. W większości przypadków w zupełności wystarczy ich użycie. Część z nich znajduje się w pakiecie <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener"><code>java.util.function</code></a>. Najważniejsze z nich zebrałem poniżej:</p>
<ul>
<li><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" target="_blank" rel="noopener">Function<T, R></a></code> zawiera metodę <code>apply</code>, która przyjmuje instancję ,klasy <code>T</code> zwracając instancję klasy <code>R</code><code></code></li>
<li><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" target="_blank" rel="noopener">Consumer<T></a></code> zawiera metodę <code>accept</code>, która przyjmuje instancję klasy <code>T</code></li>
<li><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" target="_blank" rel="noopener">Predicate<T></a></code> zawiera metodę <code>test</code>, która przyjmuje instancję klasy T i zwraca flagę. Interfejs ten może posłużyć do zastąpienia interfejsu <code>Checker</code>.</li>
<li><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" target="_blank" rel="noopener">Supplier<T></a></code> zawiera metodę <code>get</code>, która nie przyjmuje żadnych parametrów i zwraca instancję klasy <code>T</code></li>
<li><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html" target="_blank" rel="noopener">UnaryOperator<T></a></code> jest specyficznym przypadkiem interfejsu <code>Function</code>. W tym przypadku typ argumentu i typ zwracany są te same.</li><br />
</ul><br />
Wyrażenia lambda zdefiniowane na początku artykułu można przypisać do tych właśnie interfejsów:</p>
<pre class="lang:default decode:true ">UnaryOperator<Integer> square = x -> x * x;<br />
Supplier<String> someString = () -> "some return value";<br />
BiConsumer<Integer, Long> multiplier = (Integer x, Long y) -> System.out.println(x * y);<br />
Function<Integer, Long> multiline = x -> {<br />
    if (x != null &amp;&amp; x % 2 == 0) {<br />
        return (long) x * x;<br />
    }<br />
    else {<br />
        return 123L;<br />
    }<br />
};</pre></p>
<h1>Zalety stosowania wyrażeń lambda</h1><br />
Wyrażenia lambda są bardzo pomocne przy operacji na kolekcjach. Są niezastąpione także przy pracy ze strumieniami. Pozwalają także na pisanie w Javie w sposób &ldquo;funkcyjny&rdquo;[4. Oczywiście Java nie jest językiem w pełni funkcyjnym, jednak taka namiastka jest przydatna.].</p>
<p>Oczywistą zaletą wyrażeń lambda jest ich zwięzłość. Kod zajmuje o wiele mniej miejsca, staje się przez to bardziej czytelny.</p>
<h1>Odwoływanie się do metod</h1><br />
Wraz z wyrażeniami lambda Java została rozbudowana o składnię pozwalającą na odwoływanie się do metod. Służy do tego <code>::</code>. Dzięki temu wyrażeniu możemy przypisać metodę do zmiennej bez jej wywołania. Takie podejście pozwala na przekazanie tak wyłuskanej metody i wywołanie jej w zupełnie innym miejscu. Proszę spójrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">Object objectInstance = new Object();<br />
IntSupplier equalsMethodOnObject = objectInstance::hashCode;<br />
System.out.println(equalsMethodOnObject.getAsInt());</pre><br />
W przykładzie tym tworzę nową instancję klasy <code>Object</code>. Następnie pobieram metodę <code>hashCode</code> z tego obiektu i przypisuję ją do typu <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntSupplier.html" target="_blank" rel="noopener"><code>IntSupplier</code></a>. Jest to kolejny interfejs funkcyjny znajdujący się w standardowej bibliotece. Ostatnia linijka to wywołanie metody znajdującej się w tym interfejsie.</p>
<p>Kod powyżej można porównać do:</p>
<pre class="lang:default decode:true ">Object objectInstance = new Object();<br />
System.out.println(objectInstance.hashCode());</pre><br />
W obu przypadkach tworzę nowy obiekt klasy <code>Object</code> i wywołują na nim metodę <code>hashCode</code>.</p>
<h1>Odwoływanie się do metod bez podania instancji</h1><br />
Można także odwołać się do metody bez podania instancji, na której metoda powinna być wywołana. Wówczas ta instancja musi być przekazana jako pierwszy argument. Przykład poniżej powinien pomóc zrozumieć to zastosowanie:</p>
<pre class="lang:default decode:true ">ToIntFunction<Object> equalsMethodOnClass = Object::hashCode;<br />
Object objectInstance = new Object();<br />
System.out.println(equalsMethodOnClass.applyAsInt(objectInstance));</pre><br />
W odróżnieniu do poprzedniego przykładu tutaj na początku pobieram metodę. Tym razem metoda nie jest przypisana do instancji. W związku z tym wyrażenie lambda jest już innego typu. W takim przypadku zawsze pierwszym argumentem jest instancja na której metoda powinna być wywołana. W kolejnej linijce tworzę instancję klasy <code>Object</code>. Ostatnia linijka to wywołanie metody na tej instancji.</p>
<p>Kod bez użycia odwołania do metody robiący dokładnie to samo wygląda trochę mniej skomplikowanie:</p>
<pre class="lang:default decode:true">Object objectInstance = new Object();<br />
System.out.println(objectInstance.hashCode());</pre></p>
<h1>Odwoływanie się do konstruktora</h1><br />
Notacja z <code>::</code> może być także użyta do odwołania się do konstruktora. W tym przypadku należy użyć <code>::</code> wraz ze słowem kluczowym <code>new</code>. Proszę spójrz na przykład poniżej:</p>
<pre class="lang:default decode:true ">Supplier<Object> objectCreator = Object::new;<br />
System.out.println(objectCreator.get());</pre><br />
W pierwszej linijce przykładu przypisuje konstruktor klasy <code>Object</code> do zmiennej <code>objectCreator</code>. Kolejna linijka to wywołanie konstruktora.</p>
<p>To samo bez użycia referencji metody możesz uzyskać w dobrze Ci znany sposób:</p>
<pre class="lang:default decode:true ">System.out.println(new Object());</pre></p>
<h1>Przykład zastosowania wyrażeń lambda i odwołania do metody</h1><br />
Załóżmy, że chcemy wypisać na konsoli liczby znajdujące się w kolekcji. Możemy to zrobić przy pomocy standardowej pętli, którą już znasz:</p>
<pre class="lang:default decode:true">List<Integer> numbers = Arrays.asList(1, 2, 3, 4);</p>
<p>for (Integer number : numbers) {<br />
    System.out.println(number);<br />
}</pre><br />
To samo zadanie można także zrobić przy pomocy wyrażeń lambda:</p>
<pre class="lang:default decode:true ">List<Integer> numbers = Arrays.asList(1, 2, 3, 4);<br />
Consumer<Integer> integerConsumer = n -> System.out.println(n);<br />
numbers.forEach(integerConsumer);</pre><br />
Pierwsza linijka to utworzenie listy z liczbami. Kolejna jest bardziej ciekawa, zawiera wyrażenie lambda, które konsumuje liczbę wypisując ją na konsoli. Ostatnia to wywołanie metody <code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-" target="_blank" rel="noopener">forEach</a></code> wraz z wyrażeniem lambda. Wyrażenie to zostanie wywołane dla każdego elementu.</p>
<p>Kod ten można jeszcze bardziej skrócić używając mechanizmu odwoływania się do metod:</p>
<pre class="lang:default decode:true ">List<Integer> numbers = Arrays.asList(1, 2, 3, 4);<br />
numbers.forEach(System.out::println);</pre><br />
Efekt działania wszystkich trzech fragmentów jest dokładnie taki sam. Różnią się między sobą sposobem rozwiązania danego problemu.</p>
<h1>Zadania</h1><br />
Na koniec mam dla Ciebie kilka zadań, które pomogą przećwiczyć Ci wiedzę z tego artykułu.</p>
<ol>
<li>Napisz program, który pobierze o użytkownika cztery łańcuchy znaków, które umieścisz w liście. Następnie posortuj tę listę używając metody <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-" target="_blank" rel="noopener"><code>sort</code></a>. Użyj wyrażenia lambda, które posortuje łańcuchy znaków malejąco po długości.</li>
<li>Napisz program, który wywoła funkcję <code>hashCode</code> na instancji klasy <code>Object</code> używając mechanizmu odwoływania się do metody (przy pomocy <code>::</code>).</li>
<li>Utwórz instancję klasy <code>Human</code> przy pomocy mechanizmu odwoływania się do konstruktora (przy pomocy <code>::</code>).
<pre class="lang:default decode:true">public class Human {</p>
<p>    private int age;<br />
    private String name;</p>
<p>    public Human(int age, String name) {<br />
        this.age = age;<br />
        this.name = name;<br />
    }</p>
<p>    public int getAge() {<br />
        return age;<br />
    }</p>
<p>    public String getName() {<br />
        return name;<br />
    }<br />
}</pre><br />
</li><br />
</ol><br />
Jeśli będziesz miał problem z rozwiązaniem zadań możesz rzucić okiem na <a href="https://github.com/SamouczekProgramisty/KursJava/tree/master/28_wyrazenia_lambda/src/main/java/pl/samouczekprogramisty/kursjava/lambdaexpressions/exercise" target="_blank" rel="noopener">przykładowe rozwiązania</a>, które umieściłem na samouczkowym githubie.</p>
<h1>Dodatkowe materiały do nauki</h1><br />
Przygotowałem dla Ciebie zestaw kilku linków z materiałami dodatkowymi:</p>
<ul>
<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" target="_blank" rel="noopener">Wprowadzenie do wyrażeń lambda na stronie Oracle</a>,</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Tutorial dotyczący wyrażeń lambda na stronie Oracle</a>,</li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.8" target="_blank" rel="noopener">Opis interfejsów funkcyjnych w JLS</a>,</li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13" target="_blank" rel="noopener">Referencja do metody w JLS</a>,</li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27" target="_blank" rel="noopener">Wyrażenia lambda w JLS</a>.</li><br />
</ul></p>
<h1>Podsumowanie</h1><br />
Wyrażenia lambda nie są proste. Mogą powodować sporo zakłopotania, szczególnie na początku. Jeśli jednak się do nich przyzwyczaisz pisanie kodu z ich udziałem będzie sprawiało Ci sporo frajdy :). Po pewnym czasie docenisz też zwięzłość wyrażeń lambda.</p>
<p>Po przeczytaniu artykułu wiesz czym są wyrażenia lambda i jak je stosować. Znasz też mechanizm odwoływania się do metod. Przećwiczyłeś te mechanizmy rozwiązując przykładowe zadania. Nie zapomnij pochwalić się w komentarzu gdzie ostatnio użyłeś wyrażeń lambda :).</p>
<p>Na koniec mam do Ciebie prośbę. Jeśli uważasz, że artykuł ten był dla Ciebie pomocny proszę podziel się nim ze swoimi znajomymi. Zależy mi na dotarciu do jak największej grupy czytelników a Ty możesz mi w tym pomóc. Jeśli nie chcesz pominąć żadnego nowego artykułu dopisz się do samouczkowego newslettera i polub samouczka na facebooku. Do następnego razu!</p>
<p>[FM_form id="3"]</p>
<p>Zdjęcie dzięki uprzejmości https://www.flickr.com/photos/rofi/2097239111/sizes/l</p>
