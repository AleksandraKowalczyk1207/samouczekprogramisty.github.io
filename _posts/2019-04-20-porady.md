---
title: Jak pisać kod wysokiej jakości w języku Java
last_modified_at: 2019-04-10 05:01:13 +0200
permalink: /jak-pisac-kod-wysokiej-jakosci-w-jezyku-java/
header:
    teaser: /assets/images/2019/04/20_jak_pisac_dobry_kod_w_javie_artykul.jpeg
    overlay_image: /assets/images/2019/04/20_jak_pisac_dobry_kod_w_javie_artykul.jpeg
    caption: "[&copy; Javier Allegue Barros](https://unsplash.com/photos/C7B-ExXpOIE)"
excerpt: W artykule przeczytasz o tym czym jest konwencja nazewnicza. Dowiesz się jak jej stosować. Pokażę Ci na przykładzie najczęściej popełniane błędy wraz z sugestiami jak można je poprawić.
---

Powtórzę to po raz kolejny. Uważam, że nauka przez praktykę to najlepsze rozwiązanie. Dlatego właśnie artykuły na Samouczku bardzo często zawierają zadania z przykładowymi rozwiązaniami. Sporo Czytelników rozwiązuje te zadania prosząc później o spojrzenie na kod krytycznym okiem.

Tego typu praktyka spotykana jest także w codziennej pracy programisty. Przeglądy kodu (ang. _code review_) to bardzo dobry sposób na poznawanie projektu i naukę. Najlepsze jest w tym wszystkim to, że uczy się zarówno osoba, która sprawdza jak i ta której kod jest sprawdzany. 

Na przestrzeni kilku lat prowadzenia Samouczka widziałem już różne przypadki. W tym artykule zbieram najczęściej popełniane błędy wraz z przykładem ich rozwiązania.

Część proponowanych tu rozwiązań jest subiektywna. Nie jest poparta żadną specyfikacją czy dokładnym opisem „u źródła”. Masz prawo nie zgadzać się z moją opinią, z chęcią usłyszę Twój punkt widzenia w komentarzach.
{:.notice--info}

## Uwagi ogólne

Zanim zacznę opisywać jakiekolwiek standardy muszę zaznaczyć jedną bardzo ważną rzecz. Jeśli w projekcie, z którym pracujesz istnieje już jakaś konwencja proponuję nadal ją stosować. Jeśli wejdziesz między wrony, musisz krakać jak i one.

Jeśli Twoim zdaniem ta konwencja jest bez sensu porozmawiaj o tym z innymi członkami zespołu. Każdy przypadek powinien być rozpatrywany indywidualnie, a konsensus może usprawiedliwić zmianę istniejącej konwencji.

### Konwencja nazewnicza

W języku Java obowiązuje konwencja nazewnicza. Kompilator nie będzie marudził jeśli kod, który napiszesz nie będzie jej przestrzegał. Będzie marudziła kolejna osoba, która z tym kodem będzie pracowała. W praktyce często jest tak, że raz napisany kod czytany jest wielokrotnie. Często przez kogoś innego niż autor. Stosowanie konwencji nazewniczej pozwala na łatwiejsze zorientowanie się w kodzie, z którym się pracuje.

Mimo tego, że pisownia jest ważna to nie jest najważniejsza. Najabardziej istotne jest nadanie poszczególnym elementom dobrej nazwy. Pracuję w IT od 2007 roku, nadal nie potrafię tego robić dobrze. W branży IT panuje obiegowa opinia: 

> There are only two hard things in Computer Science: cache invalidation and naming things.

Istotne jest aby nazwy elementów (typów, parametrów, atrybutów, metod itd.) oddawały to co dany element zawiera/robi. Złe nazwy mogą wprowadzić w błąd, co może utrudnić zrozumienie kodu.

#### Typy

Klasy, typy wyliczeniowe, interfejsy powinny być nazwane zgodnie z [PascalCase](https://pl.wikipedia.org/wiki/PascalCase). Oznacza to tyle, że nazwy powinny być jednym ciągiem znaków, w którym każde kolejne słowo zaczyna się od wielkiej litery. Dobrze, jeśli te nazwy są rzeczownikami. Problem jest z akronimami, nawet JDK nie zachowuje tu konwencji – część akronimów pisana jest wielkimi literami (na przykład `URL`), część używając PascalCase (na przykład `Http`). W tym przypadku proponuję Ci używanie pierwszego podejścia.

Moim zdaniem przykłady poniżej pokazują nazwy, które można poprawić:

```java
// incorrect
class anonymousUser {
}

interface Bus_driver {
}

enum color {
}
```

Poprawnymi przykładami nazw mogą być:

```java
// correct
class User {
}

interface PageCollector {
}

enum URLSchema {
}
```

#### Metody, parametry, atrybuty

Metody w języku java zwykło się nazywać używając [camelCase](https://pl.wikipedia.org/wiki/CamelCase). Oznacza to tyle, że pierwsze słowo pisane jest małą literą. Każdy kolejny wyraz zaczyna się wielką literą. Przykładami poprawnych nazw mogą być:

```java
// correct
class CodeExecutor {
    String snippet;
    int returnCode;

    Future<Integer> executeAsynchronously() {
        // ...
    }
}
```

#### Stałe

Swego rodzaju wyjątkiem od reguły są stałe – atrybuty przypisane do klasy oznaczone słowem kluczowym `final`. Te powinny być pisane wyłącznie wielkimi literami używając [SCREAMING_SNAKE_CASE](https://en.wikipedia.org/wiki/Snake_case). Poszczególne słowa pisane wielkimi literami powinny być oddzielone symbolem `_`. Na przykład:

```java
// correct
class Math {
    public static final PI_SQUARE = 3.14 * 3.14;
}
```

#### Pakiety

Mimo tego, że Java pozwala na używanie domyślnego pakietu nie jest to zalecane. Przyjęło się, że nazwa pakietu skłąda się z małych liter oddzielonych kropkami. Każdy z członów opisuje bardziej szczegółowo swoją zwartość.

Przyjęło się, że pakiety mają postać „odwróconej domeny”:

```java
// incorrect
package pckg.pl;
```
```java
// correct
package pl.samouczekprogramisty.kursjava.loops;
```

### Formatowanie kodu

Nie chcę rozpoczynać świętej wojny. Niektórzy programiści bronią formatowania, do którego są przyzwyczajeni, jak niepodległości. Mam do tego bardziej pragmatyczne podejście. Używaj formatowania kodu. Niech IDE robi to za Ciebie, nie zastanawiaj się nad tym dopóki nie zacznie Ci ono przeszkadzać. Nie chcę się tu rozpisywać nad wyższością jednego formatowania nad drugim, to nie ma sensu. Istotne jest to, że brak formatowania kodu można traktować jako złą praktykę.

Moim zdaniem dobrym podejściem jest włączenie automatycznego formatowania kodu w IDE[^wyjatek]. W zależności od tego jakiego IDE używasz ta akcja może być wykonywana na przykład przed każdym zapisem pliku czy przed każdym commit'em do repozytorium. Dzięki temu możesz w ogóle zapomnieć o formatowaniu i skupić się na innych rzeczach. IDE zrobi to za Ciebie.

Istotne jest to, żeby wszystkie osoby, które pracują w danym projekcie używały spójnego formatowania kodu. Wachlowanie się commit'ami, które polegają tylko na zmianach w formatowaniu kodu nie jest dobrym pomysłem. Formatowanie kodu to konwencja, która musi być ustalonwa wspólnie przez cały zespół i konsekwentnie stosowana.

[^wyjatek]: Potrafię sobie wyobrazić wyjątki od tej reguły. Załóżmy, że pracujesz nad projektem, który nie jest pierwszej młodości. Znajdują się w nim pliki mające kilka lat i kilka tysięcy linii. Musisz poprawić błąd, który sprowadza się do zmiany kilku linijek. Łączenie tej zmiany z formatowaniem całego pliku przeważnie nie jest dobrym pomysłem.

### Bloki z jedną linią

Język Java pozwala na opuszczanie nawiasów `{ }` jeśli blok ma jedną linię. Tego typu konstrukcja może być na przykład użyta po warunku `if` czy pętli. Proszę spójrz na przykład poniżej:

```java
// incorrect
if (activeUser.isAnAdmin())
    allowedActions.add(Action.DELETION);

System.out.println("Some log message");
```

Moim zdaniem to bardzo zła praktyka. Może prowadzić do trudnych do znalezienia błędów. Co jeśli tylko użytkownik, który jest administratorem powinien móc dokonywać modyfikacji? Ktoś mógłby wprowadzić drobną zmianę:

```java
// incorrect
if (activeUser.isAnAdmin())
    allowedActions.add(Action.DELETION);
    allowedActions.add(Action.MODIFICATION);

System.out.println("Some log message");
```

Problem polega na tym, że taki fragment kodu powoduje, że każdy użytkownik mógłby wykonać modyfikację. Dlatego nawet przy jednoliniowych blokach należy używać nawiasów:

```java
// correct
if (activeUser.isAnAdmin()) {
    allowedActions.add(Action.DELETION);
}

System.out.println("Some log message");
```

### Flagi

Na początku mojej przygody z programowaniem pracowałem w Eurobanku. Nie zapomnę do końca życia strony w intranecie opisującej „kwiatki w kodzie”. Kwiatki w kodzie czyli radosną twórczość programistów, która po dłuższym zastanowieniu nie ma sensu. Dość dużą część tej strony zajmowały przykłady kodu z wyrażeniami logicznymi.

Proszę spójrz na kilka złych przykładów wraz z propozycjami jak można je poprawić:

```java
// incorrect
boolean parameter = // ...
if (parameter == true) {
    // ...
}
```
```java
// correct
boolean parameter = // ...
if (parameter) {
    // ...
}
```

Podobnie wyglądać może sytuacja z odwóceniem warunku
```java
// incorrect
if (parameter == false) {
    // ...
}
```
```java
// correct
if (!parameter) {
    // ...
}
```

Spotkałem się też z uzależnieniem wartośći zwracanej od zmienej typu `boolean`:

```java
// incorrect
if (parameter == true) {
    return false;
}
else {
    return true;
}
```
```java
// correct
return !parameter;
```

## Projekt

Problemy i złe praktyki na poziomie poszczególnych plików to czubek góry lodowej. Pod spodem kryją się większe problemy. Problemy związane z podejściem do samego projektu.

### Brak systemu kontroli wersji

Piszesz kod bez używania systemu kontroli wersji? Robisz błąd. System kontroli wersji jest narzędziem niezbędnym w pracy każdego programisty. Polecam Ci [Git'a]({{ '/kurs-git/' | absolute_url }}), który moim zdaniem jest standardem w branży.

### Brak testów jednostkowych

Piszesz kod bez testów jednostkowych? Robisz błąd. Moim zdaniem automatyczne testy jednostkowe w wielu przypakach są niezbędne. Nie będę się tu rozwodził nad tematyką testów. Zachęcam Cię do przeczytania artykułów:

* [Wprowadzenie do tematyki testów jednostkowych na przykładzie JUnit4]({% post_url 2016-10-29-testy-jednostkowe-z-junit %}) – jeśli nigdy nie udało Ci się pracować z testami zacznij od tego artykułu, 
* [Opis biblioteki JUnit5]({% post_url 2018-04-13-testy-jednostkowe-z-junit5 %}) – ten artykuł opisuje bibliotekę JUnit5,
* [Test Driven Development]({% post_url 2016-11-21-test-driven-development-na-przykladzie %}) – jak poznasz już bibliotekę do pisania testów czas zabrać się za TDD.

### Brak standardowego mechanizmu budowania

W idealnym świecie zbudowanie projektu powinno składać się z dwóch etapów:

1. Pobrania źródeł projektu, na przykład z [repozytorium Git'a]({{ '/kurs-git/' | absolute_url }}),
2. Uruchomienia narzędzia do budowania, które na podstawie plików konfiguracyjnych zbuduje projekt. 

Oba etapy powinny działać niezależnie od środowiska programisty. Drugi punkt rozwiązywany jest przez narzędzia takie jak Maven, Make, Rake, Gradle, Ant, Grunt itp. Jeśli do tej pory nie udało Ci się pracować z narzędziami tego typu zachęcam Cię do zajrzenia do artykułów opisujących Gradle:

* [Wstęp do Gradle]({% post_url 2017-01-19-wstep-do-gradle %}),
* [Pierwszy projekt z Gradle]({% post_url 2019-03-22-pierwszy-projekt-z-gradle %}).

### Niestandardowa struktura projektu

Organizacja plików w projekcie jest ważna. Podobnie jak z nazewnictwem czy formatowaniem kodu istnieje pewna konwencja, która pozwala na szybkie zorientowanie się w strukturze projektu. Niejako powiązane z tym tematem jest używanie narzędzie wspomagającego budowanie projektu, które „narzucają” urzywanie pewnych konwencji. Standardową strukturę projektu opisałem we [wstępie do Gradle]({% post_url 2017-01-19-wstep-do-gradle %}).

## Martwy kod

Historia w repozytorium jest od tego, żeby pamiętać co działo się w projekcie. Wykomentowane fragmenty kodu, które „może kiedyś się przydadzą” moim zdaniem powinny od razu wylecieć w kosmos. Nie są potrzebne, jedynie zaciemniają obraz. 

Kilka poniższych podpunktów opisuje różne przypadki, które można podsumować w jednym zdaniu: nie jest sztuką napisać dużo kodu, sztuką jest napisać jak najmniej czytelnego i zrozumiałego kodu, który robi to samo. Jeśli masz możliwość usunięcia czegoś, co nie jest używane zrób to! :) Mniej kodu oznacza mniej potencjalnych błędów. Mniej kodu, to niższy koszt jego utrzymania[^czytelny].

[^czytelny]: Jak napisałem wcześniej – zakładam, że kod jest napisany w sposób czytelny i zrozumiały. Nie chodzi mi tu o sytuację, w której używasz jednoliterowych nazw metod, żeby „było mniej kodu”.

Często jest tak, że fragmenty martwego kodu narastają z czasem – wynikają z kilku zmian wprowadzonych na przestrzeni życia projektu. Odwaga do usuwania kodu jest odwrotnie propoporcjonalna do jego wieku ;).

### Nadmiarowe warunki logiczne

Warunki logiczne często urastają do sporych potworków. Jeśli zauważysz jeden z nich, który ma zawsze taką samą wartość warto uprościć takie wyrażenie. Dzięki temu kod będzie bardziej czytelny. W przykładzie poniżej zakładam, że `variableThatAlwaysIsNull` w wyniku różnych operacji ma wartość `null`:

```java
// incorrect
Object variableThatAlwaysIsNull = methodAlwaysReturningNull();
boolean someMagicFlag = // ...

if (variableThatAlwaysIsNull == null && someMagicFlag) {
    // ...
}
```

```java
// correct
boolean someMagicFlag = // ...

if (someMagicFlag) {
    // ...
}
```

### Niepotrzebne parametry i atrybuty

Widzisz metodę, która ma nieużywany parametr? Zastanów się czy możesz go usunąć. Jeśli tak, to wiesz co masz zrobić ;). Podobną regułę trzeba stosować przy atrybutach klas.

Zwróć szczególną uwagę na zmianę sygnatury metody. Tego typu zmiany mogą prowadzić do „dziwnych zachowań”. Mam tu na myśli sytuację, w której metoda nadpisywała inną w klasie bazowej. Tu drobne ćwiczenie dla Ciebie – czym może skończyć się takie usunięcie parametru?

Usuwanie atrybutów, to też coś co wymaga pewnej analizy. W zależności od [modyfikatora dostępu]({% post_url 2017-10-29-modyfikatory-dostepu-w-jezyku-java %}) może, ale nie musi, łamać kompatybilność wsteczną.

### Zbędne metody

Nie zrozumi mnie źle. Uważam, że nieduże metody są dobre. Jednak także i tutaj trzeba zachować zdrowy rozsądek. Proszę spójrz na przykład poniżej, używa on klasy [`Math`](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Math.html):

```java
// incorrect
double someVeryImportantCalculation(double argument0, double argument1) {
    return argument0 + sqrt(argument1);
}

double sqrt(double argument) {
    return Math.sqrt(argument);
}
```

Moim zdaniem w tym przypadku wprowadzenie metody `sqrt` nic nie wnosi. Równie dobrze w miejscu jej wyłoania można byłoby użyć `Math.sqrt`.

```java
// correct
double someVeryImportantCalculation(double argument0, double argument1) {
    return argument0 + Math.sqrt(argument1);
}
```

### Nieużywana wartość zwracana

Widziałem przypadki, w których metoda wywoływana dla efektów ubocznych[^uboczne] zwracała wartość. Ta zwrócona wartość nie była w ogóle wykorzystywana. Moim zdaniem warto uprościć taką metodę usuwając wartość zwracaną:

[^uboczne]: Abstrahując od tego czy metody posiadające efekty uboczne są w porządku czy nie.

```java
// incorrect
class User {
    String login() {
        try {
            callingExternalServiceToLogin();
        }
        catch (LoginException e) {
            // handling exception
        }
        return "logged in";
    }
}
```
```
// correct
class User {
    void login() {
        try {
            callingExternalServiceToLogin();
        }
        catch (LoginException e) {
            // handling exception
        }
    }
}
```

## Tworzenie nadmiarowych obiektów

Tutaj sprawa trochę się komplikuje. [wątki]({% post_url 2019-02-11-watki-w-jezyku-java %})

Problem ten pokażę na przykładzie instancji klasy [`Scanner`](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Scanner.html):

## Znajomość JDK

### `System.in`, `System.out`, `System.err`

[`Scanner`](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Scanner.html) jest bardzo często używany do pobierania danych od użytkownika. Jednym ze sposobów utworzenia instancji tej klasy jest przekazanie jej instancji [`InputStream`](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/io/InputStream.html). Możesz na przykład użyć `System.in`. Proszę spójrz na przykład poniżej:

```java
// incorrect
public static void main(String[] args) {
    try(Scanner s = new Scanner(System.in)) {
        System.out.println(s.next());
    }
    try(Scanner s = new Scanner(System.in)) {
        System.out.println(s.next());
    }
}
```

Ten kod jest zły z dwóch powodów. Pierwszy to tworzenie dwóch instancji klasy `Scanner`, w tym przypadku spokojne wystarczy jeden obiekt i jego użycie wiele razy. Drugim, poważniejszym błędem jest zamykanie `System.in`. Dzieje się tak, ponieważ po wyjściu z bloku [_try with resources_]({% post_url 2016-08-25-konstrukcja-try-with-resources-w-jezyku-java %}) na instancji `s` wywoływana jest metoda `close`. Powoduje to zamknięcie `System.in`. Uruchom powyższy kod i zobacz jaki będzie jego efekt.

Nie jest to dobra praktyka. To wirtualna maszyna Javy otwiera ten strumień i to ona jest odpowiedzialna za jego zamknięcie. Sprawa wygląda podobnie w przypadku strumieni `System.out` czy `System.err`.

Jeśli chcesz przeczytać więcej o stdout, stderr i stdin w trochę innym kontekście zapraszam do przeczytania artykułu opisującego [początki pracy z linią poleceń]({% post_url 2019-03-12-poczatki-pracy-z-konsola %}).

Poniżej możesz zobaczyć poprawiony fragment kodu:

```java
// correct
public static void main(String[] args) {
    Scanner s = new Scanner(System.in);
    System.out.println(s.next());
    System.out.println(s.next());
}
```

### Znak końca linii

Java pozwala tworzyć programy, które mogą być uruchamiane na różnych systemach operacyjnych. Żeby programy te działały w pełni poprawnie trzeba brać pod uwagę różnice, które występują pomiędzy nimi. 

Sztandarowym przykładem jest tutaj znak końca linii. W zależności od systemu operacyjnego inny ciąg znaków odpowiedzialny jest za łamianie linii. Poniższy przykład pokazuje błąd i jego rozwiązanie:

```java
// incorrect
System.out.println("This is an\nexample.");
```
```java
// correct
System.out.println("This is an" + System.lineSeparator() + "example.");
```

### Kompilacja wyrażenia regularnego

[Wyrażenia regularne]({% post_url 2016-11-28-wyrazenia-regularne-w-jezyku-java %}) i [bardziej zaawansowane wyrażenia regularne]({% post_url 2017-01-06-wyrazenia-regularne-czesc-2 %}) byly już poruszane na blogu.

Tutaj chciałbym zwrócić na jeden drobny szczegół. Proszę rzuć okiem na kod poniżej:

```java
// incorrect
class Postcode {
    public static boolean isValid(String postcode) {
        Pattern postcodePattern = Pattern.compile("^\\d{2}-\\d{3}$");
        Matcher matcher = postcodePattern.matcher(postcode);
        return matcher.find();
    }
}
```

Kompilacja wyrażenia regularnego jest procesem długotrwałym. Jeśli jest taka możliwość to warto wykonywać tę czynność tylko raz:

```java
// correct
class Postcode {
    public static final Pattern PATTERN = Pattern.compile("^\\d{2}-\\d{3}$");

    public static boolean isValid(String postcode) {
        Matcher matcher = PATTERN.matcher(postcode);
        return matcher.find();
    }
}

### Znajomość wbudowanych wyjątków

Dobrze jest używać wyjątków, TODO

```java
public 


– IllegalArgumentException wydaje mi się lepszym wyjątkiem,


## Duplikacja kodu

Jakiś czas temu pisałem o [regule _Don't Repeat Yourself_]({% post_url 2018-09-28-jakosc-kodu-a-oschle-pocalunki-jagny %}). Można ją zastosować na wielu poziomach. Jednym z nich jest kod źródłowy programu. Duplikacja w kodzie jest zła. Należy ją elminować (już wiesz, że jestem gorącym zwolennikiem usuwania kodu). Poniższy przykład pokazuje duplikację w bardzo wąskim zakresie:

```java
// incorrect
class MagicNumber {
    private int value;

    public boolean isEven() {
        return value % 2 == 0;
    }

    public boolean isOdd() {
        return value % 2 == 1;
    }
}
```

```java
// correct
class MagicNumber {
    private int value;

    public boolean isEven() {
        return value % 2 == 0;
    }

    public boolean isOdd() {
        return !isEven();
    }
}
```

## Dodatkowe materiały do nauki

Do tej pory nie nazwałem tego wprost. Wprowadzanie zmian, które nie modyfikują zachowania programu to tak zwana refaktoryzacja. Zacznij od przeczytania czym jest refaktoryzacja w [artykule na Wikipedii](https://pl.wikipedia.org/wiki/Refaktoryzacja). Później możesz sięgnąć po książkę [Refacttoring autorstwa Martin'a Fowler'a](https://martinfowler.com/articles/refactoring-2nd-ed.html). Pierwsza edycja zawiera przykłady w Javie, druga w JavaScript.

Możesz też rzucić okiem na dość stary dokument opisujący [konwencja nazewnicza w języku Java](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf). Opisuje on też zalecane formatowanie kodu.

## Podsumowanie

Moją motywacją do napisania tego artykułu było zebranie w jednym miejscu błędów i propozycji ich rozwiązania. Temat bynajmniej nie jest wyczerpany. Większość z tych punktów można rozbudować podając więcej przykładów. 

Jednak nawet w obecnej formie artykuł pokazał Ci większość klas „podstawowych błędów”. Po jego lekturze wiesz jak można je poprawić. Stosując się do zaleceń, któ©e tu zebrałem Twój kod będzie na pewno wyższej jakości. Z góry gratuluję ;). 

Jeśli znasz kogoś dla kogo ten artykuł byłby pomocny proszę podziel się linkiem. Dzięki temu pomożesz mi dotrzeć do nowych Czytelników, za co od razu bardzo dziękuję! 

Jeśli nie chcesz pomiąć kolejnych artykułów polub [Samouczka na Facebooku](https://www.facebook.com/SamouczekProgramisty/) i dopisz się do samouczkowego newslettera. To tyle na dzisiaj, trzymaj się i do następnego razu!

@@@@@@@

– subiektywne, ale kod:

if (something) {
    // return/throw/break/continue
}
else {
    // something else
}

wolę jako (dzięki drowi Pawłowi Rogalińskiemu):

if (something) {
    // return/throw/break/continue
}
// something else

Dodatkowo metodę statyczną wywołabym na klasie, nie na instancji:

<pre>
Klasa instancja = new Klasa();
instancja.metoda();

Klasa.metodaStatyczna();
</pre>

– pusty blok <code>if</code> jest słaby, lepiej zastosuj odwrócony warunek – <code>!=</code>,

– zwróciłeś mi uwagę na coś co można zrobić lepiej w przykładowym kodzie, który pokazałem – <code>java.util.Date</code> ma słabą prasę ;). Dużo lepszym pomysłem jest użycie <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDate.html"><code>java.time.LocalDate</code></a>,
– <code>@IsDate</code> nie nadaje się do parametru, który jest typu <code>Date</code>,
– w tym przypadku walidacje na parametrach konstruktora raczej nie mają sensu (masz to samo w atrybutach klasy),
– jak zadziała Twój walidator jeśli będzie musiał sprawdzić poprawność pustego łańcucha znaków?
– spróbuj przenieść komunikaty błędów do plików properties.

– w repozytorium rozdzielaj kod na pliki jakie masz w swoim edytorze.

– spróbuj try with resources

– rzuć okiem na <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/String.html#join(java.lang.CharSequence,java.lang.CharSequence...)"><code>String.join</code></a>,
– subiektywna opinia – nie podchodzą mi importy z `*`, moim zdaniem bardziej czytelne są importy, które są "jawne",
– <code>toString</code> w <code>WordSort</code> możesz zrobić używając <code>String.join</code>,
– dobrą praktyką jest wyciąganie regexpów, które się nie zmieniają poza metody,
– rzuć okiem na <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Integer.html#compare(int,int)"><code>Integer.compare</code></a>,
– uważaj z zamykaniem <code>System.in</code>,
– jak dojdziesz do <a href="http://www.samouczekprogramisty.pl/wyrazenia-lambda-w-jezyku-java/">wyrażeń lambda</a> wróć do tych ćwiczeń i zastanów się co możesz poprawić.


Kilka standardowych uwag:

– rozdziel metody na mniejsze, z pojedynczym zakresem odpowiedzialności,
– enkapsulacja – stosuj <a href="https://www.samouczekprogramisty.pl/modyfikatory-dostepu-w-jezyku-java/">modyfikatory dostępu</a>,
– powtarzający się kod wyciągaj do oddzielnych klas/metod,
– jaka jest domyślna wartość w tablicy <code>int[]</code>?,
– nie potrzebujesz zmiennej lokalnej, zamiast <code>%=</code> możesz użyć po prostu <code>%</code>,
– staraj się nazywać zmienne w sposób, który mówi co zawierają (liczba2, arg1 przeważnie mają lepsze odpowiedniki),

Poniżej kilka uwag, które przyszły mi do głowy:
– instanceof w metodzie printInfo jest do usunięcia, spróbuj zostawić funkcjonalność tej metody bez użycia tego operatora,
– w repozytorium trzymaj kod w formie, która może być w prosty sposób zaimportowana do IDE (poprawne pliki java),
– przyjrzyj się stałej Math.PI,
– nie zamykaj Scanner'a przypiętego do System.in. JVM otwiera ten plik i JVM go zamyka,
– do niektórych zadań możesz napisać testy jednostkowe, to lepszy sposób sprawdzania poprawności kodu,
– spróbuj sprawdzić czy słowo jest palindromem używając pętli,
– jaka jest wartość domyślna elementów pustej tablicy int[]?
– nie dodawaj znaku nowej linii samodzielnie, użyj System.lineSeparator(),
– jak zachowa się Twoja implementacja zadania 9 z pętli jeśli przekażesz pustą tablicę?
– używaj <code>System.lineSeparator()</code>,
